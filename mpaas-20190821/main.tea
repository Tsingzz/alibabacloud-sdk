import Util;
import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-hangzhou = 'mpaas.aliyuncs.com',
    ap-northeast-1 = 'mpaas.aliyuncs.com',
    ap-northeast-2-pop = 'mpaas.aliyuncs.com',
    ap-south-1 = 'mpaas.aliyuncs.com',
    ap-southeast-1 = 'mpaas.aliyuncs.com',
    ap-southeast-2 = 'mpaas.aliyuncs.com',
    ap-southeast-3 = 'mpaas.aliyuncs.com',
    ap-southeast-5 = 'mpaas.aliyuncs.com',
    cn-beijing = 'mpaas.aliyuncs.com',
    cn-beijing-finance-1 = 'mpaas.aliyuncs.com',
    cn-beijing-finance-pop = 'mpaas.aliyuncs.com',
    cn-beijing-gov-1 = 'mpaas.aliyuncs.com',
    cn-beijing-nu16-b01 = 'mpaas.aliyuncs.com',
    cn-chengdu = 'mpaas.aliyuncs.com',
    cn-edge-1 = 'mpaas.aliyuncs.com',
    cn-fujian = 'mpaas.aliyuncs.com',
    cn-haidian-cm12-c01 = 'mpaas.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'mpaas.aliyuncs.com',
    cn-hangzhou-finance = 'mpaas.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'mpaas.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'mpaas.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'mpaas.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'mpaas.aliyuncs.com',
    cn-hangzhou-test-306 = 'mpaas.aliyuncs.com',
    cn-hongkong = 'mpaas.aliyuncs.com',
    cn-hongkong-finance-pop = 'mpaas.aliyuncs.com',
    cn-huhehaote = 'mpaas.aliyuncs.com',
    cn-north-2-gov-1 = 'mpaas.aliyuncs.com',
    cn-qingdao = 'mpaas.aliyuncs.com',
    cn-qingdao-nebula = 'mpaas.aliyuncs.com',
    cn-shanghai = 'mpaas.aliyuncs.com',
    cn-shanghai-et15-b01 = 'mpaas.aliyuncs.com',
    cn-shanghai-et2-b01 = 'mpaas.aliyuncs.com',
    cn-shanghai-finance-1 = 'mpaas.aliyuncs.com',
    cn-shanghai-inner = 'mpaas.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'mpaas.aliyuncs.com',
    cn-shenzhen = 'mpaas.aliyuncs.com',
    cn-shenzhen-finance-1 = 'mpaas.aliyuncs.com',
    cn-shenzhen-inner = 'mpaas.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'mpaas.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'mpaas.aliyuncs.com',
    cn-wuhan = 'mpaas.aliyuncs.com',
    cn-yushanfang = 'mpaas.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'mpaas.aliyuncs.com',
    cn-zhangjiakou = 'mpaas.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'mpaas.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'mpaas.aliyuncs.com',
    eu-central-1 = 'mpaas.aliyuncs.com',
    eu-west-1 = 'mpaas.aliyuncs.com',
    eu-west-1-oxs = 'mpaas.aliyuncs.com',
    me-east-1 = 'mpaas.aliyuncs.com',
    rus-west-1-pop = 'mpaas.aliyuncs.com',
    us-east-1 = 'mpaas.aliyuncs.com',
    us-west-1 = 'mpaas.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('mpaas', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model DeleteMpaasMrtcArtvcRecordfileRequest = {
  appId?: string(name='AppId', description='AppId'),
  bizAppCode?: string(name='BizAppCode', description='BizAppCode'),
  bizName?: string(name='BizName', description='BizName'),
  bizRequestId?: string(name='BizRequestId', description='BizRequestId'),
  mediaType?: string(name='MediaType', description='MediaType'),
  recordId?: string(name='RecordId', description='RecordId'),
  roomId?: string(name='RoomId', description='RoomId'),
  s?: string(name='S', description='S'),
  tenantId?: string(name='TenantId', description='TenantId'),
  workspaceId?: string(name='WorkspaceId', description='WorkspaceId'),
}

model DeleteMpaasMrtcArtvcRecordfileResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  mrtcApiRecordFileQueryWrapResp: {
    code: string(name='Code', description='Code'),
    msg: string(name='Msg', description='Msg'),
    data: {
      bizRequestId: string(name='BizRequestId', description='BizRequestId'),
      filePath: string(name='FilePath', description='FilePath'),
      fileType: string(name='FileType', description='FileType'),
      recordStartTime: string(name='RecordStartTime', description='RecordStartTime'),
      status: string(name='Status', description='Status'),
    }(name='Data', description='Data'),
  }(name='MrtcApiRecordFileQueryWrapResp', description='MrtcApiRecordFileQueryWrapResp'),
}

async function deleteMpaasMrtcArtvcRecordfileWithOptions(request: DeleteMpaasMrtcArtvcRecordfileRequest, runtime: Util.RuntimeOptions): DeleteMpaasMrtcArtvcRecordfileResponse {
  Util.validateModel(request);
  return doRequest('DeleteMpaasMrtcArtvcRecordfile', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function deleteMpaasMrtcArtvcRecordfile(request: DeleteMpaasMrtcArtvcRecordfileRequest): DeleteMpaasMrtcArtvcRecordfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMpaasMrtcArtvcRecordfileWithOptions(request, runtime);
}

model QueryMpaasMrtcArtvcRecordfileRequest = {
  appId?: string(name='AppId', description='AppId'),
  bizAppCode?: string(name='BizAppCode', description='BizAppCode'),
  bizName?: string(name='BizName', description='BizName'),
  bizRequestId?: string(name='BizRequestId', description='BizRequestId'),
  mediaType?: string(name='MediaType', description='MediaType'),
  recordId?: string(name='RecordId', description='RecordId'),
  roomId?: string(name='RoomId', description='RoomId'),
  s?: string(name='S', description='S'),
  tenantId?: string(name='TenantId', description='TenantId'),
  workspaceId?: string(name='WorkspaceId', description='WorkspaceId'),
}

model QueryMpaasMrtcArtvcRecordfileResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  mrtcApiRecordFileQueryWrapResp: {
    code: string(name='Code', description='Code'),
    msg: string(name='Msg', description='Msg'),
    data: {
      bizRequestId: string(name='BizRequestId', description='BizRequestId'),
      filePath: string(name='FilePath', description='FilePath'),
      fileType: string(name='FileType', description='FileType'),
      recordStartTime: string(name='RecordStartTime', description='RecordStartTime'),
      status: string(name='Status', description='Status'),
    }(name='Data', description='Data'),
  }(name='MrtcApiRecordFileQueryWrapResp', description='MrtcApiRecordFileQueryWrapResp'),
}

async function queryMpaasMrtcArtvcRecordfileWithOptions(request: QueryMpaasMrtcArtvcRecordfileRequest, runtime: Util.RuntimeOptions): QueryMpaasMrtcArtvcRecordfileResponse {
  Util.validateModel(request);
  return doRequest('QueryMpaasMrtcArtvcRecordfile', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function queryMpaasMrtcArtvcRecordfile(request: QueryMpaasMrtcArtvcRecordfileRequest): QueryMpaasMrtcArtvcRecordfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMpaasMrtcArtvcRecordfileWithOptions(request, runtime);
}

model ListMcubeMiniTasksRequest = {
  appId: string(name='AppId', description='AppId'),
  id: string(name='Id', description='Id'),
  tenantId: string(name='TenantId', description='TenantId'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model ListMcubeMiniTasksResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  listMiniTaskResult: {
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
    miniTaskList: [
      {
        appCode: string(name='AppCode', description='AppCode'),
        gmtCreate: string(name='GmtCreate', description='GmtCreate'),
        gmtModified: string(name='GmtModified', description='GmtModified'),
        greyConfigInfo: string(name='GreyConfigInfo', description='GreyConfigInfo'),
        greyEndtime: string(name='GreyEndtime', description='GreyEndtime'),
        greyEndtimeData: string(name='GreyEndtimeData', description='GreyEndtimeData'),
        greyNum: long(name='GreyNum', description='GreyNum'),
        id: long(name='Id', description='Id'),
        memo: string(name='Memo', description='Memo'),
        packageId: long(name='PackageId', description='PackageId'),
        platform: string(name='Platform', description='Platform'),
        productVersion: string(name='ProductVersion', description='ProductVersion'),
        publishMode: long(name='PublishMode', description='PublishMode'),
        publishType: long(name='PublishType', description='PublishType'),
        status: string(name='Status', description='Status'),
        taskStatus: long(name='TaskStatus', description='TaskStatus'),
        whitelistIds: string(name='WhitelistIds', description='WhitelistIds'),
      }
    ](name='MiniTaskList', description='MiniTaskList'),
  }(name='ListMiniTaskResult', description='ListMiniTaskResult'),
}

async function listMcubeMiniTasksWithOptions(request: ListMcubeMiniTasksRequest, runtime: Util.RuntimeOptions): ListMcubeMiniTasksResponse {
  Util.validateModel(request);
  return doRequest('ListMcubeMiniTasks', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function listMcubeMiniTasks(request: ListMcubeMiniTasksRequest): ListMcubeMiniTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcubeMiniTasksWithOptions(request, runtime);
}

model ListMcubeMiniPackagesRequest = {
  appId: string(name='AppId', description='AppId'),
  h5Id: string(name='H5Id', description='H5Id'),
  packageTypes: string(name='PackageTypes', description='PackageTypes'),
  tenantId: string(name='TenantId', description='TenantId'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model ListMcubeMiniPackagesResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  listMiniPackageResult: {
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
    miniPackageList: [
      {
        appCode: string(name='AppCode', description='AppCode'),
        autoInstall: long(name='AutoInstall', description='AutoInstall'),
        clientVersionMax: string(name='ClientVersionMax', description='ClientVersionMax'),
        clientVersionMin: string(name='ClientVersionMin', description='ClientVersionMin'),
        downloadUrl: string(name='DownloadUrl', description='DownloadUrl'),
        extendInfo: string(name='ExtendInfo', description='ExtendInfo'),
        extraData: string(name='ExtraData', description='ExtraData'),
        fallbackBaseUrl: string(name='FallbackBaseUrl', description='FallbackBaseUrl'),
        gmtCreate: string(name='GmtCreate', description='GmtCreate'),
        gmtModified: string(name='GmtModified', description='GmtModified'),
        h5Id: string(name='H5Id', description='H5Id'),
        h5Name: string(name='H5Name', description='H5Name'),
        h5Version: string(name='H5Version', description='H5Version'),
        id: long(name='Id', description='Id'),
        installType: long(name='InstallType', description='InstallType'),
        mainUrl: string(name='MainUrl', description='MainUrl'),
        memo: string(name='Memo', description='Memo'),
        packageType: long(name='PackageType', description='PackageType'),
        platform: string(name='Platform', description='Platform'),
        publishPeriod: long(name='PublishPeriod', description='PublishPeriod'),
        resourceType: long(name='ResourceType', description='ResourceType'),
        status: long(name='Status', description='Status'),
      }
    ](name='MiniPackageList', description='MiniPackageList'),
  }(name='ListMiniPackageResult', description='ListMiniPackageResult'),
}

async function listMcubeMiniPackagesWithOptions(request: ListMcubeMiniPackagesRequest, runtime: Util.RuntimeOptions): ListMcubeMiniPackagesResponse {
  Util.validateModel(request);
  return doRequest('ListMcubeMiniPackages', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function listMcubeMiniPackages(request: ListMcubeMiniPackagesRequest): ListMcubeMiniPackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcubeMiniPackagesWithOptions(request, runtime);
}

model GetMcubeFileTokenRequest = {
  appId: string(name='AppId', description='AppId'),
  onexFlag: boolean(name='OnexFlag', description='OnexFlag'),
  tenantId: string(name='TenantId', description='TenantId'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model GetMcubeFileTokenResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  getFileTokenResult: {
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
    fileToken: {
      accessid: string(name='Accessid', description='Accessid'),
      dir: string(name='Dir', description='Dir'),
      expire: string(name='Expire', description='Expire'),
      host: string(name='Host', description='Host'),
      policy: string(name='Policy', description='Policy'),
      signature: string(name='Signature', description='Signature'),
    }(name='FileToken', description='FileToken'),
  }(name='GetFileTokenResult', description='GetFileTokenResult'),
}

async function getMcubeFileTokenWithOptions(request: GetMcubeFileTokenRequest, runtime: Util.RuntimeOptions): GetMcubeFileTokenResponse {
  Util.validateModel(request);
  return doRequest('GetMcubeFileToken', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function getMcubeFileToken(request: GetMcubeFileTokenRequest): GetMcubeFileTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMcubeFileTokenWithOptions(request, runtime);
}

model UpdateMcubeWhitelistRequest = {
  appId: string(name='AppId', description='AppId'),
  id: string(name='Id', description='Id'),
  keyIds?: string(name='KeyIds', description='KeyIds'),
  onexFlag: boolean(name='OnexFlag', description='OnexFlag'),
  ossUrl?: string(name='OssUrl', description='OssUrl'),
  tenantId: string(name='TenantId', description='TenantId'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model UpdateMcubeWhitelistResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  addWhitelistResult: {
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
    addWhitelistInfo: {
      failNum: long(name='FailNum', description='FailNum'),
      failUserIds: string(name='FailUserIds', description='FailUserIds'),
      successNum: long(name='SuccessNum', description='SuccessNum'),
    }(name='AddWhitelistInfo', description='AddWhitelistInfo'),
  }(name='AddWhitelistResult', description='AddWhitelistResult'),
}

async function updateMcubeWhitelistWithOptions(request: UpdateMcubeWhitelistRequest, runtime: Util.RuntimeOptions): UpdateMcubeWhitelistResponse {
  Util.validateModel(request);
  return doRequest('UpdateMcubeWhitelist', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function updateMcubeWhitelist(request: UpdateMcubeWhitelistRequest): UpdateMcubeWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMcubeWhitelistWithOptions(request, runtime);
}

model DeleteMcubeWhitelistRequest = {
  appId: string(name='AppId', description='AppId'),
  id: long(name='Id', description='Id'),
  tenantId: string(name='TenantId', description='TenantId'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model DeleteMcubeWhitelistResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  deleteWhitelistResult: {
    data: string(name='Data', description='Data'),
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
  }(name='DeleteWhitelistResult', description='DeleteWhitelistResult'),
}

async function deleteMcubeWhitelistWithOptions(request: DeleteMcubeWhitelistRequest, runtime: Util.RuntimeOptions): DeleteMcubeWhitelistResponse {
  Util.validateModel(request);
  return doRequest('DeleteMcubeWhitelist', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function deleteMcubeWhitelist(request: DeleteMcubeWhitelistRequest): DeleteMcubeWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMcubeWhitelistWithOptions(request, runtime);
}

model CreateMcubeMiniTaskRequest = {
  appId: string(name='AppId', description='AppId'),
  greyConfigInfo?: string(name='GreyConfigInfo', description='GreyConfigInfo'),
  greyEndtimeData?: string(name='GreyEndtimeData', description='GreyEndtimeData'),
  greyNum?: long(name='GreyNum', description='GreyNum'),
  memo: string(name='Memo', description='Memo'),
  packageId: long(name='PackageId', description='PackageId'),
  publishMode: long(name='PublishMode', description='PublishMode'),
  publishType: long(name='PublishType', description='PublishType'),
  tenantId: string(name='TenantId', description='TenantId'),
  whitelistIds?: string(name='WhitelistIds', description='WhitelistIds'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model CreateMcubeMiniTaskResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  createMiniTaskResult: {
    miniTaskId: string(name='MiniTaskId', description='MiniTaskId'),
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
  }(name='CreateMiniTaskResult', description='CreateMiniTaskResult'),
}

async function createMcubeMiniTaskWithOptions(request: CreateMcubeMiniTaskRequest, runtime: Util.RuntimeOptions): CreateMcubeMiniTaskResponse {
  Util.validateModel(request);
  return doRequest('CreateMcubeMiniTask', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function createMcubeMiniTask(request: CreateMcubeMiniTaskRequest): CreateMcubeMiniTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeMiniTaskWithOptions(request, runtime);
}

model ExistMcubeRsaKeyRequest = {
  appId: string(name='AppId', description='AppId'),
  tenantId: string(name='TenantId', description='TenantId'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model ExistMcubeRsaKeyResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  checkRsaKeyResult: {
    data: string(name='Data', description='Data'),
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
  }(name='CheckRsaKeyResult', description='CheckRsaKeyResult'),
}

async function existMcubeRsaKeyWithOptions(request: ExistMcubeRsaKeyRequest, runtime: Util.RuntimeOptions): ExistMcubeRsaKeyResponse {
  Util.validateModel(request);
  return doRequest('ExistMcubeRsaKey', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function existMcubeRsaKey(request: ExistMcubeRsaKeyRequest): ExistMcubeRsaKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return existMcubeRsaKeyWithOptions(request, runtime);
}

model UploadMcubeMiniPackageRequest = {
  appId: string(name='AppId', description='AppId'),
  autoInstall: long(name='AutoInstall', description='AutoInstall'),
  clientVersionMax?: string(name='ClientVersionMax', description='ClientVersionMax'),
  clientVersionMin: string(name='ClientVersionMin', description='ClientVersionMin'),
  enableKeepAlive: string(name='EnableKeepAlive', description='EnableKeepAlive'),
  enableOptionMenu: string(name='EnableOptionMenu', description='EnableOptionMenu'),
  enableTabBar: long(name='EnableTabBar', description='EnableTabBar'),
  extendInfo?: string(name='ExtendInfo', description='ExtendInfo'),
  h5Id: string(name='H5Id', description='H5Id'),
  h5Name: string(name='H5Name', description='H5Name'),
  h5Version: string(name='H5Version', description='H5Version'),
  iconFileUrl: string(name='IconFileUrl', description='IconFileUrl'),
  installType: long(name='InstallType', description='InstallType'),
  mainUrl: string(name='MainUrl', description='MainUrl'),
  onexFlag: boolean(name='OnexFlag', description='OnexFlag'),
  packageType: long(name='PackageType', description='PackageType'),
  platform: string(name='Platform', description='Platform'),
  resourceFileUrl: string(name='ResourceFileUrl', description='ResourceFileUrl'),
  resourceType: long(name='ResourceType', description='ResourceType'),
  tenantId: string(name='TenantId', description='TenantId'),
  userId: string(name='UserId', description='UserId'),
  uuid?: string(name='Uuid', description='Uuid'),
  vhost: string(name='Vhost', description='Vhost'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model UploadMcubeMiniPackageResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  uploadMiniPackageResult: {
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
    returnPackageResult: {
      debugUrl: string(name='DebugUrl', description='DebugUrl'),
      packageId: string(name='PackageId', description='PackageId'),
      userId: string(name='UserId', description='UserId'),
    }(name='ReturnPackageResult', description='ReturnPackageResult'),
  }(name='UploadMiniPackageResult', description='UploadMiniPackageResult'),
}

async function uploadMcubeMiniPackageWithOptions(request: UploadMcubeMiniPackageRequest, runtime: Util.RuntimeOptions): UploadMcubeMiniPackageResponse {
  Util.validateModel(request);
  return doRequest('UploadMcubeMiniPackage', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function uploadMcubeMiniPackage(request: UploadMcubeMiniPackageRequest): UploadMcubeMiniPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadMcubeMiniPackageWithOptions(request, runtime);
}

model QueryMcubeMiniTaskRequest = {
  appId: string(name='AppId', description='AppId'),
  taskId: long(name='TaskId', description='TaskId'),
  tenantId: string(name='TenantId', description='TenantId'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model QueryMcubeMiniTaskResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  queryMiniTaskResult: {
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
    miniTaskInfo: {
      appCode: string(name='AppCode', description='AppCode'),
      gmtCreate: string(name='GmtCreate', description='GmtCreate'),
      gmtModified: string(name='GmtModified', description='GmtModified'),
      greyConfigInfo: string(name='GreyConfigInfo', description='GreyConfigInfo'),
      greyEndtime: string(name='GreyEndtime', description='GreyEndtime'),
      greyEndtimeData: string(name='GreyEndtimeData', description='GreyEndtimeData'),
      greyNum: long(name='GreyNum', description='GreyNum'),
      id: long(name='Id', description='Id'),
      memo: string(name='Memo', description='Memo'),
      packageId: long(name='PackageId', description='PackageId'),
      platform: string(name='Platform', description='Platform'),
      productVersion: string(name='ProductVersion', description='ProductVersion'),
      publishMode: long(name='PublishMode', description='PublishMode'),
      publishType: long(name='PublishType', description='PublishType'),
      status: string(name='Status', description='Status'),
      taskStatus: long(name='TaskStatus', description='TaskStatus'),
      whitelistIds: string(name='WhitelistIds', description='WhitelistIds'),
    }(name='MiniTaskInfo', description='MiniTaskInfo'),
  }(name='QueryMiniTaskResult', description='QueryMiniTaskResult'),
}

async function queryMcubeMiniTaskWithOptions(request: QueryMcubeMiniTaskRequest, runtime: Util.RuntimeOptions): QueryMcubeMiniTaskResponse {
  Util.validateModel(request);
  return doRequest('QueryMcubeMiniTask', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function queryMcubeMiniTask(request: QueryMcubeMiniTaskRequest): QueryMcubeMiniTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMcubeMiniTaskWithOptions(request, runtime);
}

model QueryMcubeMiniPackageRequest = {
  appId: string(name='AppId', description='AppId'),
  h5Id: string(name='H5Id', description='H5Id'),
  id: string(name='Id', description='Id'),
  tenantId: string(name='TenantId', description='TenantId'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model QueryMcubeMiniPackageResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  queryMiniPackageResult: {
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
    miniPackageInfo: {
      appCode: string(name='AppCode', description='AppCode'),
      autoInstall: long(name='AutoInstall', description='AutoInstall'),
      clientVersionMax: string(name='ClientVersionMax', description='ClientVersionMax'),
      clientVersionMin: string(name='ClientVersionMin', description='ClientVersionMin'),
      downloadUrl: string(name='DownloadUrl', description='DownloadUrl'),
      extendInfo: string(name='ExtendInfo', description='ExtendInfo'),
      extraData: string(name='ExtraData', description='ExtraData'),
      fallbackBaseUrl: string(name='FallbackBaseUrl', description='FallbackBaseUrl'),
      gmtCreate: string(name='GmtCreate', description='GmtCreate'),
      gmtModified: string(name='GmtModified', description='GmtModified'),
      h5Id: string(name='H5Id', description='H5Id'),
      h5Name: string(name='H5Name', description='H5Name'),
      h5Version: string(name='H5Version', description='H5Version'),
      id: long(name='Id', description='Id'),
      installType: long(name='InstallType', description='InstallType'),
      mainUrl: string(name='MainUrl', description='MainUrl'),
      memo: string(name='Memo', description='Memo'),
      packageType: long(name='PackageType', description='PackageType'),
      platform: string(name='Platform', description='Platform'),
      publishPeriod: long(name='PublishPeriod', description='PublishPeriod'),
      resourceType: long(name='ResourceType', description='ResourceType'),
      status: long(name='Status', description='Status'),
    }(name='MiniPackageInfo', description='MiniPackageInfo'),
  }(name='QueryMiniPackageResult', description='QueryMiniPackageResult'),
}

async function queryMcubeMiniPackageWithOptions(request: QueryMcubeMiniPackageRequest, runtime: Util.RuntimeOptions): QueryMcubeMiniPackageResponse {
  Util.validateModel(request);
  return doRequest('QueryMcubeMiniPackage', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function queryMcubeMiniPackage(request: QueryMcubeMiniPackageRequest): QueryMcubeMiniPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMcubeMiniPackageWithOptions(request, runtime);
}

model UploadMcubeRsaKeyRequest = {
  appId: string(name='AppId', description='AppId'),
  fileUrl: string(name='FileUrl', description='FileUrl'),
  onexFlag: boolean(name='OnexFlag', description='OnexFlag'),
  tenantId: string(name='TenantId', description='TenantId'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model UploadMcubeRsaKeyResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  uploadRsaResult: {
    data: string(name='Data', description='Data'),
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
  }(name='UploadRsaResult', description='UploadRsaResult'),
}

async function uploadMcubeRsaKeyWithOptions(request: UploadMcubeRsaKeyRequest, runtime: Util.RuntimeOptions): UploadMcubeRsaKeyResponse {
  Util.validateModel(request);
  return doRequest('UploadMcubeRsaKey', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function uploadMcubeRsaKey(request: UploadMcubeRsaKeyRequest): UploadMcubeRsaKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadMcubeRsaKeyWithOptions(request, runtime);
}

model DeleteMcubeMiniAppRequest = {
  appId: string(name='AppId', description='AppId'),
  h5Id: string(name='H5Id', description='H5Id'),
  tenantId: string(name='TenantId', description='TenantId'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model DeleteMcubeMiniAppResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  deleteMiniResult: {
    data: string(name='Data', description='Data'),
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
  }(name='DeleteMiniResult', description='DeleteMiniResult'),
}

async function deleteMcubeMiniAppWithOptions(request: DeleteMcubeMiniAppRequest, runtime: Util.RuntimeOptions): DeleteMcubeMiniAppResponse {
  Util.validateModel(request);
  return doRequest('DeleteMcubeMiniApp', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function deleteMcubeMiniApp(request: DeleteMcubeMiniAppRequest): DeleteMcubeMiniAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMcubeMiniAppWithOptions(request, runtime);
}

model CreateMcubeWhitelistRequest = {
  appId: string(name='AppId', description='AppId'),
  tenantId: string(name='TenantId', description='TenantId'),
  whitelistType: string(name='WhitelistType', description='WhitelistType'),
  whiteListName: string(name='WhiteListName', description='WhiteListName'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model CreateMcubeWhitelistResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  createWhitelistResult: {
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
    whitelistId: string(name='WhitelistId', description='WhitelistId'),
  }(name='CreateWhitelistResult', description='CreateWhitelistResult'),
}

async function createMcubeWhitelistWithOptions(request: CreateMcubeWhitelistRequest, runtime: Util.RuntimeOptions): CreateMcubeWhitelistResponse {
  Util.validateModel(request);
  return doRequest('CreateMcubeWhitelist', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function createMcubeWhitelist(request: CreateMcubeWhitelistRequest): CreateMcubeWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeWhitelistWithOptions(request, runtime);
}

model CreateMcubeWhitelistForIdeRequest = {
  appId: string(name='AppId', description='AppId'),
  tenantId: string(name='TenantId', description='TenantId'),
  userId: string(name='UserId', description='UserId'),
  whitelistValue: string(name='WhitelistValue', description='WhitelistValue'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model CreateMcubeWhitelistForIdeResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  createWhitelistForIdeResult: {
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
    whitelistId: string(name='WhitelistId', description='WhitelistId'),
  }(name='CreateWhitelistForIdeResult', description='CreateWhitelistForIdeResult'),
}

async function createMcubeWhitelistForIdeWithOptions(request: CreateMcubeWhitelistForIdeRequest, runtime: Util.RuntimeOptions): CreateMcubeWhitelistForIdeResponse {
  Util.validateModel(request);
  return doRequest('CreateMcubeWhitelistForIde', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function createMcubeWhitelistForIde(request: CreateMcubeWhitelistForIdeRequest): CreateMcubeWhitelistForIdeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeWhitelistForIdeWithOptions(request, runtime);
}

model ChangeMcubeMiniTaskStatusRequest = {
  appId: string(name='AppId', description='AppId'),
  bizType: string(name='BizType', description='BizType'),
  packageId: long(name='PackageId', description='PackageId'),
  taskId: long(name='TaskId', description='TaskId'),
  taskStatus: long(name='TaskStatus', description='TaskStatus'),
  tenantId: string(name='TenantId', description='TenantId'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model ChangeMcubeMiniTaskStatusResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  changeMiniTaskStatusResult: {
    data: string(name='Data', description='Data'),
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
  }(name='ChangeMiniTaskStatusResult', description='ChangeMiniTaskStatusResult'),
}

async function changeMcubeMiniTaskStatusWithOptions(request: ChangeMcubeMiniTaskStatusRequest, runtime: Util.RuntimeOptions): ChangeMcubeMiniTaskStatusResponse {
  Util.validateModel(request);
  return doRequest('ChangeMcubeMiniTaskStatus', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function changeMcubeMiniTaskStatus(request: ChangeMcubeMiniTaskStatusRequest): ChangeMcubeMiniTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeMcubeMiniTaskStatusWithOptions(request, runtime);
}

model CreateMcubeVhostRequest = {
  appId: string(name='AppId', description='AppId'),
  tenantId: string(name='TenantId', description='TenantId'),
  vhost: string(name='Vhost', description='Vhost'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model CreateMcubeVhostResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  createVhostResult: {
    data: string(name='Data', description='Data'),
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
  }(name='CreateVhostResult', description='CreateVhostResult'),
}

async function createMcubeVhostWithOptions(request: CreateMcubeVhostRequest, runtime: Util.RuntimeOptions): CreateMcubeVhostResponse {
  Util.validateModel(request);
  return doRequest('CreateMcubeVhost', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function createMcubeVhost(request: CreateMcubeVhostRequest): CreateMcubeVhostResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeVhostWithOptions(request, runtime);
}

model CreateMcubeMiniAppRequest = {
  appId: string(name='AppId', description='AppId'),
  h5Id: string(name='H5Id', description='H5Id'),
  h5Name: string(name='H5Name', description='H5Name'),
  tenantId: string(name='TenantId', description='TenantId'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model CreateMcubeMiniAppResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  createMiniResult: {
    data: string(name='Data', description='Data'),
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
  }(name='CreateMiniResult', description='CreateMiniResult'),
}

async function createMcubeMiniAppWithOptions(request: CreateMcubeMiniAppRequest, runtime: Util.RuntimeOptions): CreateMcubeMiniAppResponse {
  Util.validateModel(request);
  return doRequest('CreateMcubeMiniApp', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function createMcubeMiniApp(request: CreateMcubeMiniAppRequest): CreateMcubeMiniAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeMiniAppWithOptions(request, runtime);
}

model QueryMcubeVhostRequest = {
  appId: string(name='AppId', description='AppId'),
  tenantId: string(name='TenantId', description='TenantId'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model QueryMcubeVhostResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  queryVhostResult: {
    data: string(name='Data', description='Data'),
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
  }(name='QueryVhostResult', description='QueryVhostResult'),
}

async function queryMcubeVhostWithOptions(request: QueryMcubeVhostRequest, runtime: Util.RuntimeOptions): QueryMcubeVhostResponse {
  Util.validateModel(request);
  return doRequest('QueryMcubeVhost', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function queryMcubeVhost(request: QueryMcubeVhostRequest): QueryMcubeVhostResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMcubeVhostWithOptions(request, runtime);
}

model ListMcubeMiniAppsRequest = {
  appId: string(name='AppId', description='AppId'),
  tenantId: string(name='TenantId', description='TenantId'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model ListMcubeMiniAppsResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  listMiniResult: {
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
    miniProgramList: [
      {
        appCode: string(name='AppCode', description='AppCode'),
        gmtCreate: string(name='GmtCreate', description='GmtCreate'),
        gmtModified: string(name='GmtModified', description='GmtModified'),
        h5Id: string(name='H5Id', description='H5Id'),
        h5Name: string(name='H5Name', description='H5Name'),
      }
    ](name='MiniProgramList', description='MiniProgramList'),
  }(name='ListMiniResult', description='ListMiniResult'),
}

async function listMcubeMiniAppsWithOptions(request: ListMcubeMiniAppsRequest, runtime: Util.RuntimeOptions): ListMcubeMiniAppsResponse {
  Util.validateModel(request);
  return doRequest('ListMcubeMiniApps', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function listMcubeMiniApps(request: ListMcubeMiniAppsRequest): ListMcubeMiniAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcubeMiniAppsWithOptions(request, runtime);
}

model ListMcubeWhitelistsRequest = {
  appId: string(name='AppId', description='AppId'),
  tenantId: string(name='TenantId', description='TenantId'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model ListMcubeWhitelistsResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  listWhitelistResult: {
    resultMsg: string(name='ResultMsg', description='ResultMsg'),
    success: boolean(name='Success', description='Success'),
    whitelists: [
      {
        appCode: string(name='AppCode', description='AppCode'),
        gmtCreate: string(name='GmtCreate', description='GmtCreate'),
        gmtModified: string(name='GmtModified', description='GmtModified'),
        id: long(name='Id', description='Id'),
        whitelistType: string(name='WhitelistType', description='WhitelistType'),
        whiteListCount: long(name='WhiteListCount', description='WhiteListCount'),
        whiteListName: string(name='WhiteListName', description='WhiteListName'),
      }
    ](name='Whitelists', description='Whitelists'),
  }(name='ListWhitelistResult', description='ListWhitelistResult'),
}

async function listMcubeWhitelistsWithOptions(request: ListMcubeWhitelistsRequest, runtime: Util.RuntimeOptions): ListMcubeWhitelistsResponse {
  Util.validateModel(request);
  return doRequest('ListMcubeWhitelists', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function listMcubeWhitelists(request: ListMcubeWhitelistsRequest): ListMcubeWhitelistsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcubeWhitelistsWithOptions(request, runtime);
}

model CreateOpenSingleDataRequest = {
  appId: string(name='AppId', description='AppId'),
  appMaxVersion?: string(name='AppMaxVersion', description='AppMaxVersion'),
  appMinVersion?: string(name='AppMinVersion', description='AppMinVersion'),
  bizType: string(name='BizType', description='BizType'),
  checkOnline?: boolean(name='CheckOnline', description='CheckOnline'),
  extAttrStr?: string(name='ExtAttrStr', description='ExtAttrStr'),
  linkToken: string(name='LinkToken', description='LinkToken'),
  osType?: string(name='OsType', description='OsType'),
  payload: string(name='Payload', description='Payload'),
  thirdMsgId: string(name='ThirdMsgId', description='ThirdMsgId'),
  validTimeEnd?: long(name='ValidTimeEnd', description='ValidTimeEnd'),
  validTimeStart?: long(name='ValidTimeStart', description='ValidTimeStart'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model CreateOpenSingleDataResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
}

async function createOpenSingleDataWithOptions(request: CreateOpenSingleDataRequest, runtime: Util.RuntimeOptions): CreateOpenSingleDataResponse {
  Util.validateModel(request);
  return doRequest('CreateOpenSingleData', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function createOpenSingleData(request: CreateOpenSingleDataRequest): CreateOpenSingleDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOpenSingleDataWithOptions(request, runtime);
}

model CreateOpenGlobalDataRequest = {
  appId: string(name='AppId', description='AppId'),
  appMaxVersion?: string(name='AppMaxVersion', description='AppMaxVersion'),
  appMinVersion?: string(name='AppMinVersion', description='AppMinVersion'),
  bizType: string(name='BizType', description='BizType'),
  extAttrStr?: string(name='ExtAttrStr', description='ExtAttrStr'),
  maxUid?: long(name='MaxUid', description='MaxUid'),
  minUid?: long(name='MinUid', description='MinUid'),
  osType?: string(name='OsType', description='OsType'),
  payload: string(name='Payload', description='Payload'),
  thirdMsgId: string(name='ThirdMsgId', description='ThirdMsgId'),
  uids?: string(name='Uids', description='Uids'),
  validTimeEnd?: long(name='ValidTimeEnd', description='ValidTimeEnd'),
  validTimeStart?: long(name='ValidTimeStart', description='ValidTimeStart'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model CreateOpenGlobalDataResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
}

async function createOpenGlobalDataWithOptions(request: CreateOpenGlobalDataRequest, runtime: Util.RuntimeOptions): CreateOpenGlobalDataResponse {
  Util.validateModel(request);
  return doRequest('CreateOpenGlobalData', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function createOpenGlobalData(request: CreateOpenGlobalDataRequest): CreateOpenGlobalDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOpenGlobalDataWithOptions(request, runtime);
}

model PushSimpleRequest = {
  appId: string(name='AppId', description='AppId'),
  content: string(name='Content', description='Content'),
  deliveryType: long(name='DeliveryType', description='DeliveryType'),
  expiredSeconds: long(name='ExpiredSeconds', description='ExpiredSeconds'),
  extendedParams?: string(name='ExtendedParams', description='ExtendedParams'),
  notifyType?: string(name='NotifyType', description='NotifyType'),
  pushAction?: long(name='PushAction', description='PushAction'),
  silent?: long(name='Silent', description='Silent'),
  targetMsgkey: string(name='TargetMsgkey', description='TargetMsgkey'),
  taskName?: string(name='TaskName', description='TaskName'),
  title: string(name='Title', description='Title'),
  uri?: string(name='Uri', description='Uri'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model PushSimpleResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
}

async function pushSimpleWithOptions(request: PushSimpleRequest, runtime: Util.RuntimeOptions): PushSimpleResponse {
  Util.validateModel(request);
  return doRequest('PushSimple', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function pushSimple(request: PushSimpleRequest): PushSimpleResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushSimpleWithOptions(request, runtime);
}

model PushBroadcastRequest = {
  appId: string(name='AppId', description='AppId'),
  deliveryType: long(name='DeliveryType', description='DeliveryType'),
  expiredSeconds: long(name='ExpiredSeconds', description='ExpiredSeconds'),
  extendedParams?: string(name='ExtendedParams', description='ExtendedParams'),
  msgkey: string(name='Msgkey', description='Msgkey'),
  notifyType?: string(name='NotifyType', description='NotifyType'),
  pushAction?: long(name='PushAction', description='PushAction'),
  pushStatus?: long(name='PushStatus', description='PushStatus'),
  silent?: long(name='Silent', description='Silent'),
  taskName?: string(name='TaskName', description='TaskName'),
  templateKeyValue?: string(name='TemplateKeyValue', description='TemplateKeyValue'),
  templateName: string(name='TemplateName', description='TemplateName'),
  unBindPeriod?: long(name='UnBindPeriod', description='UnBindPeriod'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model PushBroadcastResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
}

async function pushBroadcastWithOptions(request: PushBroadcastRequest, runtime: Util.RuntimeOptions): PushBroadcastResponse {
  Util.validateModel(request);
  return doRequest('PushBroadcast', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function pushBroadcast(request: PushBroadcastRequest): PushBroadcastResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushBroadcastWithOptions(request, runtime);
}

model PushTemplateRequest = {
  appId: string(name='AppId', description='AppId'),
  deliveryType: long(name='DeliveryType', description='DeliveryType'),
  expiredSeconds: long(name='ExpiredSeconds', description='ExpiredSeconds'),
  extendedParams?: string(name='ExtendedParams', description='ExtendedParams'),
  notifyType?: string(name='NotifyType', description='NotifyType'),
  pushAction?: long(name='PushAction', description='PushAction'),
  silent?: long(name='Silent', description='Silent'),
  targetMsgkey: string(name='TargetMsgkey', description='TargetMsgkey'),
  taskName?: string(name='TaskName', description='TaskName'),
  templateKeyValue?: string(name='TemplateKeyValue', description='TemplateKeyValue'),
  templateName: string(name='TemplateName', description='TemplateName'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model PushTemplateResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
}

async function pushTemplateWithOptions(request: PushTemplateRequest, runtime: Util.RuntimeOptions): PushTemplateResponse {
  Util.validateModel(request);
  return doRequest('PushTemplate', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function pushTemplate(request: PushTemplateRequest): PushTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushTemplateWithOptions(request, runtime);
}

model PushMultipleRequest = {
  appId: string(name='AppId', description='AppId'),
  deliveryType: long(name='DeliveryType', description='DeliveryType'),
  expiredSeconds: long(name='ExpiredSeconds', description='ExpiredSeconds'),
  extendedParams?: string(name='ExtendedParams', description='ExtendedParams'),
  notifyType?: string(name='NotifyType', description='NotifyType'),
  pushAction?: long(name='PushAction', description='PushAction'),
  silent?: long(name='Silent', description='Silent'),
  targetMsg: [
    {
      extendedParams?: string(name='ExtendedParams', description='ExtendedParams'),
      msgKey: string(name='MsgKey', description='MsgKey'),
      target: string(name='Target', description='Target'),
      templateKeyValue?: string(name='TemplateKeyValue', description='TemplateKeyValue'),
    }
  ](name='TargetMsg', description='TargetMsg'),
  taskName?: string(name='TaskName', description='TaskName'),
  templateName: string(name='TemplateName', description='TemplateName'),
  workspaceId: string(name='WorkspaceId', description='WorkspaceId'),
}

model PushMultipleResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
}

async function pushMultipleWithOptions(request: PushMultipleRequest, runtime: Util.RuntimeOptions): PushMultipleResponse {
  Util.validateModel(request);
  return doRequest('PushMultiple', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function pushMultiple(request: PushMultipleRequest): PushMultipleResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushMultipleWithOptions(request, runtime);
}

model ListMcdpAimRequest = {
  appId?: string(name='AppId', description='AppId'),
  emptyTag?: string(name='EmptyTag', description='EmptyTag'),
  keyword?: string(name='Keyword', description='Keyword'),
  name?: string(name='Name', description='Name'),
  pageNo?: long(name='PageNo', description='PageNo'),
  pageSize?: long(name='PageSize', description='PageSize'),
  sortField?: string(name='SortField', description='SortField'),
  tenantId?: string(name='TenantId', description='TenantId'),
  type?: string(name='Type', description='Type'),
  workspaceId?: string(name='WorkspaceId', description='WorkspaceId'),
}

model ListMcdpAimResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  resultCode: string(name='ResultCode', description='ResultCode'),
  resultMessage: string(name='ResultMessage', description='ResultMessage'),
  resultContent: {
    code: string(name='Code', description='Code'),
    data: string(name='Data', description='Data'),
    message: string(name='Message', description='Message'),
    success: boolean(name='Success', description='Success'),
  }(name='ResultContent', description='ResultContent'),
}

async function listMcdpAimWithOptions(request: ListMcdpAimRequest, runtime: Util.RuntimeOptions): ListMcdpAimResponse {
  Util.validateModel(request);
  return doRequest('ListMcdpAim', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function listMcdpAim(request: ListMcdpAimRequest): ListMcdpAimResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcdpAimWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
