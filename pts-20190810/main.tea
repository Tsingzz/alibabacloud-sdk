import Util;
import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('pts', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model DescribeJMeterSampleSummaryRequest = {
  reportId: string(name='ReportId', description='reportId'),
  samplerId: integer(name='SamplerId', description='samplerId'),
}

model DescribeJMeterSampleSummaryResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  concurrencyRtStat: map[string]any(name='ConcurrencyRtStat', description='concurrencyRtStat'),
  concurrencyTpsStat: map[string]any(name='ConcurrencyTpsStat', description='concurrencyTpsStat'),
  rtDistribution: map[string]any(name='RtDistribution', description='rtDistribution'),
}

async function describeJMeterSampleSummaryWithOptions(request: DescribeJMeterSampleSummaryRequest, runtime: Util.RuntimeOptions): DescribeJMeterSampleSummaryResponse {
  Util.validateModel(request);
  return doRequest('DescribeJMeterSampleSummary', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function describeJMeterSampleSummary(request: DescribeJMeterSampleSummaryRequest): DescribeJMeterSampleSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJMeterSampleSummaryWithOptions(request, runtime);
}

model CloneJMeterSceneRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
}

model CloneJMeterSceneResponse = {
  requestId: string(name='RequestId', description='requestId'),
  sceneId: string(name='SceneId', description='sceneId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function cloneJMeterSceneWithOptions(request: CloneJMeterSceneRequest, runtime: Util.RuntimeOptions): CloneJMeterSceneResponse {
  Util.validateModel(request);
  return doRequest('CloneJMeterScene', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function cloneJMeterScene(request: CloneJMeterSceneRequest): CloneJMeterSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return cloneJMeterSceneWithOptions(request, runtime);
}

model AdjustJMeterSpeedRequest = {
  sceneId?: string(name='SceneId', description='sceneId'),
  loadMode?: string(name='LoadMode', description='loadMode'),
  speed?: integer(name='Speed', description='speed'),
}

model AdjustJMeterSpeedResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function adjustJMeterSpeedWithOptions(request: AdjustJMeterSpeedRequest, runtime: Util.RuntimeOptions): AdjustJMeterSpeedResponse {
  Util.validateModel(request);
  return doRequest('AdjustJMeterSpeed', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function adjustJMeterSpeed(request: AdjustJMeterSpeedRequest): AdjustJMeterSpeedResponse {
  var runtime = new Util.RuntimeOptions{};
  return adjustJMeterSpeedWithOptions(request, runtime);
}

model DescribeJMeterSamplingLogsRequest = {
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
  reportId: string(name='ReportId', description='reportId'),
  taskId?: long(name='TaskId', description='taskId'),
  samplerId?: integer(name='SamplerId', description='samplerId'),
  success?: boolean(name='Success', description='success'),
  thread?: string(name='Thread', description='thread'),
  keyword?: string(name='Keyword', description='keyword'),
  rtRange?: string(name='RtRange', description='rtRange'),
}

model DescribeJMeterSamplingLogsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  totalCount: long(name='TotalCount', description='totalCount'),
  sampleResults: [ string ] (name='SampleResults', description='sampleResults'),
}

async function describeJMeterSamplingLogsWithOptions(request: DescribeJMeterSamplingLogsRequest, runtime: Util.RuntimeOptions): DescribeJMeterSamplingLogsResponse {
  Util.validateModel(request);
  return doRequest('DescribeJMeterSamplingLogs', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function describeJMeterSamplingLogs(request: DescribeJMeterSamplingLogsRequest): DescribeJMeterSamplingLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJMeterSamplingLogsWithOptions(request, runtime);
}

model DescribeAgentNetTrafficRequest = {
  reportId: string(name='ReportId', description='reportId'),
  taskId: long(name='TaskId', description='taskId'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
}

model DescribeAgentNetTrafficResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  netTrafficInfo: [ map[string]any ] (name='NetTrafficInfo', description='netTrafficInfo'),
}

async function describeAgentNetTrafficWithOptions(request: DescribeAgentNetTrafficRequest, runtime: Util.RuntimeOptions): DescribeAgentNetTrafficResponse {
  Util.validateModel(request);
  return doRequest('DescribeAgentNetTraffic', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeAgentNetTraffic(request: DescribeAgentNetTrafficRequest): DescribeAgentNetTrafficResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAgentNetTrafficWithOptions(request, runtime);
}

model DescribeAgentCpuInfoRequest = {
  reportId: string(name='ReportId', description='reportId'),
  taskId: long(name='TaskId', description='taskId'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
}

model DescribeAgentCpuInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  cpuInfo: [ map[string]any ] (name='CpuInfo', description='cpuInfo'),
}

async function describeAgentCpuInfoWithOptions(request: DescribeAgentCpuInfoRequest, runtime: Util.RuntimeOptions): DescribeAgentCpuInfoResponse {
  Util.validateModel(request);
  return doRequest('DescribeAgentCpuInfo', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey', null, request, runtime);
}

async function describeAgentCpuInfo(request: DescribeAgentCpuInfoRequest): DescribeAgentCpuInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAgentCpuInfoWithOptions(request, runtime);
}

model DescribeAgentGCInfoRequest = {
  reportId: string(name='ReportId', description='reportId'),
  taskId: long(name='TaskId', description='taskId'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
}

model DescribeAgentGCInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  gcInfo: [ map[string]any ] (name='GcInfo', description='gcInfo'),
}

async function describeAgentGCInfoWithOptions(request: DescribeAgentGCInfoRequest, runtime: Util.RuntimeOptions): DescribeAgentGCInfoResponse {
  Util.validateModel(request);
  return doRequest('DescribeAgentGCInfo', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeAgentGCInfo(request: DescribeAgentGCInfoRequest): DescribeAgentGCInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAgentGCInfoWithOptions(request, runtime);
}

model DescribeAgentMemoryInfoRequest = {
  reportId: string(name='ReportId', description='reportId'),
  taskId: long(name='TaskId', description='taskId'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
}

model DescribeAgentMemoryInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  memoryInfo: [ map[string]any ] (name='MemoryInfo', description='memoryInfo'),
}

async function describeAgentMemoryInfoWithOptions(request: DescribeAgentMemoryInfoRequest, runtime: Util.RuntimeOptions): DescribeAgentMemoryInfoResponse {
  Util.validateModel(request);
  return doRequest('DescribeAgentMemoryInfo', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function describeAgentMemoryInfo(request: DescribeAgentMemoryInfoRequest): DescribeAgentMemoryInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAgentMemoryInfoWithOptions(request, runtime);
}

model DescribeAgentLoadInfoRequest = {
  reportId: string(name='ReportId', description='reportId'),
  taskId: long(name='TaskId', description='taskId'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
}

model DescribeAgentLoadInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  loadInfo: [ map[string]any ] (name='LoadInfo', description='loadInfo'),
}

async function describeAgentLoadInfoWithOptions(request: DescribeAgentLoadInfoRequest, runtime: Util.RuntimeOptions): DescribeAgentLoadInfoResponse {
  Util.validateModel(request);
  return doRequest('DescribeAgentLoadInfo', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function describeAgentLoadInfo(request: DescribeAgentLoadInfoRequest): DescribeAgentLoadInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAgentLoadInfoWithOptions(request, runtime);
}

model DescribeJMeterPlanRequest = {
  reportId: string(name='ReportId', description='reportId'),
}

model DescribeJMeterPlanResponse = {
  requestId: string(name='RequestId', description='requestId'),
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  report: string(name='Report', description='report'),
}

async function describeJMeterPlanWithOptions(request: DescribeJMeterPlanRequest, runtime: Util.RuntimeOptions): DescribeJMeterPlanResponse {
  Util.validateModel(request);
  return doRequest('DescribeJMeterPlan', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeJMeterPlan(request: DescribeJMeterPlanRequest): DescribeJMeterPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJMeterPlanWithOptions(request, runtime);
}

model DescribeJMeterSceneRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
}

model DescribeJMeterSceneResponse = {
  requestId: string(name='RequestId', description='requestId'),
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  scene: {
    name: string(name='Name', description='name'),
    pool: string(name='Pool', description='pool'),
    JMeterVersion: string(name='JMeterVersion', description='jmeterVersion'),
    concurrency: integer(name='Concurrency', description='concurrency'),
    rampUp: integer(name='RampUp', description='rampUp'),
    holdFor: integer(name='HoldFor', description='holdFor'),
    useIterations: boolean(name='UseIterations', description='useIterations'),
    iterations: integer(name='Iterations', description='iterations'),
    maxConcurrencyPerAgent: integer(name='MaxConcurrencyPerAgent', description='maxConcurrencyPerAgent'),
    specifyAgentCount: boolean(name='SpecifyAgentCount', description='specifyAgentCount'),
    agentCount: integer(name='AgentCount', description='agentCount'),
    splitCsv: boolean(name='SplitCsv', description='splitCsv'),
    testFile: string(name='TestFile', description='testFile'),
    fileList: string(name='FileList', description='fileList'),
    regionId: string(name='RegionId', description='regionId'),
    vpcId: string(name='VpcId', description='vpcId'),
    securityGroupId: string(name='SecurityGroupId', description='securityGroupId'),
    VSwitchId: string(name='VSwitchId', description='vSwitchId'),
    sceneId: string(name='SceneId', description='sceneId'),
    conditionSatisfiedExactly: boolean(name='ConditionSatisfiedExactly', description='conditionSatisfiedExactly'),
    syncTimerType: string(name='SyncTimerType', description='syncTimerType'),
    steps: integer(name='Steps', description='steps'),
    constantThroughputTimerType: string(name='ConstantThroughputTimerType', description='constantThroughputTimerType'),
    condition: [
      {
        region: string(name='Region', description='region'),
        isp: string(name='Isp', description='isp'),
        amount: integer(name='Amount', description='amount'),
      }
    ](name='Condition', description='condition'),
    plan: {
      modifiedTime: long(name='ModifiedTime', description='gmtModified'),
      lastActive: long(name='LastActive', description='lastActive'),
      vum: long(name='Vum', description='vum'),
      hasReport: boolean(name='HasReport', description='hasReport'),
      vumWeight: long(name='VumWeight', description='vumWeight'),
      beginTime: long(name='BeginTime', description='startTime'),
    }(name='Plan', description='plan'),
  }(name='Scene', description='scene'),
}

async function describeJMeterSceneWithOptions(request: DescribeJMeterSceneRequest, runtime: Util.RuntimeOptions): DescribeJMeterSceneResponse {
  Util.validateModel(request);
  return doRequest('DescribeJMeterScene', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeJMeterScene(request: DescribeJMeterSceneRequest): DescribeJMeterSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJMeterSceneWithOptions(request, runtime);
}

model DescribeJMeterSceneRunningStatusRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
}

model DescribeJMeterSceneRunningStatusResponse = {
  requestId: string(name='RequestId', description='requestId'),
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  scene: {
    name: string(name='Name', description='name'),
    pool: string(name='Pool', description='pool'),
    jmeterVersion: string(name='JmeterVersion', description='jmeterVersion'),
    concurrency: integer(name='Concurrency', description='concurrency'),
    rampUp: integer(name='RampUp', description='rampUp'),
    holdFor: integer(name='HoldFor', description='holdFor'),
    useIterations: boolean(name='UseIterations', description='useIterations'),
    iterations: integer(name='Iterations', description='iterations'),
    maxConcurrencyPerAgent: integer(name='MaxConcurrencyPerAgent', description='maxConcurrencyPerAgent'),
    specifyAgentCount: boolean(name='SpecifyAgentCount', description='specifyAgentCount'),
    agentCount: integer(name='AgentCount', description='agentCount'),
    splitCsv: boolean(name='SplitCsv', description='splitCsv'),
    testFile: string(name='TestFile', description='testFile'),
    plan: string(name='Plan', description='plan'),
    steps: integer(name='Steps', description='steps'),
  }(name='Scene', description='scene'),
}

async function describeJMeterSceneRunningStatusWithOptions(request: DescribeJMeterSceneRunningStatusRequest, runtime: Util.RuntimeOptions): DescribeJMeterSceneRunningStatusResponse {
  Util.validateModel(request);
  return doRequest('DescribeJMeterSceneRunningStatus', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeJMeterSceneRunningStatus(request: DescribeJMeterSceneRunningStatusRequest): DescribeJMeterSceneRunningStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJMeterSceneRunningStatusWithOptions(request, runtime);
}

model DescribeJMeterTaskListRequest = {
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  reportId?: string(name='ReportId', description='reportId'),
}

model DescribeJMeterTaskListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  totalCount: long(name='TotalCount', description='totalCount'),
  taskList: string(name='TaskList', description='taskList'),
}

async function describeJMeterTaskListWithOptions(request: DescribeJMeterTaskListRequest, runtime: Util.RuntimeOptions): DescribeJMeterTaskListResponse {
  Util.validateModel(request);
  return doRequest('DescribeJMeterTaskList', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeJMeterTaskList(request: DescribeJMeterTaskListRequest): DescribeJMeterTaskListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJMeterTaskListWithOptions(request, runtime);
}

model DescribeJMeterLogsRequest = {
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  reportId?: string(name='ReportId', description='reportId'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
  taskId?: long(name='TaskId', description='taskId'),
  thread?: string(name='Thread', description='thread'),
  level?: string(name='Level', description='level'),
  loggerName?: string(name='LoggerName', description='loggerName'),
  keyword?: string(name='Keyword', description='keyword'),
}

model DescribeJMeterLogsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  totalCount: long(name='TotalCount', description='totalCount'),
  logs: string(name='Logs', description='logs'),
}

async function describeJMeterLogsWithOptions(request: DescribeJMeterLogsRequest, runtime: Util.RuntimeOptions): DescribeJMeterLogsResponse {
  Util.validateModel(request);
  return doRequest('DescribeJMeterLogs', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeJMeterLogs(request: DescribeJMeterLogsRequest): DescribeJMeterLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJMeterLogsWithOptions(request, runtime);
}

model StopJMeterTestingRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
}

model StopJMeterTestingResponse = {
  requestId: string(name='RequestId', description='requestId'),
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function stopJMeterTestingWithOptions(request: StopJMeterTestingRequest, runtime: Util.RuntimeOptions): StopJMeterTestingResponse {
  Util.validateModel(request);
  return doRequest('StopJMeterTesting', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function stopJMeterTesting(request: StopJMeterTestingRequest): StopJMeterTestingResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopJMeterTestingWithOptions(request, runtime);
}

model DescribeSampleMetricRequest = {
  reportId?: string(name='ReportId', description='reportId'),
  samplerId?: integer(name='SamplerId', description='samplerId'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
}

model DescribeSampleMetricResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  sampleMetricList: string(name='SampleMetricList', description='sampleMetricList'),
}

async function describeSampleMetricWithOptions(request: DescribeSampleMetricRequest, runtime: Util.RuntimeOptions): DescribeSampleMetricResponse {
  Util.validateModel(request);
  return doRequest('DescribeSampleMetric', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeSampleMetric(request: DescribeSampleMetricRequest): DescribeSampleMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSampleMetricWithOptions(request, runtime);
}

model DescribeJMeterChainDetailRequest = {
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  reportId?: string(name='ReportId', description='reportId'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
  taskId?: long(name='TaskId', description='taskId'),
  thread?: long(name='Thread', description='thread'),
  kw?: string(name='Kw', description='kw'),
  samplerId?: integer(name='SamplerId', description='samplerId'),
  success?: boolean(name='Success', description='success'),
}

model DescribeJMeterChainDetailResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  totalCount: long(name='TotalCount', description='totalCount'),
  sampleResults: string(name='SampleResults', description='sampleResults'),
}

async function describeJMeterChainDetailWithOptions(request: DescribeJMeterChainDetailRequest, runtime: Util.RuntimeOptions): DescribeJMeterChainDetailResponse {
  Util.validateModel(request);
  return doRequest('DescribeJMeterChainDetail', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeJMeterChainDetail(request: DescribeJMeterChainDetailRequest): DescribeJMeterChainDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJMeterChainDetailWithOptions(request, runtime);
}

model StartJMeterTestingRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
}

model StartJMeterTestingResponse = {
  requestId: string(name='RequestId', description='requestId'),
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  planId: string(name='PlanId', description='planId'),
}

async function startJMeterTestingWithOptions(request: StartJMeterTestingRequest, runtime: Util.RuntimeOptions): StartJMeterTestingResponse {
  Util.validateModel(request);
  return doRequest('StartJMeterTesting', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function startJMeterTesting(request: StartJMeterTestingRequest): StartJMeterTestingResponse {
  var runtime = new Util.RuntimeOptions{};
  return startJMeterTestingWithOptions(request, runtime);
}

model RemoveInstanceFromGroupRequest = {
  groupId: long(name='GroupId', description='groupId'),
  instanceIdAndPorts: map[string]any(name='InstanceIdAndPorts', description='instanceIdAndPorts'),
  ver: long(name='Ver', description='version'),
}

model RemoveInstanceFromGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
}

async function removeInstanceFromGroupWithOptions(request: RemoveInstanceFromGroupRequest, runtime: Util.RuntimeOptions): RemoveInstanceFromGroupResponse {
  Util.validateModel(request);
  return doRequest('RemoveInstanceFromGroup', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function removeInstanceFromGroup(request: RemoveInstanceFromGroupRequest): RemoveInstanceFromGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeInstanceFromGroupWithOptions(request, runtime);
}

model ListReceiversRequest = {
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
}

model ListReceiversResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  receivers: [
    {
      id: string(name='Id', description='id'),
      name: string(name='Name', description='name'),
      emailCheckCode: string(name='EmailCheckCode', description='emailCheckCode'),
      mobileCheckCode: string(name='MobileCheckCode', description='mobileCheckCode'),
      dingTalk: string(name='DingTalk', description='dingTalk'),
      mobile: string(name='Mobile', description='mobile'),
      source: string(name='Source', description='source'),
      deleted: integer(name='Deleted', description='deleted'),
      email: string(name='Email', description='email'),
      wangwang: string(name='Wangwang', description='wangwang'),
      uid: string(name='Uid', description='uid'),
    }
  ](name='Receivers', description='receivers'),
}

async function listReceiversWithOptions(request: ListReceiversRequest, runtime: Util.RuntimeOptions): ListReceiversResponse {
  Util.validateModel(request);
  return doRequest('ListReceivers', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function listReceivers(request: ListReceiversRequest): ListReceiversResponse {
  var runtime = new Util.RuntimeOptions{};
  return listReceiversWithOptions(request, runtime);
}

model ReplaceOssFileRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
  originalOssFileUrl: string(name='OriginalOssFileUrl', description='originalOssFileUrl'),
  newOssFileUrl: string(name='NewOssFileUrl', description='newOssFileUrl'),
  jobId?: string(name='JobId', description='jobId'),
}

model ReplaceOssFileResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  finished: boolean(name='Finished', description='finished'),
  jobId: string(name='JobId', description='jobId'),
  timeout: integer(name='Timeout', description='timeout'),
}

async function replaceOssFileWithOptions(request: ReplaceOssFileRequest, runtime: Util.RuntimeOptions): ReplaceOssFileResponse {
  Util.validateModel(request);
  return doRequest('ReplaceOssFile', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function replaceOssFile(request: ReplaceOssFileRequest): ReplaceOssFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return replaceOssFileWithOptions(request, runtime);
}

model StartDebuggingRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
}

model StartDebuggingResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  reportId: string(name='ReportId', description='reportId'),
}

async function startDebuggingWithOptions(request: StartDebuggingRequest, runtime: Util.RuntimeOptions): StartDebuggingResponse {
  Util.validateModel(request);
  return doRequest('StartDebugging', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function startDebugging(request: StartDebuggingRequest): StartDebuggingResponse {
  var runtime = new Util.RuntimeOptions{};
  return startDebuggingWithOptions(request, runtime);
}

model StopDebuggingRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
}

model StopDebuggingResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
}

async function stopDebuggingWithOptions(request: StopDebuggingRequest, runtime: Util.RuntimeOptions): StopDebuggingResponse {
  Util.validateModel(request);
  return doRequest('StopDebugging', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function stopDebugging(request: StopDebuggingRequest): StopDebuggingResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopDebuggingWithOptions(request, runtime);
}

model StartTestingRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
}

model StartTestingResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  sceneId: string(name='SceneId', description='sceneId'),
  reportId: string(name='ReportId', description='reportId'),
}

async function startTestingWithOptions(request: StartTestingRequest, runtime: Util.RuntimeOptions): StartTestingResponse {
  Util.validateModel(request);
  return doRequest('StartTesting', 'HTTPS', 'GET', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function startTesting(request: StartTestingRequest): StartTestingResponse {
  var runtime = new Util.RuntimeOptions{};
  return startTestingWithOptions(request, runtime);
}

model StopTestingRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
}

model StopTestingResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
}

async function stopTestingWithOptions(request: StopTestingRequest, runtime: Util.RuntimeOptions): StopTestingResponse {
  Util.validateModel(request);
  return doRequest('StopTesting', 'HTTPS', 'GET', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function stopTesting(request: StopTestingRequest): StopTestingResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopTestingWithOptions(request, runtime);
}

model ListReportsRequest = {
  keyword?: string(name='Keyword', description='keywords'),
  pageSize: integer(name='PageSize', description='pageSize'),
  sceneType?: string(name='SceneType', description='sceneType'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
}

model ListReportsResponse = {
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  code: string(name='Code', description='code'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  pageSize: integer(name='PageSize', description='pageSize'),
  totalCount: integer(name='TotalCount', description='totalCount'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  reports: [
    {
      reportId: string(name='ReportId', description='reportId'),
      sceneId: string(name='SceneId', description='sceneId'),
      sceneName: string(name='SceneName', description='sceneName'),
      sceneType: string(name='SceneType', description='sceneType'),
      maxConcurrency: integer(name='MaxConcurrency', description='maxConcurrency'),
      vum: integer(name='Vum', description='vum'),
      duration: string(name='Duration', description='duration'),
      beginTime: long(name='BeginTime', description='beginTime'),
      sceneDeleted: boolean(name='SceneDeleted', description='sceneDeleted'),
      requestId: string(name='RequestId', description='requestId'),
    }
  ](name='Reports', description='reports'),
}

async function listReportsWithOptions(request: ListReportsRequest, runtime: Util.RuntimeOptions): ListReportsResponse {
  Util.validateModel(request);
  return doRequest('ListReports', 'HTTPS', 'GET', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function listReports(request: ListReportsRequest): ListReportsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listReportsWithOptions(request, runtime);
}

model DescribeReportChainDetailRequest = {
  reportId: string(name='ReportId', description='reportId'),
  chainId?: long(name='ChainId', description='chainId'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
}

model DescribeReportChainDetailResponse = {
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  chainDetails: [
    {
      totalFail: long(name='TotalFail', description='totalFail'),
      qpsFail: float(name='QpsFail', description='qpsFail'),
      total3XX: long(name='Total3XX', description='total300'),
      realConcurrency: float(name='RealConcurrency', description='concurrency'),
      timePoint: long(name='TimePoint', description='timePoint'),
      maxRt: integer(name='MaxRt', description='maxRt'),
      minRt: integer(name='MinRt', description='minRt'),
      totalRequest: long(name='TotalRequest', description='realTotal'),
      qps2XX: float(name='Qps2XX', description='qps200'),
      total4XX: long(name='Total4XX', description='total400'),
      total5XX: long(name='Total5XX', description='total500'),
      qps4XX: float(name='Qps4XX', description='qps400'),
      realQps: float(name='RealQps', description='realQps'),
      configQps: integer(name='ConfigQps', description='configQps'),
      averageRt: integer(name='AverageRt', description='avgRt'),
      bpsRequest: long(name='BpsRequest', description='bpsRequest'),
      chainId: long(name='ChainId', description='chainId'),
      bpsResponse: long(name='BpsResponse', description='bpsResponse'),
      total2XX: long(name='Total2XX', description='total200'),
      qps5XX: float(name='Qps5XX', description='qps500'),
    }
  ](name='ChainDetails', description='chainDetails'),
}

async function describeReportChainDetailWithOptions(request: DescribeReportChainDetailRequest, runtime: Util.RuntimeOptions): DescribeReportChainDetailResponse {
  Util.validateModel(request);
  return doRequest('DescribeReportChainDetail', 'HTTPS', 'GET', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeReportChainDetail(request: DescribeReportChainDetailRequest): DescribeReportChainDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeReportChainDetailWithOptions(request, runtime);
}

model DescribeReportChainSummaryRequest = {
  reportId: string(name='ReportId', description='reportId'),
}

model DescribeReportChainSummaryResponse = {
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  chainSummary: [
    {
      chainId: long(name='ChainId', description='chainId'),
      averageTps: float(name='AverageTps', description='avgTps'),
      succeedRequestRate: float(name='SucceedRequestRate', description='reqSucRate'),
      hasCheckPoint: boolean(name='HasCheckPoint', description='hasAssert'),
      chainName: string(name='ChainName', description='chainName'),
      totalRequest: long(name='TotalRequest', description='totalRequest'),
      count5XX: long(name='Count5XX', description='count5xx'),
      relationName: string(name='RelationName', description='relationName'),
      count4XX: long(name='Count4XX', description='count4xx'),
      countTimeout: long(name='CountTimeout', description='countTimeout'),
      seg75Rt: long(name='Seg75Rt', description='seg75Rt'),
      failedBusinessCount: long(name='FailedBusinessCount', description='bizFailCount'),
      failedRequestCount: long(name='FailedRequestCount', description='reqFailCount'),
      seg90Rt: long(name='Seg90Rt', description='seg90Rt'),
      maxRt: integer(name='MaxRt', description='maxRt'),
      minRt: integer(name='MinRt', description='minRt'),
      count3XX: long(name='Count3XX', description='count3xx'),
      averageRt: float(name='AverageRt', description='avgRt'),
      relationId: long(name='RelationId', description='relationId'),
      succeedBusinessRate: float(name='SucceedBusinessRate', description='bizSucRate'),
      seg50Rt: integer(name='Seg50Rt', description='seg50Rt'),
      seg99Rt: integer(name='Seg99Rt', description='seg99Rt'),
      averageConcurrency: float(name='AverageConcurrency', description='avgConcurrency'),
    }
  ](name='ChainSummary', description='chainSummary'),
}

async function describeReportChainSummaryWithOptions(request: DescribeReportChainSummaryRequest, runtime: Util.RuntimeOptions): DescribeReportChainSummaryResponse {
  Util.validateModel(request);
  return doRequest('DescribeReportChainSummary', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeReportChainSummary(request: DescribeReportChainSummaryRequest): DescribeReportChainSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeReportChainSummaryWithOptions(request, runtime);
}

model RemoveScenesRequest = {
  sceneIds: map[string]any(name='SceneIds', description='sceneIds'),
}

model RemoveScenesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function removeScenesWithOptions(request: RemoveScenesRequest, runtime: Util.RuntimeOptions): RemoveScenesResponse {
  Util.validateModel(request);
  return doRequest('RemoveScenes', 'HTTPS', 'GET', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function removeScenes(request: RemoveScenesRequest): RemoveScenesResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeScenesWithOptions(request, runtime);
}

model DescribeReportRequest = {
  reportId: string(name='ReportId', description='ReportId'),
}

model DescribeReportResponse = {
  averageConcurrency: integer(name='AverageConcurrency', description='averageConcurrency'),
  averageBandWidth: long(name='AverageBandWidth', description='averageBandWidth'),
  succeedRequestRatio: float(name='SucceedRequestRatio', description='succeedRequestRatio'),
  endTime: long(name='EndTime', description='endTime'),
  beginTime: long(name='BeginTime', description='beginTime'),
  totalAgents: integer(name='TotalAgents', description='totalAgents'),
  requestCount: long(name='RequestCount', description='requestCount'),
  rpsLimit: integer(name='RpsLimit', description='rpsLimit'),
  aliveAgents: integer(name='AliveAgents', description='aliveAgents'),
  maxTps: integer(name='MaxTps', description='maxTps'),
  concurrencyLimit: integer(name='ConcurrencyLimit', description='concurrencyLimit'),
  maxConcurrency: integer(name='MaxConcurrency', description='maxConcurrency'),
  sceneDeleted: boolean(name='SceneDeleted', description='sceneDeleted'),
  duration: string(name='Duration', description='duration'),
  maxBandWidth: long(name='MaxBandWidth', description='maxBandWidth'),
  vum: long(name='Vum', description='vum'),
  failedBusinessCount: long(name='FailedBusinessCount', description='failedBusinessCount'),
  failedRequestCount: long(name='FailedRequestCount', description='failedRequestCount'),
  businessRequestRatio: float(name='BusinessRequestRatio', description='businessRequestRatio'),
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  agentsLocation: [
    {
      region: string(name='Region', description='region'),
      province: string(name='Province', description='province'),
      isp: string(name='Isp', description='isp'),
      count: integer(name='Count', description='count'),
    }
  ](name='AgentsLocation', description='agentsLocation'),
  relations: [
    {
      name: string(name='Name', description='name'),
      id: long(name='Id', description='Id'),
      disabled: boolean(name='Disabled', description='disabled'),
      headers: map[string]any(name='Headers', description='headers'),
      relationTestConfig: map[string]any(name='RelationTestConfig', description='relationTestConfig'),
      nodes: [
        {
          type: string(name='Type', description='type'),
          id: long(name='Id', description='id'),
          name: string(name='Name', description='name'),
          config: map[string]any(name='Config', description='config'),
        }
      ](name='Nodes', description='nodes'),
    }
  ](name='Relations', description='relations'),
}

async function describeReportWithOptions(request: DescribeReportRequest, runtime: Util.RuntimeOptions): DescribeReportResponse {
  Util.validateModel(request);
  return doRequest('DescribeReport', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeReport(request: DescribeReportRequest): DescribeReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeReportWithOptions(request, runtime);
}

model ListScenesRequest = {
  keyword?: string(name='Keyword', description='keyword'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
}

model ListScenesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  totalCount: long(name='TotalCount', description='totalCount'),
  scenes: [
    {
      sceneId: string(name='SceneId', description='sceneId'),
      sceneName: string(name='SceneName', description='sceneName'),
      duration: integer(name='Duration', description='duration'),
      modifiedTime: long(name='ModifiedTime', description='modifiedTime'),
      sceneType: string(name='SceneType', description='type'),
      cronable: boolean(name='Cronable', description='cronable'),
      status: string(name='Status', description='status'),
    }
  ](name='Scenes', description='scenes'),
}

async function listScenesWithOptions(request: ListScenesRequest, runtime: Util.RuntimeOptions): ListScenesResponse {
  Util.validateModel(request);
  return doRequest('ListScenes', 'HTTPS', 'GET', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function listScenes(request: ListScenesRequest): ListScenesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listScenesWithOptions(request, runtime);
}

model DescribeSceneRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
}

model DescribeSceneResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  scene: {
    id: string(name='Id', description='id'),
    name: string(name='Name', description='name'),
    type: string(name='Type', description='type'),
    variables: map[string]any(name='Variables', description='variables'),
    headers: map[string]any(name='Headers', description='headers'),
    creator: string(name='Creator', description='creator'),
    modifier: string(name='Modifier', description='modifier'),
    createTime: long(name='CreateTime', description='createTime'),
    modifyTime: long(name='ModifyTime', description='modifyTime'),
    relations: [
      {
        id: long(name='Id', description='id'),
        name: string(name='Name', description='name'),
        disabled: boolean(name='Disabled', description='disabled'),
        headers: map[string]any(name='Headers', description='headers'),
        nodes: [
          {
            id: long(name='Id', description='id'),
            name: string(name='Name', description='name'),
            type: string(name='Type', description='type'),
            config: map[string]any(name='Config', description='config'),
          }
        ](name='Nodes', description='nodes'),
        relationTestConfig: {
          beginStep: integer(name='BeginStep', description='beginStep'),
          increment: integer(name='Increment', description='increment'),
          endStep: integer(name='EndStep', description='endStep'),
        }(name='RelationTestConfig', description='relationTestConfig'),
      }
    ](name='Relations', description='relations'),
    vips: [
      {
        domain: string(name='Domain', description='domain'),
        enabled: boolean(name='Enabled', description='enabled'),
        ips: [ string ](name='Ips', description='ips'),
      }
    ](name='Vips', description='vips'),
    files: [
      {
        fileKey: string(name='FileKey', description='fileKey'),
        fileName: string(name='FileName', description='fileName'),
        skipFirstLine: boolean(name='SkipFirstLine', description='skipFirstLine'),
        previewData: map[string]any(name='PreviewData', description='previewData'),
        remoteUrl: string(name='RemoteUrl', description='remoteUrl'),
        exportedParams: [
          {
            name: string(name='Name', description='name'),
            column: string(name='Column', description='column'),
          }
        ](name='ExportedParams', description='exportParams'),
      }
    ](name='Files', description='files'),
    status: {
      operations: map[string]any(name='Operations', description='operations'),
      tips: string(name='Tips', description='tips'),
      debugging: boolean(name='Debugging', description='debugging'),
      testing: boolean(name='Testing', description='testing'),
      isCronable: boolean(name='IsCronable', description='isCronable'),
      isReusable: boolean(name='IsReusable', description='isReusable'),
      cronEditable: boolean(name='CronEditable', description='cronEditable'),
    }(name='Status', description='status'),
    testConfig: {
      mode: string(name='Mode', description='mode'),
      maxDuration: integer(name='MaxDuration', description='maxDuration'),
      autoStep: boolean(name='AutoStep', description='autoStep'),
      increment: integer(name='Increment', description='increment'),
      keepTime: integer(name='KeepTime', description='keepTime'),
      agentPool: string(name='AgentPool', description='agentPool'),
      vpcConfig: {
        regionId: string(name='RegionId', description='regionId'),
        VSwitchId: string(name='VSwitchId', description='vSwitchId'),
        securityGroupId: string(name='SecurityGroupId', description='securityGroupId'),
        vpcId: string(name='VpcId', description='vpcId'),
      }(name='VpcConfig', description='vpcConfig'),
    }(name='TestConfig', description='testConfig'),
  }(name='Scene', description='scene'),
}

async function describeSceneWithOptions(request: DescribeSceneRequest, runtime: Util.RuntimeOptions): DescribeSceneResponse {
  Util.validateModel(request);
  return doRequest('DescribeScene', 'HTTPS', 'GET', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeScene(request: DescribeSceneRequest): DescribeSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSceneWithOptions(request, runtime);
}

model DescribeSceneRunningStatusRequest = {
  sceneId?: string(name='SceneId', description='sceneId'),
}

model DescribeSceneRunningStatusResponse = {
  tips: string(name='Tips', description='tips'),
  totalRequestCount: long(name='TotalRequestCount', description='totalRequestCount'),
  vum: long(name='Vum', description='vum'),
  requestBps: string(name='RequestBps', description='requestBps'),
  responseBps: string(name='ResponseBps', description='responseBps'),
  failedRequestCount: long(name='FailedRequestCount', description='failedRequestCount'),
  failedBusinessCount: long(name='FailedBusinessCount', description='failedBusinessCount'),
  concurrency: integer(name='Concurrency', description='concurrency'),
  concurrencyLimit: integer(name='ConcurrencyLimit', description='concurrencyLimit'),
  tps: integer(name='Tps', description='tps'),
  tpsLimit: integer(name='TpsLimit', description='tpsLimit'),
  aliveAgents: integer(name='AliveAgents', description='aliveAgents'),
  totalAgents: integer(name='TotalAgents', description='totalAgents'),
  seg90Rt: long(name='Seg90Rt', description='seg90Rt'),
  averageRt: long(name='AverageRt', description='averageRt'),
  reportId: string(name='ReportId', description='reportId'),
  beginTime: long(name='BeginTime', description='startTime'),
  currentTime: long(name='CurrentTime', description='currentTime'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  useCustomPool: boolean(name='UseCustomPool', description='useCustomPool'),
  requestId: string(name='RequestId', description='requestId'),
  agentsLocation: [
    {
      region: string(name='Region', description='region'),
      province: string(name='Province', description='province'),
      isp: string(name='Isp', description='isp'),
      count: integer(name='Count', description='count'),
    }
  ](name='AgentsLocation', description='agentsLocation'),
  chainMonitorDataList: [
    {
      chainId: long(name='ChainId', description='chainId'),
      timePoint: long(name='TimePoint', description='timePoint'),
      configQps: integer(name='ConfigQps', description='configQps'),
      realQps: float(name='RealQps', description='realQps'),
      concurrency: float(name='Concurrency', description='concurrency'),
      qps2XX: float(name='Qps2XX', description='qps200'),
      failedQps: float(name='FailedQps', description='qpsFail'),
      averageRt: integer(name='AverageRt', description='avgRt'),
      maxRt: integer(name='MaxRt', description='maxRt'),
      minRt: integer(name='MinRt', description='minRt'),
      count2XX: long(name='Count2XX', description='count200'),
      failedCount: long(name='FailedCount', description='countFail'),
      queueSize: integer(name='QueueSize', description='queueSize'),
      queueCapacity: integer(name='QueueCapacity', description='queueCapacity'),
      qpsSummary: [
        {
          statusCode: integer(name='StatusCode', description='statusCode'),
          qps: float(name='Qps', description='qps'),
          totalCount: integer(name='TotalCount', description='totalCount'),
        }
      ](name='QpsSummary', description='qpsSummary'),
      checkPointResult: {
        succeedBusinessCount: long(name='SucceedBusinessCount', description='hitCount'),
        failedBusinessCount: long(name='FailedBusinessCount', description='missCount'),
        succeedBusinessQps: float(name='SucceedBusinessQps', description='hitQps'),
        failedBusinessQps: float(name='FailedBusinessQps', description='missQps'),
      }(name='CheckPointResult', description='overBizAssert'),
    }
  ](name='ChainMonitorDataList', description='monitorDataList'),
}

async function describeSceneRunningStatusWithOptions(request: DescribeSceneRunningStatusRequest, runtime: Util.RuntimeOptions): DescribeSceneRunningStatusResponse {
  Util.validateModel(request);
  return doRequest('DescribeSceneRunningStatus', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeSceneRunningStatus(request: DescribeSceneRunningStatusRequest): DescribeSceneRunningStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSceneRunningStatusWithOptions(request, runtime);
}

model AdjustSceneSpeedRequest = {
  sceneId?: string(name='SceneId', description='sceneId'),
  speed?: integer(name='Speed', description='speed'),
}

model AdjustSceneSpeedResponse = {
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function adjustSceneSpeedWithOptions(request: AdjustSceneSpeedRequest, runtime: Util.RuntimeOptions): AdjustSceneSpeedResponse {
  Util.validateModel(request);
  return doRequest('AdjustSceneSpeed', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function adjustSceneSpeed(request: AdjustSceneSpeedRequest): AdjustSceneSpeedResponse {
  var runtime = new Util.RuntimeOptions{};
  return adjustSceneSpeedWithOptions(request, runtime);
}

model AdjustRelationSpeedRequest = {
  sceneId?: string(name='SceneId', description='sceneId'),
  speed?: integer(name='Speed', description='speed'),
  relationIndex?: integer(name='RelationIndex', description='relationIndex'),
}

model AdjustRelationSpeedResponse = {
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function adjustRelationSpeedWithOptions(request: AdjustRelationSpeedRequest, runtime: Util.RuntimeOptions): AdjustRelationSpeedResponse {
  Util.validateModel(request);
  return doRequest('AdjustRelationSpeed', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function adjustRelationSpeed(request: AdjustRelationSpeedRequest): AdjustRelationSpeedResponse {
  var runtime = new Util.RuntimeOptions{};
  return adjustRelationSpeedWithOptions(request, runtime);
}

model DescribeSamplingLogRequest = {
  reportId: string(name='ReportId', description='reportId'),
  chainId?: long(name='ChainId', description='chainId'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  errorCode?: string(name='ErrorCode', description='errorCode'),
  httpResponseStatus?: string(name='HttpResponseStatus', description='httpResponseStatus'),
  rtRange?: string(name='RtRange', description='rtRange'),
}

model DescribeSamplingLogResponse = {
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  requestId: string(name='RequestId', description='requestId'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  totalCount: long(name='TotalCount', description='totalCount'),
  samplingLogs: [
    {
      chainId: string(name='ChainId', description='chainId'),
      timestamp: string(name='Timestamp', description='timestamp'),
      httpRequestMethod: string(name='HttpRequestMethod', description='httpRequestMethod'),
      httpRequestBody: string(name='HttpRequestBody', description='httpRequestBody'),
      httpRequestHeaders: string(name='HttpRequestHeaders', description='httpRequestHeaders'),
      httpRequestUrl: string(name='HttpRequestUrl', description='httpRequestUrl'),
      httpStartTime: string(name='HttpStartTime', description='httpStartTime'),
      httpResponseBody: string(name='HttpResponseBody', description='httpResponseBody'),
      httpResponseFailMsg: string(name='HttpResponseFailMsg', description='HttpResponseFailMsg'),
      httpResponseHeaders: string(name='HttpResponseHeaders', description='httpResponseHeaders'),
      importContent: string(name='ImportContent', description='ImportContent'),
      exportConfig: string(name='ExportConfig', description='exportConfig'),
      exportContent: string(name='ExportContent', description='exportContent'),
      checkResult: string(name='CheckResult', description='checkResult'),
      httpTiming: string(name='HttpTiming', description='httpTiming'),
      rt: string(name='Rt', description='rt'),
      httpResponseStatus: string(name='HttpResponseStatus', description='httpResponseStatus'),
      transId: string(name='TransId', description='trans_id'),
      groupTag: string(name='GroupTag', description='groupTag'),
    }
  ](name='SamplingLogs', description='samplingLogs'),
}

async function describeSamplingLogWithOptions(request: DescribeSamplingLogRequest, runtime: Util.RuntimeOptions): DescribeSamplingLogResponse {
  Util.validateModel(request);
  return doRequest('DescribeSamplingLog', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeSamplingLog(request: DescribeSamplingLogRequest): DescribeSamplingLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSamplingLogWithOptions(request, runtime);
}

model RemoveReportsRequest = {
  reportIds: map[string]any(name='ReportIds', description='reportIds'),
}

model RemoveReportsResponse = {
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function removeReportsWithOptions(request: RemoveReportsRequest, runtime: Util.RuntimeOptions): RemoveReportsResponse {
  Util.validateModel(request);
  return doRequest('RemoveReports', 'HTTPS', 'GET', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function removeReports(request: RemoveReportsRequest): RemoveReportsResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeReportsWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
