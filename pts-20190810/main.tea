import Util;
import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('pts', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model DescribeConfigRequest = {
  routeRequestBody?: map[string]any(name='RouteRequestBody', description='routeRequestBody'),
}

model DescribeConfigResponse = {
  requestId: string(name='RequestId', description='requestId'),
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  routeResponseBody: string(name='RouteResponseBody', description='pasResult'),
  success: string(name='Success', description='success'),
}

async function describeConfigWithOptions(request: DescribeConfigRequest, runtime: Util.RuntimeOptions): DescribeConfigResponse {
  Util.validateModel(request);
  return doRequest('DescribeConfig', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function describeConfig(request: DescribeConfigRequest): DescribeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeConfigWithOptions(request, runtime);
}

model SubmitTestingRequest = {
  sceneId?: string(name='SceneId', description='sceneId'),
}

model SubmitTestingResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  submitResult: string(name='SubmitResult', description='submitResult'),
}

async function submitTestingWithOptions(request: SubmitTestingRequest, runtime: Util.RuntimeOptions): SubmitTestingResponse {
  Util.validateModel(request);
  return doRequest('SubmitTesting', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function submitTesting(request: SubmitTestingRequest): SubmitTestingResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitTestingWithOptions(request, runtime);
}

model SubmitProgressRequest = {
  sceneId?: string(name='SceneId', description='sceneId'),
  taskId?: string(name='TaskId', description='taskId'),
}

model SubmitProgressResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  submitResult: string(name='SubmitResult', description='submitResult'),
}

async function submitProgressWithOptions(request: SubmitProgressRequest, runtime: Util.RuntimeOptions): SubmitProgressResponse {
  Util.validateModel(request);
  return doRequest('SubmitProgress', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function submitProgress(request: SubmitProgressRequest): SubmitProgressResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitProgressWithOptions(request, runtime);
}

model ListSlaWarningsRequest = {
  planId: string(name='PlanId', description='planId'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
}

model ListSlaWarningsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  warnings: string(name='Warnings', description='warnings'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  totalCount: long(name='TotalCount', description='totalCount'),
}

async function listSlaWarningsWithOptions(request: ListSlaWarningsRequest, runtime: Util.RuntimeOptions): ListSlaWarningsResponse {
  Util.validateModel(request);
  return doRequest('ListSlaWarnings', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,BearerToken,PrivateKey', null, request, runtime);
}

async function listSlaWarnings(request: ListSlaWarningsRequest): ListSlaWarningsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSlaWarningsWithOptions(request, runtime);
}

model ListSlaSnapshotSummaryRequest = {
  planId: string(name='PlanId', description='planId'),
}

model ListSlaSnapshotSummaryResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  slaSummaryVO: string(name='SlaSummaryVO', description='slaSummaryVO'),
}

async function listSlaSnapshotSummaryWithOptions(request: ListSlaSnapshotSummaryRequest, runtime: Util.RuntimeOptions): ListSlaSnapshotSummaryResponse {
  Util.validateModel(request);
  return doRequest('ListSlaSnapshotSummary', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function listSlaSnapshotSummary(request: ListSlaSnapshotSummaryRequest): ListSlaSnapshotSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSlaSnapshotSummaryWithOptions(request, runtime);
}

model ExecuteSceneFunctionRequest = {
  expression: string(name='Expression', description='expression'),
}

model ExecuteSceneFunctionResponse = {
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  result: string(name='Result', description='result'),
}

async function executeSceneFunctionWithOptions(request: ExecuteSceneFunctionRequest, runtime: Util.RuntimeOptions): ExecuteSceneFunctionResponse {
  Util.validateModel(request);
  return doRequest('ExecuteSceneFunction', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function executeSceneFunction(request: ExecuteSceneFunctionRequest): ExecuteSceneFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  return executeSceneFunctionWithOptions(request, runtime);
}

model DescribeIntranetResourceRequest = {
}

model DescribeIntranetResourceResponse = {
  requestId: string(name='RequestId', description='requestId'),
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  intranetResource: string(name='IntranetResource', description='intranetResource'),
}

async function describeIntranetResourceWithOptions(request: DescribeIntranetResourceRequest, runtime: Util.RuntimeOptions): DescribeIntranetResourceResponse {
  Util.validateModel(request);
  return doRequest('DescribeIntranetResource', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeIntranetResource(request: DescribeIntranetResourceRequest): DescribeIntranetResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIntranetResourceWithOptions(request, runtime);
}

model UploadFileFromOSSRequest = {
  ossUrl?: string(name='OssUrl', description='ossUrl'),
}

model UploadFileFromOSSResponse = {
  requestId: string(name='RequestId', description='requestId'),
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  ptsDataFile: {
    fileKey: string(name='FileKey', description='fileKey'),
    fileName: string(name='FileName', description='fileName'),
    ossUrl: map[string]any(name='OssUrl', description='ossUrl'),
    lineCount: long(name='LineCount', description='lineCount'),
    skipFirstLine: boolean(name='SkipFirstLine', description='skipFirstLine'),
    delimiter: string(name='Delimiter', description='delimiter'),
    length: long(name='Length', description='length'),
    columns: string(name='Columns', description='columns'),
    useOnce: boolean(name='UseOnce', description='useOnce'),
    gmtCreateTS: long(name='GmtCreateTS', description='gmtCreateTS'),
  }(name='PtsDataFile', description='ptsDataFile'),
}

async function uploadFileFromOSSWithOptions(request: UploadFileFromOSSRequest, runtime: Util.RuntimeOptions): UploadFileFromOSSResponse {
  Util.validateModel(request);
  return doRequest('UploadFileFromOSS', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function uploadFileFromOSS(request: UploadFileFromOSSRequest): UploadFileFromOSSResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadFileFromOSSWithOptions(request, runtime);
}

model ListSlaSnapshotRealRequest = {
  planId: string(name='PlanId', description='planId'),
}

model ListSlaSnapshotRealResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  slaSummaryVO: string(name='SlaSummaryVO', description='slaSummaryVO'),
}

async function listSlaSnapshotRealWithOptions(request: ListSlaSnapshotRealRequest, runtime: Util.RuntimeOptions): ListSlaSnapshotRealResponse {
  Util.validateModel(request);
  return doRequest('ListSlaSnapshotReal', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function listSlaSnapshotReal(request: ListSlaSnapshotRealRequest): ListSlaSnapshotRealResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSlaSnapshotRealWithOptions(request, runtime);
}

model StopSceneTestingRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
}

model StopSceneTestingResponse = {
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  isSuccess: boolean(name='IsSuccess', description='isSuccess'),
}

async function stopSceneTestingWithOptions(request: StopSceneTestingRequest, runtime: Util.RuntimeOptions): StopSceneTestingResponse {
  Util.validateModel(request);
  return doRequest('StopSceneTesting', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function stopSceneTesting(request: StopSceneTestingRequest): StopSceneTestingResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopSceneTestingWithOptions(request, runtime);
}

model DescribeSlaTemplateRequest = {
  type?: string(name='Type', description='type'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
}

model DescribeSlaTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  totalCount: integer(name='TotalCount', description='totalCount'),
  templates: [
    {
      id: string(name='Id', description='id'),
      type: string(name='Type', description='type'),
      name: string(name='Name', description='name'),
      description: string(name='Description', description='description'),
      uid: string(name='Uid', description='uid'),
      modifiedTime: long(name='ModifiedTime', description='modifiedTime'),
      classification: string(name='Classification', description='classification'),
      businessGroup: string(name='BusinessGroup', description='businessGroup'),
      businessChildGroup: string(name='BusinessChildGroup', description='businessChildGroup'),
      rules: string(name='Rules', description='rules'),
      deleted: integer(name='Deleted', description='deleted'),
    }
  ](name='Templates', description='templates'),
}

async function describeSlaTemplateWithOptions(request: DescribeSlaTemplateRequest, runtime: Util.RuntimeOptions): DescribeSlaTemplateResponse {
  Util.validateModel(request);
  return doRequest('DescribeSlaTemplate', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeSlaTemplate(request: DescribeSlaTemplateRequest): DescribeSlaTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSlaTemplateWithOptions(request, runtime);
}

model StartSceneTestingRequest = {
  sceneId?: string(name='SceneId', description='sceneId'),
}

model StartSceneTestingResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  planId: string(name='PlanId', description='planId'),
}

async function startSceneTestingWithOptions(request: StartSceneTestingRequest, runtime: Util.RuntimeOptions): StartSceneTestingResponse {
  Util.validateModel(request);
  return doRequest('StartSceneTesting', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function startSceneTesting(request: StartSceneTestingRequest): StartSceneTestingResponse {
  var runtime = new Util.RuntimeOptions{};
  return startSceneTestingWithOptions(request, runtime);
}

model SaveSceneRequest = {
  scene: string(name='Scene', description='scene'),
}

model SaveSceneResponse = {
  requestId: string(name='RequestId', description='requestId'),
  sceneId: string(name='SceneId', description='sceneId'),
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  codeKey: string(name='CodeKey', description='codeKey'),
}

async function saveSceneWithOptions(request: SaveSceneRequest, runtime: Util.RuntimeOptions): SaveSceneResponse {
  Util.validateModel(request);
  return doRequest('SaveScene', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function saveScene(request: SaveSceneRequest): SaveSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSceneWithOptions(request, runtime);
}

model CreateSceneRequest = {
  scene: string(name='Scene', description='scene'),
}

model CreateSceneResponse = {
  requestId: string(name='RequestId', description='requestId'),
  sceneId: string(name='SceneId', description='sceneId'),
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  codeKey: string(name='CodeKey', description='codeKey'),
}

async function createSceneWithOptions(request: CreateSceneRequest, runtime: Util.RuntimeOptions): CreateSceneResponse {
  Util.validateModel(request);
  return doRequest('CreateScene', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function createScene(request: CreateSceneRequest): CreateSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSceneWithOptions(request, runtime);
}

model ChangePressureRequest = {
  routeRequestBody?: map[string]any(name='RouteRequestBody', description='routeRequestBody'),
}

model ChangePressureResponse = {
  requestId: string(name='RequestId', description='requestId'),
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  routeResponseBody: string(name='RouteResponseBody', description='pasResult'),
  success: string(name='Success', description='success'),
}

async function changePressureWithOptions(request: ChangePressureRequest, runtime: Util.RuntimeOptions): ChangePressureResponse {
  Util.validateModel(request);
  return doRequest('ChangePressure', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function changePressure(request: ChangePressureRequest): ChangePressureResponse {
  var runtime = new Util.RuntimeOptions{};
  return changePressureWithOptions(request, runtime);
}

model ListEnginesRequest = {
  routeRequestBody?: map[string]any(name='RouteRequestBody', description='routeRequestBody'),
}

model ListEnginesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  routeResponseBody: string(name='RouteResponseBody', description='pasResult'),
  success: string(name='Success', description='success'),
}

async function listEnginesWithOptions(request: ListEnginesRequest, runtime: Util.RuntimeOptions): ListEnginesResponse {
  Util.validateModel(request);
  return doRequest('ListEngines', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function listEngines(request: ListEnginesRequest): ListEnginesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEnginesWithOptions(request, runtime);
}

model DescribeRealTimeLogRequest = {
  routeRequestBody?: map[string]any(name='RouteRequestBody', description='routeRequestBody'),
}

model DescribeRealTimeLogResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  requestId: string(name='RequestId', description='requestId'),
  routeResponseBody: string(name='RouteResponseBody', description='pasResult'),
  success: string(name='Success', description='success'),
}

async function describeRealTimeLogWithOptions(request: DescribeRealTimeLogRequest, runtime: Util.RuntimeOptions): DescribeRealTimeLogResponse {
  Util.validateModel(request);
  return doRequest('DescribeRealTimeLog', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function describeRealTimeLog(request: DescribeRealTimeLogRequest): DescribeRealTimeLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRealTimeLogWithOptions(request, runtime);
}

model DescribeStructureMonitorAuthRequest = {
}

model DescribeStructureMonitorAuthResponse = {
  requestId: string(name='RequestId', description='requestId'),
  structureNew: boolean(name='StructureNew', description='structureNew'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function describeStructureMonitorAuthWithOptions(request: DescribeStructureMonitorAuthRequest, runtime: Util.RuntimeOptions): DescribeStructureMonitorAuthResponse {
  Util.validateModel(request);
  return doRequest('DescribeStructureMonitorAuth', 'HTTPS', 'GET', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', request, null, runtime);
}

async function describeStructureMonitorAuth(request: DescribeStructureMonitorAuthRequest): DescribeStructureMonitorAuthResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeStructureMonitorAuthWithOptions(request, runtime);
}

model DescribeJMeterSampleSummaryRequest = {
  reportId: string(name='ReportId', description='reportId'),
  samplerId: integer(name='SamplerId', description='samplerId'),
}

model DescribeJMeterSampleSummaryResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  concurrencyRtStat: map[string]any(name='ConcurrencyRtStat', description='concurrencyRtStat'),
  concurrencyTpsStat: map[string]any(name='ConcurrencyTpsStat', description='concurrencyTpsStat'),
  rtDistribution: map[string]any(name='RtDistribution', description='rtDistribution'),
}

async function describeJMeterSampleSummaryWithOptions(request: DescribeJMeterSampleSummaryRequest, runtime: Util.RuntimeOptions): DescribeJMeterSampleSummaryResponse {
  Util.validateModel(request);
  return doRequest('DescribeJMeterSampleSummary', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function describeJMeterSampleSummary(request: DescribeJMeterSampleSummaryRequest): DescribeJMeterSampleSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJMeterSampleSummaryWithOptions(request, runtime);
}

model CloneJMeterSceneRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
}

model CloneJMeterSceneResponse = {
  requestId: string(name='RequestId', description='requestId'),
  sceneId: string(name='SceneId', description='sceneId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function cloneJMeterSceneWithOptions(request: CloneJMeterSceneRequest, runtime: Util.RuntimeOptions): CloneJMeterSceneResponse {
  Util.validateModel(request);
  return doRequest('CloneJMeterScene', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function cloneJMeterScene(request: CloneJMeterSceneRequest): CloneJMeterSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return cloneJMeterSceneWithOptions(request, runtime);
}

model AdjustJMeterSpeedRequest = {
  sceneId?: string(name='SceneId', description='sceneId'),
  loadMode?: string(name='LoadMode', description='loadMode'),
  speed?: integer(name='Speed', description='speed'),
}

model AdjustJMeterSpeedResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function adjustJMeterSpeedWithOptions(request: AdjustJMeterSpeedRequest, runtime: Util.RuntimeOptions): AdjustJMeterSpeedResponse {
  Util.validateModel(request);
  return doRequest('AdjustJMeterSpeed', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function adjustJMeterSpeed(request: AdjustJMeterSpeedRequest): AdjustJMeterSpeedResponse {
  var runtime = new Util.RuntimeOptions{};
  return adjustJMeterSpeedWithOptions(request, runtime);
}

model DescribeJMeterSamplingLogsRequest = {
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
  reportId: string(name='ReportId', description='reportId'),
  taskId?: long(name='TaskId', description='taskId'),
  samplerId?: integer(name='SamplerId', description='samplerId'),
  success?: boolean(name='Success', description='success'),
  thread?: string(name='Thread', description='thread'),
  keyword?: string(name='Keyword', description='keyword'),
  rtRange?: string(name='RtRange', description='rtRange'),
}

model DescribeJMeterSamplingLogsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  totalCount: long(name='TotalCount', description='totalCount'),
  sampleResults: [ string ] (name='SampleResults', description='sampleResults'),
}

async function describeJMeterSamplingLogsWithOptions(request: DescribeJMeterSamplingLogsRequest, runtime: Util.RuntimeOptions): DescribeJMeterSamplingLogsResponse {
  Util.validateModel(request);
  return doRequest('DescribeJMeterSamplingLogs', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function describeJMeterSamplingLogs(request: DescribeJMeterSamplingLogsRequest): DescribeJMeterSamplingLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJMeterSamplingLogsWithOptions(request, runtime);
}

model DescribeAgentNetTrafficRequest = {
  reportId: string(name='ReportId', description='reportId'),
  taskId: long(name='TaskId', description='taskId'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
}

model DescribeAgentNetTrafficResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  netTrafficInfo: [ map[string]any ] (name='NetTrafficInfo', description='netTrafficInfo'),
}

async function describeAgentNetTrafficWithOptions(request: DescribeAgentNetTrafficRequest, runtime: Util.RuntimeOptions): DescribeAgentNetTrafficResponse {
  Util.validateModel(request);
  return doRequest('DescribeAgentNetTraffic', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeAgentNetTraffic(request: DescribeAgentNetTrafficRequest): DescribeAgentNetTrafficResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAgentNetTrafficWithOptions(request, runtime);
}

model DescribeAgentCpuInfoRequest = {
  reportId: string(name='ReportId', description='reportId'),
  taskId: long(name='TaskId', description='taskId'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
}

model DescribeAgentCpuInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  cpuInfo: [ map[string]any ] (name='CpuInfo', description='cpuInfo'),
}

async function describeAgentCpuInfoWithOptions(request: DescribeAgentCpuInfoRequest, runtime: Util.RuntimeOptions): DescribeAgentCpuInfoResponse {
  Util.validateModel(request);
  return doRequest('DescribeAgentCpuInfo', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey', null, request, runtime);
}

async function describeAgentCpuInfo(request: DescribeAgentCpuInfoRequest): DescribeAgentCpuInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAgentCpuInfoWithOptions(request, runtime);
}

model DescribeAgentGCInfoRequest = {
  reportId: string(name='ReportId', description='reportId'),
  taskId: long(name='TaskId', description='taskId'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
}

model DescribeAgentGCInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  gcInfo: [ map[string]any ] (name='GcInfo', description='gcInfo'),
}

async function describeAgentGCInfoWithOptions(request: DescribeAgentGCInfoRequest, runtime: Util.RuntimeOptions): DescribeAgentGCInfoResponse {
  Util.validateModel(request);
  return doRequest('DescribeAgentGCInfo', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeAgentGCInfo(request: DescribeAgentGCInfoRequest): DescribeAgentGCInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAgentGCInfoWithOptions(request, runtime);
}

model DescribeAgentMemoryInfoRequest = {
  reportId: string(name='ReportId', description='reportId'),
  taskId: long(name='TaskId', description='taskId'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
}

model DescribeAgentMemoryInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  memoryInfo: [ map[string]any ] (name='MemoryInfo', description='memoryInfo'),
}

async function describeAgentMemoryInfoWithOptions(request: DescribeAgentMemoryInfoRequest, runtime: Util.RuntimeOptions): DescribeAgentMemoryInfoResponse {
  Util.validateModel(request);
  return doRequest('DescribeAgentMemoryInfo', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function describeAgentMemoryInfo(request: DescribeAgentMemoryInfoRequest): DescribeAgentMemoryInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAgentMemoryInfoWithOptions(request, runtime);
}

model DescribeAgentLoadInfoRequest = {
  reportId: string(name='ReportId', description='reportId'),
  taskId: long(name='TaskId', description='taskId'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
}

model DescribeAgentLoadInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  loadInfo: [ map[string]any ] (name='LoadInfo', description='loadInfo'),
}

async function describeAgentLoadInfoWithOptions(request: DescribeAgentLoadInfoRequest, runtime: Util.RuntimeOptions): DescribeAgentLoadInfoResponse {
  Util.validateModel(request);
  return doRequest('DescribeAgentLoadInfo', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function describeAgentLoadInfo(request: DescribeAgentLoadInfoRequest): DescribeAgentLoadInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAgentLoadInfoWithOptions(request, runtime);
}

model DescribeJMeterPlanRequest = {
  reportId: string(name='ReportId', description='reportId'),
}

model DescribeJMeterPlanResponse = {
  requestId: string(name='RequestId', description='requestId'),
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  report: string(name='Report', description='report'),
}

async function describeJMeterPlanWithOptions(request: DescribeJMeterPlanRequest, runtime: Util.RuntimeOptions): DescribeJMeterPlanResponse {
  Util.validateModel(request);
  return doRequest('DescribeJMeterPlan', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeJMeterPlan(request: DescribeJMeterPlanRequest): DescribeJMeterPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJMeterPlanWithOptions(request, runtime);
}

model DescribeJMeterSceneRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
}

model DescribeJMeterSceneResponse = {
  requestId: string(name='RequestId', description='requestId'),
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  scene: {
    name: string(name='Name', description='name'),
    pool: string(name='Pool', description='pool'),
    JMeterVersion: string(name='JMeterVersion', description='jmeterVersion'),
    concurrency: integer(name='Concurrency', description='concurrency'),
    rampUp: integer(name='RampUp', description='rampUp'),
    holdFor: integer(name='HoldFor', description='holdFor'),
    useIterations: boolean(name='UseIterations', description='useIterations'),
    iterations: integer(name='Iterations', description='iterations'),
    maxConcurrencyPerAgent: integer(name='MaxConcurrencyPerAgent', description='maxConcurrencyPerAgent'),
    specifyAgentCount: boolean(name='SpecifyAgentCount', description='specifyAgentCount'),
    agentCount: integer(name='AgentCount', description='agentCount'),
    splitCsv: boolean(name='SplitCsv', description='splitCsv'),
    testFile: string(name='TestFile', description='testFile'),
    fileList: string(name='FileList', description='fileList'),
    regionId: string(name='RegionId', description='regionId'),
    vpcId: string(name='VpcId', description='vpcId'),
    securityGroupId: string(name='SecurityGroupId', description='securityGroupId'),
    vSwitchId: string(name='VSwitchId', description='vSwitchId'),
    sceneId: string(name='SceneId', description='sceneId'),
    conditionSatisfiedExactly: boolean(name='ConditionSatisfiedExactly', description='conditionSatisfiedExactly'),
    syncTimerType: string(name='SyncTimerType', description='syncTimerType'),
    steps: integer(name='Steps', description='steps'),
    constantThroughputTimerType: string(name='ConstantThroughputTimerType', description='constantThroughputTimerType'),
    environmentId: string(name='EnvironmentId', description='environmentId'),
    condition: [
      {
        region: string(name='Region', description='region'),
        isp: string(name='Isp', description='isp'),
        amount: integer(name='Amount', description='amount'),
      }
    ](name='Condition', description='condition'),
    plan: {
      modifiedTime: long(name='ModifiedTime', description='gmtModified'),
      lastActive: long(name='LastActive', description='lastActive'),
      vum: long(name='Vum', description='vum'),
      hasReport: boolean(name='HasReport', description='hasReport'),
      vumWeight: long(name='VumWeight', description='vumWeight'),
      beginTime: long(name='BeginTime', description='startTime'),
    }(name='Plan', description='plan'),
  }(name='Scene', description='scene'),
}

async function describeJMeterSceneWithOptions(request: DescribeJMeterSceneRequest, runtime: Util.RuntimeOptions): DescribeJMeterSceneResponse {
  Util.validateModel(request);
  return doRequest('DescribeJMeterScene', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeJMeterScene(request: DescribeJMeterSceneRequest): DescribeJMeterSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJMeterSceneWithOptions(request, runtime);
}

model DescribeJMeterSceneRunningStatusRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
}

model DescribeJMeterSceneRunningStatusResponse = {
  requestId: string(name='RequestId', description='requestId'),
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  scene: {
    name: string(name='Name', description='name'),
    pool: string(name='Pool', description='pool'),
    jmeterVersion: string(name='JmeterVersion', description='jmeterVersion'),
    concurrency: integer(name='Concurrency', description='concurrency'),
    rampUp: integer(name='RampUp', description='rampUp'),
    holdFor: integer(name='HoldFor', description='holdFor'),
    useIterations: boolean(name='UseIterations', description='useIterations'),
    iterations: integer(name='Iterations', description='iterations'),
    maxConcurrencyPerAgent: integer(name='MaxConcurrencyPerAgent', description='maxConcurrencyPerAgent'),
    specifyAgentCount: boolean(name='SpecifyAgentCount', description='specifyAgentCount'),
    agentCount: integer(name='AgentCount', description='agentCount'),
    splitCsv: boolean(name='SplitCsv', description='splitCsv'),
    testFile: string(name='TestFile', description='testFile'),
    plan: string(name='Plan', description='plan'),
    steps: integer(name='Steps', description='steps'),
  }(name='Scene', description='scene'),
}

async function describeJMeterSceneRunningStatusWithOptions(request: DescribeJMeterSceneRunningStatusRequest, runtime: Util.RuntimeOptions): DescribeJMeterSceneRunningStatusResponse {
  Util.validateModel(request);
  return doRequest('DescribeJMeterSceneRunningStatus', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeJMeterSceneRunningStatus(request: DescribeJMeterSceneRunningStatusRequest): DescribeJMeterSceneRunningStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJMeterSceneRunningStatusWithOptions(request, runtime);
}

model DescribeJMeterTaskListRequest = {
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  reportId?: string(name='ReportId', description='reportId'),
}

model DescribeJMeterTaskListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  totalCount: long(name='TotalCount', description='totalCount'),
  taskList: string(name='TaskList', description='taskList'),
}

async function describeJMeterTaskListWithOptions(request: DescribeJMeterTaskListRequest, runtime: Util.RuntimeOptions): DescribeJMeterTaskListResponse {
  Util.validateModel(request);
  return doRequest('DescribeJMeterTaskList', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeJMeterTaskList(request: DescribeJMeterTaskListRequest): DescribeJMeterTaskListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJMeterTaskListWithOptions(request, runtime);
}

model DescribeJMeterLogsRequest = {
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  reportId?: string(name='ReportId', description='reportId'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
  taskId?: long(name='TaskId', description='taskId'),
  thread?: string(name='Thread', description='thread'),
  level?: string(name='Level', description='level'),
  loggerName?: string(name='LoggerName', description='loggerName'),
  keyword?: string(name='Keyword', description='keyword'),
}

model DescribeJMeterLogsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  totalCount: long(name='TotalCount', description='totalCount'),
  logs: string(name='Logs', description='logs'),
}

async function describeJMeterLogsWithOptions(request: DescribeJMeterLogsRequest, runtime: Util.RuntimeOptions): DescribeJMeterLogsResponse {
  Util.validateModel(request);
  return doRequest('DescribeJMeterLogs', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeJMeterLogs(request: DescribeJMeterLogsRequest): DescribeJMeterLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJMeterLogsWithOptions(request, runtime);
}

model StopJMeterTestingRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
}

model StopJMeterTestingResponse = {
  requestId: string(name='RequestId', description='requestId'),
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function stopJMeterTestingWithOptions(request: StopJMeterTestingRequest, runtime: Util.RuntimeOptions): StopJMeterTestingResponse {
  Util.validateModel(request);
  return doRequest('StopJMeterTesting', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function stopJMeterTesting(request: StopJMeterTestingRequest): StopJMeterTestingResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopJMeterTestingWithOptions(request, runtime);
}

model DescribeSampleMetricRequest = {
  reportId?: string(name='ReportId', description='reportId'),
  samplerId?: integer(name='SamplerId', description='samplerId'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
}

model DescribeSampleMetricResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  sampleMetricList: string(name='SampleMetricList', description='sampleMetricList'),
}

async function describeSampleMetricWithOptions(request: DescribeSampleMetricRequest, runtime: Util.RuntimeOptions): DescribeSampleMetricResponse {
  Util.validateModel(request);
  return doRequest('DescribeSampleMetric', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeSampleMetric(request: DescribeSampleMetricRequest): DescribeSampleMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSampleMetricWithOptions(request, runtime);
}

model DescribeJMeterChainDetailRequest = {
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  reportId?: string(name='ReportId', description='reportId'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
  taskId?: long(name='TaskId', description='taskId'),
  thread?: long(name='Thread', description='thread'),
  kw?: string(name='Kw', description='kw'),
  samplerId?: integer(name='SamplerId', description='samplerId'),
  success?: boolean(name='Success', description='success'),
}

model DescribeJMeterChainDetailResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  totalCount: long(name='TotalCount', description='totalCount'),
  sampleResults: string(name='SampleResults', description='sampleResults'),
}

async function describeJMeterChainDetailWithOptions(request: DescribeJMeterChainDetailRequest, runtime: Util.RuntimeOptions): DescribeJMeterChainDetailResponse {
  Util.validateModel(request);
  return doRequest('DescribeJMeterChainDetail', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeJMeterChainDetail(request: DescribeJMeterChainDetailRequest): DescribeJMeterChainDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJMeterChainDetailWithOptions(request, runtime);
}

model StartJMeterTestingRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
}

model StartJMeterTestingResponse = {
  requestId: string(name='RequestId', description='requestId'),
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  planId: string(name='PlanId', description='planId'),
}

async function startJMeterTestingWithOptions(request: StartJMeterTestingRequest, runtime: Util.RuntimeOptions): StartJMeterTestingResponse {
  Util.validateModel(request);
  return doRequest('StartJMeterTesting', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function startJMeterTesting(request: StartJMeterTestingRequest): StartJMeterTestingResponse {
  var runtime = new Util.RuntimeOptions{};
  return startJMeterTestingWithOptions(request, runtime);
}

model RemoveInstanceFromGroupRequest = {
  groupId: long(name='GroupId', description='groupId'),
  instanceIdAndPorts: map[string]any(name='InstanceIdAndPorts', description='instanceIdAndPorts'),
  ver: long(name='Ver', description='version'),
}

model RemoveInstanceFromGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
}

async function removeInstanceFromGroupWithOptions(request: RemoveInstanceFromGroupRequest, runtime: Util.RuntimeOptions): RemoveInstanceFromGroupResponse {
  Util.validateModel(request);
  return doRequest('RemoveInstanceFromGroup', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function removeInstanceFromGroup(request: RemoveInstanceFromGroupRequest): RemoveInstanceFromGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeInstanceFromGroupWithOptions(request, runtime);
}

model ReplaceOssFileRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
  originalOssFileUrl: string(name='OriginalOssFileUrl', description='originalOssFileUrl'),
  newOssFileUrl: string(name='NewOssFileUrl', description='newOssFileUrl'),
  jobId?: string(name='JobId', description='jobId'),
}

model ReplaceOssFileResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  finished: boolean(name='Finished', description='finished'),
  jobId: string(name='JobId', description='jobId'),
  timeout: integer(name='Timeout', description='timeout'),
}

async function replaceOssFileWithOptions(request: ReplaceOssFileRequest, runtime: Util.RuntimeOptions): ReplaceOssFileResponse {
  Util.validateModel(request);
  return doRequest('ReplaceOssFile', 'HTTPS', 'POST', '2019-08-10', 'AK', null, request, runtime);
}

async function replaceOssFile(request: ReplaceOssFileRequest): ReplaceOssFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return replaceOssFileWithOptions(request, runtime);
}

model StartTestingRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
}

model StartTestingResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  sceneId: string(name='SceneId', description='sceneId'),
  reportId: string(name='ReportId', description='reportId'),
}

async function startTestingWithOptions(request: StartTestingRequest, runtime: Util.RuntimeOptions): StartTestingResponse {
  Util.validateModel(request);
  return doRequest('StartTesting', 'HTTPS', 'GET', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', request, null, runtime);
}

async function startTesting(request: StartTestingRequest): StartTestingResponse {
  var runtime = new Util.RuntimeOptions{};
  return startTestingWithOptions(request, runtime);
}

model StopTestingRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
}

model StopTestingResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
}

async function stopTestingWithOptions(request: StopTestingRequest, runtime: Util.RuntimeOptions): StopTestingResponse {
  Util.validateModel(request);
  return doRequest('StopTesting', 'HTTPS', 'GET', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', request, null, runtime);
}

async function stopTesting(request: StopTestingRequest): StopTestingResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopTestingWithOptions(request, runtime);
}

model ListReportsRequest = {
  keyword?: string(name='Keyword', description='keywords'),
  pageSize: integer(name='PageSize', description='pageSize'),
  sceneType?: string(name='SceneType', description='sceneType'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  sceneId?: string(name='SceneId', description='sceneId'),
}

model ListReportsResponse = {
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  code: string(name='Code', description='code'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  pageSize: integer(name='PageSize', description='pageSize'),
  totalCount: integer(name='TotalCount', description='totalCount'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  reports: [
    {
      reportId: string(name='ReportId', description='reportId'),
      sceneId: string(name='SceneId', description='sceneId'),
      sceneName: string(name='SceneName', description='sceneName'),
      sceneType: string(name='SceneType', description='sceneType'),
      maxConcurrency: integer(name='MaxConcurrency', description='maxConcurrency'),
      vum: integer(name='Vum', description='vum'),
      duration: string(name='Duration', description='duration'),
      beginTime: long(name='BeginTime', description='beginTime'),
      sceneDeleted: boolean(name='SceneDeleted', description='sceneDeleted'),
      requestId: string(name='RequestId', description='requestId'),
    }
  ](name='Reports', description='reports'),
}

async function listReportsWithOptions(request: ListReportsRequest, runtime: Util.RuntimeOptions): ListReportsResponse {
  Util.validateModel(request);
  return doRequest('ListReports', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function listReports(request: ListReportsRequest): ListReportsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listReportsWithOptions(request, runtime);
}

model DescribeReportChainDetailRequest = {
  reportId: string(name='ReportId', description='reportId'),
  chainId?: long(name='ChainId', description='chainId'),
  beginTime?: long(name='BeginTime', description='beginTime'),
  endTime?: long(name='EndTime', description='endTime'),
}

model DescribeReportChainDetailResponse = {
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  chainDetails: [
    {
      totalFail: long(name='TotalFail', description='totalFail'),
      qpsFail: float(name='QpsFail', description='qpsFail'),
      total3XX: long(name='Total3XX', description='total300'),
      realConcurrency: float(name='RealConcurrency', description='concurrency'),
      timePoint: long(name='TimePoint', description='timePoint'),
      maxRt: integer(name='MaxRt', description='maxRt'),
      minRt: integer(name='MinRt', description='minRt'),
      totalRequest: long(name='TotalRequest', description='realTotal'),
      qps2XX: float(name='Qps2XX', description='qps200'),
      total4XX: long(name='Total4XX', description='total400'),
      total5XX: long(name='Total5XX', description='total500'),
      qps4XX: float(name='Qps4XX', description='qps400'),
      realQps: float(name='RealQps', description='realQps'),
      configQps: integer(name='ConfigQps', description='configQps'),
      averageRt: integer(name='AverageRt', description='avgRt'),
      bpsRequest: long(name='BpsRequest', description='bpsRequest'),
      chainId: long(name='ChainId', description='chainId'),
      bpsResponse: long(name='BpsResponse', description='bpsResponse'),
      total2XX: long(name='Total2XX', description='total200'),
      qps5XX: float(name='Qps5XX', description='qps500'),
      qps3XX: float(name='Qps3XX', description='qps300'),
      qpsHit: float(name='QpsHit', description='qpsHit'),
      qpsMiss: float(name='QpsMiss', description='qpsMiss'),
      totalHit: long(name='TotalHit', description='totalHit'),
      totalMiss: long(name='TotalMiss', description='totalMiss'),
    }
  ](name='ChainDetails', description='chainDetails'),
}

async function describeReportChainDetailWithOptions(request: DescribeReportChainDetailRequest, runtime: Util.RuntimeOptions): DescribeReportChainDetailResponse {
  Util.validateModel(request);
  return doRequest('DescribeReportChainDetail', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeReportChainDetail(request: DescribeReportChainDetailRequest): DescribeReportChainDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeReportChainDetailWithOptions(request, runtime);
}

model DescribeReportChainSummaryRequest = {
  reportId: string(name='ReportId', description='reportId'),
}

model DescribeReportChainSummaryResponse = {
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  chainSummary: [
    {
      chainId: long(name='ChainId', description='chainId'),
      averageTps: float(name='AverageTps', description='avgTps'),
      succeedRequestRate: float(name='SucceedRequestRate', description='reqSucRate'),
      hasCheckPoint: boolean(name='HasCheckPoint', description='hasAssert'),
      chainName: string(name='ChainName', description='chainName'),
      totalRequest: long(name='TotalRequest', description='totalRequest'),
      count5XX: long(name='Count5XX', description='count5xx'),
      relationName: string(name='RelationName', description='relationName'),
      count4XX: long(name='Count4XX', description='count4xx'),
      countTimeout: long(name='CountTimeout', description='countTimeout'),
      seg75Rt: long(name='Seg75Rt', description='seg75Rt'),
      failedBusinessCount: long(name='FailedBusinessCount', description='bizFailCount'),
      failedRequestCount: long(name='FailedRequestCount', description='reqFailCount'),
      seg90Rt: long(name='Seg90Rt', description='seg90Rt'),
      maxRt: integer(name='MaxRt', description='maxRt'),
      minRt: integer(name='MinRt', description='minRt'),
      count3XX: long(name='Count3XX', description='count3xx'),
      averageRt: float(name='AverageRt', description='avgRt'),
      relationId: long(name='RelationId', description='relationId'),
      succeedBusinessRate: float(name='SucceedBusinessRate', description='bizSucRate'),
      seg50Rt: integer(name='Seg50Rt', description='seg50Rt'),
      seg99Rt: integer(name='Seg99Rt', description='seg99Rt'),
      averageConcurrency: float(name='AverageConcurrency', description='avgConcurrency'),
      exceptions: string(name='Exceptions', description='exceptions'),
    }
  ](name='ChainSummary', description='chainSummary'),
}

async function describeReportChainSummaryWithOptions(request: DescribeReportChainSummaryRequest, runtime: Util.RuntimeOptions): DescribeReportChainSummaryResponse {
  Util.validateModel(request);
  return doRequest('DescribeReportChainSummary', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeReportChainSummary(request: DescribeReportChainSummaryRequest): DescribeReportChainSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeReportChainSummaryWithOptions(request, runtime);
}

model RemoveScenesRequest = {
  sceneIds: map[string]any(name='SceneIds', description='sceneIds'),
}

model RemoveScenesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function removeScenesWithOptions(request: RemoveScenesRequest, runtime: Util.RuntimeOptions): RemoveScenesResponse {
  Util.validateModel(request);
  return doRequest('RemoveScenes', 'HTTPS', 'GET', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', request, null, runtime);
}

async function removeScenes(request: RemoveScenesRequest): RemoveScenesResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeScenesWithOptions(request, runtime);
}

model DescribeReportRequest = {
  reportId: string(name='ReportId', description='ReportId'),
}

model DescribeReportResponse = {
  averageConcurrency: integer(name='AverageConcurrency', description='averageConcurrency'),
  avgBw: long(name='AvgBw', description='avgBw'),
  successRateReq: float(name='SuccessRateReq', description='successRateReq'),
  endTimeTS: long(name='EndTimeTS', description='endTimeTS'),
  startTimeTS: long(name='StartTimeTS', description='startTimeTS'),
  totalAgents: integer(name='TotalAgents', description='totalAgents'),
  requestCount: long(name='RequestCount', description='requestCount'),
  rpsLimit: long(name='RpsLimit', description='rpsLimit'),
  aliveAgents: integer(name='AliveAgents', description='aliveAgents'),
  maxTps: long(name='MaxTps', description='maxTps'),
  concurrencyLimit: long(name='ConcurrencyLimit', description='concurrencyLimit'),
  maxConcurrency: long(name='MaxConcurrency', description='maxConcurrency'),
  sceneDeleted: boolean(name='SceneDeleted', description='sceneDeleted'),
  duration: string(name='Duration', description='duration'),
  maxBw: long(name='MaxBw', description='maxBw'),
  vum: long(name='Vum', description='vum'),
  failCountBiz: long(name='FailCountBiz', description='failCountBiz'),
  failCountReq: long(name='FailCountReq', description='failCountReq'),
  successRateBiz: float(name='SuccessRateBiz', description='successRateBiz'),
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  reportView: string(name='ReportView', description='reportView'),
  chargeType: string(name='ChargeType', description='chargeType'),
  agentsLocations: string(name='AgentsLocations', description='agentsLocations'),
  relations: [
    {
      name: string(name='Name', description='name'),
      id: long(name='Id', description='Id'),
      disabled: boolean(name='Disabled', description='disabled'),
      headers: map[string]any(name='Headers', description='headers'),
      relationTestConfig: map[string]any(name='RelationTestConfig', description='relationTestConfig'),
      nodes: [
        {
          type: string(name='Type', description='type'),
          id: long(name='Id', description='id'),
          name: string(name='Name', description='name'),
          config: map[string]any(name='Config', description='config'),
        }
      ](name='Nodes', description='nodes'),
    }
  ](name='Relations', description='relations'),
  sceneSnapshot: {
    type: string(name='Type', description='type'),
    sceneName: string(name='SceneName', description='sceneName'),
    testConfig: string(name='TestConfig', description='testConfig'),
    status: integer(name='Status', description='status'),
    execStatus: string(name='ExecStatus', description='execStatus'),
  }(name='SceneSnapshot', description='sceneSnapshot'),
}

async function describeReportWithOptions(request: DescribeReportRequest, runtime: Util.RuntimeOptions): DescribeReportResponse {
  Util.validateModel(request);
  return doRequest('DescribeReport', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeReport(request: DescribeReportRequest): DescribeReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeReportWithOptions(request, runtime);
}

model ListScenesRequest = {
  keywords?: string(name='Keywords', description='keywords'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
}

model ListScenesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  totalCount: long(name='TotalCount', description='totalCount'),
  scenes: [
    {
      sceneId: string(name='SceneId', description='sceneId'),
      sceneName: string(name='SceneName', description='sceneName'),
      duration: integer(name='Duration', description='duration'),
      modifiedTime: long(name='ModifiedTime', description='modifiedTime'),
      sceneType: string(name='SceneType', description='sceneType'),
      cronable: boolean(name='Cronable', description='cronable'),
      execStatus: string(name='ExecStatus', description='execStatusVO'),
      status: integer(name='Status', description='status'),
      allsparkId: string(name='AllsparkId', description='allsparkId'),
      agentPool: string(name='AgentPool', description='agentPool'),
    }
  ](name='Scenes', description='scenes'),
}

async function listScenesWithOptions(request: ListScenesRequest, runtime: Util.RuntimeOptions): ListScenesResponse {
  Util.validateModel(request);
  return doRequest('ListScenes', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function listScenes(request: ListScenesRequest): ListScenesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listScenesWithOptions(request, runtime);
}

model DescribeSceneRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
}

model DescribeSceneResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  scene: {
    id: string(name='Id', description='id'),
    name: string(name='Name', description='name'),
    type: string(name='Type', description='type'),
    variables: map[string]any(name='Variables', description='variables'),
    headers: map[string]any(name='Headers', description='headers'),
    creator: string(name='Creator', description='creator'),
    modifier: string(name='Modifier', description='modifier'),
    createTime: long(name='CreateTime', description='createTime'),
    modifyTime: long(name='ModifyTime', description='modifyTime'),
    sla: string(name='Sla', description='sla'),
    relations: [
      {
        id: long(name='Id', description='id'),
        name: string(name='Name', description='name'),
        disabled: boolean(name='Disabled', description='disabled'),
        headers: map[string]any(name='Headers', description='headers'),
        nodes: [
          {
            nodeId: long(name='NodeId', description='nodeId'),
            name: string(name='Name', description='name'),
            nodeType: string(name='NodeType', description='nodeType'),
            config: string(name='Config', description='config'),
            params: string(name='Params', description='params'),
          }
        ](name='Nodes', description='nodes'),
        relationTestConfig: {
          beginStep: integer(name='BeginStep', description='beginStep'),
          increment: integer(name='Increment', description='increment'),
          endStep: integer(name='EndStep', description='endStep'),
        }(name='RelationTestConfig', description='relationTestConfig'),
      }
    ](name='Relations', description='relations'),
    vips: [
      {
        domain: string(name='Domain', description='domain'),
        enabled: boolean(name='Enabled', description='enabled'),
        ips: [ string ](name='Ips', description='ips'),
      }
    ](name='Vips', description='vips'),
    files: [
      {
        fileKey: string(name='FileKey', description='fileKey'),
        fileName: string(name='FileName', description='fileName'),
        skipFirstLine: boolean(name='SkipFirstLine', description='skipFirstLine'),
        previewData: string(name='PreviewData', description='previewData'),
        remoteUrl: string(name='RemoteUrl', description='remoteUrl'),
        ossUrl: string(name='OssUrl', description='ossUrl'),
        columns: string(name='Columns', description='columns'),
        processedLineCount: long(name='ProcessedLineCount', description='processedLineCount'),
        bizType: string(name='BizType', description='bizType'),
        exports: string(name='Exports', description='exports'),
        createTime: long(name='CreateTime', description='createTime'),
        useOnce: boolean(name='UseOnce', description='useOnce'),
        delimiter: string(name='Delimiter', description='delimiter'),
        length: long(name='Length', description='length'),
        lineCount: long(name='LineCount', description='lineCount'),
        exportedParams: [
          {
            name: string(name='Name', description='name'),
            column: string(name='Column', description='column'),
          }
        ](name='ExportedParams', description='exportParams'),
      }
    ](name='Files', description='files'),
    status: {
      operations: map[string]any(name='Operations', description='operations'),
      tips: string(name='Tips', description='tips'),
      debugging: boolean(name='Debugging', description='debugging'),
      testing: boolean(name='Testing', description='testing'),
      isCronable: boolean(name='IsCronable', description='isCronable'),
      isReusable: boolean(name='IsReusable', description='isReusable'),
      cronEditable: boolean(name='CronEditable', description='cronEditable'),
    }(name='Status', description='status'),
    testConfig: {
      mode: string(name='Mode', description='mode'),
      maxDuration: integer(name='MaxDuration', description='maxDuration'),
      autoStep: boolean(name='AutoStep', description='autoStep'),
      increment: integer(name='Increment', description='increment'),
      keepTime: integer(name='KeepTime', description='keepTime'),
      agentPool: string(name='AgentPool', description='agentPool'),
      concurrencyLimit: string(name='ConcurrencyLimit', description='concurrencyLimit'),
      customTraffic: boolean(name='CustomTraffic', description='customTraffic'),
      customConfig: string(name='CustomConfig', description='customConfig'),
      intelligentTest: boolean(name='IntelligentTest', description='intelligentTest'),
      agentCount: integer(name='AgentCount', description='agentCount'),
      tpsLimit: integer(name='TpsLimit', description='tpsLimit'),
      conditionSatisfiedExactly: string(name='ConditionSatisfiedExactly', description='conditionSatisfiedExactly'),
      conditions: [
        {
          region: string(name='Region', description='region'),
          isp: string(name='Isp', description='isp'),
          amount: integer(name='Amount', description='amount'),
        }
      ](name='Conditions', description='conditions'),
      vpcConfig: {
        regionId: string(name='RegionId', description='regionId'),
        vSwitchId: string(name='VSwitchId', description='vSwitchId'),
        securityGroupId: string(name='SecurityGroupId', description='securityGroupId'),
        vpcId: string(name='VpcId', description='vpcId'),
      }(name='VpcConfig', description='vpcConfig'),
    }(name='TestConfig', description='testConfig'),
  }(name='Scene', description='scene'),
}

async function describeSceneWithOptions(request: DescribeSceneRequest, runtime: Util.RuntimeOptions): DescribeSceneResponse {
  Util.validateModel(request);
  return doRequest('DescribeScene', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeScene(request: DescribeSceneRequest): DescribeSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSceneWithOptions(request, runtime);
}

model DescribeSceneRunningStatusRequest = {
  sceneId?: string(name='SceneId', description='sceneId'),
}

model DescribeSceneRunningStatusResponse = {
  tips: string(name='Tips', description='tips'),
  totalRequestCount: long(name='TotalRequestCount', description='totalRequestCount'),
  vum: long(name='Vum', description='vum'),
  requestBps: string(name='RequestBps', description='requestBps'),
  responseBps: string(name='ResponseBps', description='responseBps'),
  failedRequestCount: long(name='FailedRequestCount', description='failedRequestCount'),
  failedBusinessCount: long(name='FailedBusinessCount', description='failedBusinessCount'),
  concurrency: integer(name='Concurrency', description='concurrency'),
  concurrencyLimit: integer(name='ConcurrencyLimit', description='concurrencyLimit'),
  tps: integer(name='Tps', description='tps'),
  tpsLimit: integer(name='TpsLimit', description='tpsLimit'),
  aliveAgents: integer(name='AliveAgents', description='aliveAgents'),
  totalAgents: integer(name='TotalAgents', description='totalAgents'),
  seg90Rt: long(name='Seg90Rt', description='seg90Rt'),
  averageRt: long(name='AverageRt', description='averageRt'),
  reportId: string(name='ReportId', description='reportId'),
  beginTime: long(name='BeginTime', description='startTime'),
  currentTime: long(name='CurrentTime', description='currentTime'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  useCustomPool: boolean(name='UseCustomPool', description='useCustomPool'),
  requestId: string(name='RequestId', description='requestId'),
  status: integer(name='Status', description='status'),
  hasReport: boolean(name='HasReport', description='hasReport'),
  hasError: boolean(name='HasError', description='hasError'),
  agentLocation: string(name='AgentLocation', description='agentsLocation'),
  chainMonitorDataList: [
    {
      chainId: long(name='ChainId', description='chainId'),
      timePoint: long(name='TimePoint', description='timePoint'),
      configQps: integer(name='ConfigQps', description='configQps'),
      realQps: float(name='RealQps', description='realQps'),
      concurrency: float(name='Concurrency', description='concurrency'),
      qps2XX: float(name='Qps2XX', description='qps200'),
      failedQps: float(name='FailedQps', description='qpsFail'),
      averageRt: integer(name='AverageRt', description='avgRt'),
      maxRt: integer(name='MaxRt', description='maxRt'),
      minRt: integer(name='MinRt', description='minRt'),
      count2XX: long(name='Count2XX', description='count200'),
      failedCount: long(name='FailedCount', description='countFail'),
      queueSize: integer(name='QueueSize', description='queueSize'),
      queueCapacity: integer(name='QueueCapacity', description='queueCapacity'),
      qpsSummary: [
        {
          statusCode: integer(name='StatusCode', description='statusCode'),
          qps: float(name='Qps', description='qps'),
          totalCount: integer(name='TotalCount', description='totalCount'),
        }
      ](name='QpsSummary', description='qpsSummary'),
      checkPointResult: {
        succeedBusinessCount: long(name='SucceedBusinessCount', description='hitCount'),
        failedBusinessCount: long(name='FailedBusinessCount', description='missCount'),
        succeedBusinessQps: float(name='SucceedBusinessQps', description='hitQps'),
        failedBusinessQps: float(name='FailedBusinessQps', description='missQps'),
      }(name='CheckPointResult', description='overBizAssert'),
    }
  ](name='ChainMonitorDataList', description='monitorDataList'),
}

async function describeSceneRunningStatusWithOptions(request: DescribeSceneRunningStatusRequest, runtime: Util.RuntimeOptions): DescribeSceneRunningStatusResponse {
  Util.validateModel(request);
  return doRequest('DescribeSceneRunningStatus', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeSceneRunningStatus(request: DescribeSceneRunningStatusRequest): DescribeSceneRunningStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSceneRunningStatusWithOptions(request, runtime);
}

model AdjustSceneSpeedRequest = {
  sceneId: string(name='SceneId', description='sceneId'),
  speedData: string(name='SpeedData', description='speedData'),
  content?: string(name='Content', description='content'),
}

model AdjustSceneSpeedResponse = {
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function adjustSceneSpeedWithOptions(request: AdjustSceneSpeedRequest, runtime: Util.RuntimeOptions): AdjustSceneSpeedResponse {
  Util.validateModel(request);
  return doRequest('AdjustSceneSpeed', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function adjustSceneSpeed(request: AdjustSceneSpeedRequest): AdjustSceneSpeedResponse {
  var runtime = new Util.RuntimeOptions{};
  return adjustSceneSpeedWithOptions(request, runtime);
}

model AdjustRelationSpeedRequest = {
  sceneId?: string(name='SceneId', description='sceneId'),
  speed?: integer(name='Speed', description='speed'),
  relationIndex?: integer(name='RelationIndex', description='relationIndex'),
}

model AdjustRelationSpeedResponse = {
  message: string(name='Message', description='message'),
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function adjustRelationSpeedWithOptions(request: AdjustRelationSpeedRequest, runtime: Util.RuntimeOptions): AdjustRelationSpeedResponse {
  Util.validateModel(request);
  return doRequest('AdjustRelationSpeed', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function adjustRelationSpeed(request: AdjustRelationSpeedRequest): AdjustRelationSpeedResponse {
  var runtime = new Util.RuntimeOptions{};
  return adjustRelationSpeedWithOptions(request, runtime);
}

model DescribeSamplingLogRequest = {
  reportId: string(name='ReportId', description='reportId'),
  chainId?: long(name='ChainId', description='chainId'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  errorCode?: string(name='ErrorCode', description='errorCode'),
  httpResponseStatus?: string(name='HttpResponseStatus', description='httpResponseStatus'),
  rtRange?: string(name='RtRange', description='rtRange'),
}

model DescribeSamplingLogResponse = {
  message: string(name='Message', description='message'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  requestId: string(name='RequestId', description='requestId'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  totalCount: long(name='TotalCount', description='totalCount'),
  samplingLogs: [
    {
      chainId: string(name='ChainId', description='chainId'),
      timestamp: string(name='Timestamp', description='timestamp'),
      httpRequestMethod: string(name='HttpRequestMethod', description='httpRequestMethod'),
      httpRequestBody: string(name='HttpRequestBody', description='httpRequestBody'),
      httpRequestHeaders: string(name='HttpRequestHeaders', description='httpRequestHeaders'),
      httpRequestUrl: string(name='HttpRequestUrl', description='httpRequestUrl'),
      httpStartTime: string(name='HttpStartTime', description='httpStartTime'),
      httpResponseBody: string(name='HttpResponseBody', description='httpResponseBody'),
      httpResponseFailMsg: string(name='HttpResponseFailMsg', description='httpResponseFailMsg'),
      httpResponseHeaders: string(name='HttpResponseHeaders', description='httpResponseHeaders'),
      importContent: string(name='ImportContent', description='ImportContent'),
      exportConfig: string(name='ExportConfig', description='exportConfig'),
      exportContent: string(name='ExportContent', description='exportContent'),
      checkResult: string(name='CheckResult', description='checkResult'),
      httpTiming: string(name='HttpTiming', description='httpTiming'),
      rt: string(name='Rt', description='rt'),
      httpResponseStatus: string(name='HttpResponseStatus', description='httpResponseStatus'),
      transId: string(name='TransId', description='trans_id'),
      groupTag: string(name='GroupTag', description='groupTag'),
    }
  ](name='SamplingLogs', description='samplingLogs'),
}

async function describeSamplingLogWithOptions(request: DescribeSamplingLogRequest, runtime: Util.RuntimeOptions): DescribeSamplingLogResponse {
  Util.validateModel(request);
  return doRequest('DescribeSamplingLog', 'HTTPS', 'POST', '2019-08-10', 'AK,APP,PrivateKey,BearerToken', null, request, runtime);
}

async function describeSamplingLog(request: DescribeSamplingLogRequest): DescribeSamplingLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSamplingLogWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
