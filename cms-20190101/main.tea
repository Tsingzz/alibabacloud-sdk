import Util;
import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('cms', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model PutLogMonitorRequest = {
  logId?: string(name='LogId', description='id'),
  slsRegionId: string(name='SlsRegionId', description='slsRegionId'),
  slsProject: string(name='SlsProject', description='slsProject'),
  slsLogstore: string(name='SlsLogstore', description='slsLogstore'),
  metricName?: string(name='MetricName', description='metricName'),
  metricExpress?: string(name='MetricExpress', description='metricExpress'),
  groupId?: string(name='GroupId', description='productGroupId'),
  aggregates: [
    {
      alias: string(name='Alias', description='alias'),
      fieldName: string(name='FieldName', description='fieldName'),
      function: string(name='Function', description='function'),
    }
  ](name='Aggregates', description='aggregatesJson'),
  groupbys?: [
    {
      alias?: string(name='Alias', description='alias'),
      fieldName?: string(name='FieldName', description='fieldName'),
    }
  ](name='Groupbys', description='groupbysJson'),
  valueFilterRelation?: string(name='ValueFilterRelation', description='valueFilterRelation'),
  valueFilter?: [
    {
      key?: string(name='Key', description='key'),
      operator?: string(name='Operator', description='operator'),
      value?: string(name='Value', description='value'),
    }
  ](name='ValueFilter', description='valueFilterJson'),
  tumblingwindows?: string(name='Tumblingwindows', description='tumblingwindowsJson'),
  unit?: string(name='Unit', description='unit'),
}

model PutLogMonitorResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  logId: string(name='LogId', description='data.entity.id'),
}

async function putLogMonitorWithOptions(request: PutLogMonitorRequest, runtime: Util.RuntimeOptions): PutLogMonitorResponse {
  Util.validateModel(request);
  return doRequest('PutLogMonitor', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putLogMonitor(request: PutLogMonitorRequest): PutLogMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return putLogMonitorWithOptions(request, runtime);
}

model DeleteLogMonitorRequest = {
  logId: long(name='LogId', description='logId'),
}

model DeleteLogMonitorResponse = {
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  message: string(name='Message', description='message'),
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteLogMonitorWithOptions(request: DeleteLogMonitorRequest, runtime: Util.RuntimeOptions): DeleteLogMonitorResponse {
  Util.validateModel(request);
  return doRequest('DeleteLogMonitor', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteLogMonitor(request: DeleteLogMonitorRequest): DeleteLogMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLogMonitorWithOptions(request, runtime);
}

model DescribeLogMonitorListRequest = {
  pageNumber?: integer(name='PageNumber', description='page'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  searchValue?: string(name='SearchValue', description='searchValue'),
  groupId?: long(name='GroupId', description='groupId'),
}

model DescribeLogMonitorListResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  total: long(name='Total', description='total'),
  pageNumber: integer(name='PageNumber', description='page'),
  pageSize: integer(name='PageSize', description='pageSize'),
  logMonitorList: [
    {
      logId: long(name='LogId', description='id'),
      slsRegionId: string(name='SlsRegionId', description='slsRegionId'),
      slsProject: string(name='SlsProject', description='slsProject'),
      slsLogstore: string(name='SlsLogstore', description='slsLogstore'),
      metricName: string(name='MetricName', description='metricName'),
      gmtCreate: long(name='GmtCreate', description='gmtCreate'),
      valueFilterRelation: string(name='ValueFilterRelation', description='valueFilterRelation'),
      groupId: long(name='GroupId', description='productGroupId'),
      valueFilter: [
        {
          key: string(name='Key', description='key'),
          operator: string(name='Operator', description='operator'),
          value: string(name='Value', description='value'),
        }
      ](name='ValueFilter', description='valueFilter'),
    }
  ](name='LogMonitorList', description='data'),
}

async function describeLogMonitorListWithOptions(request: DescribeLogMonitorListRequest, runtime: Util.RuntimeOptions): DescribeLogMonitorListResponse {
  Util.validateModel(request);
  return doRequest('DescribeLogMonitorList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeLogMonitorList(request: DescribeLogMonitorListRequest): DescribeLogMonitorListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogMonitorListWithOptions(request, runtime);
}

model DescribeLogMonitorAttributeRequest = {
  metricName: string(name='MetricName', description='metricName'),
}

model DescribeLogMonitorAttributeResponse = {
  code: string(name='Code', description='code'),
  success: boolean(name='Success', description='success'),
  message: string(name='Message', description='message'),
  requestId: string(name='RequestId', description='requestId'),
  logMonitor: {
    logId: long(name='LogId', description='id'),
    slsRegionId: string(name='SlsRegionId', description='slsRegionId'),
    slsProject: string(name='SlsProject', description='slsProject'),
    slsLogstore: string(name='SlsLogstore', description='slsLogstore'),
    metricName: string(name='MetricName', description='metricName'),
    metricExpress: string(name='MetricExpress', description='metricExpress'),
    gmtCreate: long(name='GmtCreate', description='gmtCreate'),
    valueFilterRelation: string(name='ValueFilterRelation', description='valueFilterRelation'),
    groupId: long(name='GroupId', description='productGroupId'),
    aggregates: [
      {
        alias: string(name='Alias', description='alias'),
        fieldName: string(name='FieldName', description='fieldName'),
        function: string(name='Function', description='function'),
        min: string(name='Min', description='min'),
        max: string(name='Max', description='max'),
      }
    ](name='Aggregates', description='aggregates'),
    valueFilter: [
      {
        key: string(name='Key', description='key'),
        operator: string(name='Operator', description='operator'),
        value: string(name='Value', description='value'),
      }
    ](name='ValueFilter', description='valueFilter'),
    tumblingwindows: [ string ](name='Tumblingwindows', description='tumblingwindows'),
    groupbys: [ string ](name='Groupbys', description='groupbys'),
  }(name='LogMonitor', description='data'),
}

async function describeLogMonitorAttributeWithOptions(request: DescribeLogMonitorAttributeRequest, runtime: Util.RuntimeOptions): DescribeLogMonitorAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeLogMonitorAttribute', 'HTTPS', 'GET', '2019-01-01', 'AK', request, null, runtime);
}

async function describeLogMonitorAttribute(request: DescribeLogMonitorAttributeRequest): DescribeLogMonitorAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogMonitorAttributeWithOptions(request, runtime);
}

model ModifyHostInfoRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
  hostName?: string(name='HostName', description='hostName'),
}

model ModifyHostInfoResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
}

async function modifyHostInfoWithOptions(request: ModifyHostInfoRequest, runtime: Util.RuntimeOptions): ModifyHostInfoResponse {
  Util.validateModel(request);
  return doRequest('ModifyHostInfo', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function modifyHostInfo(request: ModifyHostInfoRequest): ModifyHostInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHostInfoWithOptions(request, runtime);
}

model DescribeExporterOutputListRequest = {
  pageNumber?: integer(name='PageNumber', description='page'),
  pageSize?: integer(name='PageSize', description='pageSize'),
}

model DescribeExporterOutputListResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
  total: integer(name='Total', description='total'),
  pageNumber: integer(name='PageNumber', description='currentPage'),
  success: boolean(name='Success', description='code'),
  datapoints: {
    datapoint: [
      {
        destName: string(name='DestName', description='name'),
        destType: string(name='DestType', description='type'),
        createTime: long(name='CreateTime', description='createTime'),
        configJson: {
          logstore: string(name='logstore', description='logstore'),
          project: string(name='project', description='project'),
          endpoint: string(name='endpoint', description='endpoint'),
          as: string(name='as', description='as'),
          ak: string(name='ak', description='ak'),
        }(name='ConfigJson', description='accessInfo'),
      }
    ](name='Datapoint', description='Datapoint'),
  }(name='Datapoints', description='datapoints'),
}

async function describeExporterOutputListWithOptions(request: DescribeExporterOutputListRequest, runtime: Util.RuntimeOptions): DescribeExporterOutputListResponse {
  Util.validateModel(request);
  return doRequest('DescribeExporterOutputList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeExporterOutputList(request: DescribeExporterOutputListRequest): DescribeExporterOutputListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExporterOutputListWithOptions(request, runtime);
}

model DeleteExporterOutputRequest = {
  destName: string(name='DestName', description='outputName'),
}

model DeleteExporterOutputResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
  success: boolean(name='Success', description='code'),
}

async function deleteExporterOutputWithOptions(request: DeleteExporterOutputRequest, runtime: Util.RuntimeOptions): DeleteExporterOutputResponse {
  Util.validateModel(request);
  return doRequest('DeleteExporterOutput', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteExporterOutput(request: DeleteExporterOutputRequest): DeleteExporterOutputResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExporterOutputWithOptions(request, runtime);
}

model PutExporterOutputRequest = {
  destName: string(name='DestName', description='destName'),
  configJson: string(name='ConfigJson', description='accessDetails'),
  desc?: string(name='Desc', description='desc'),
  destType?: string(name='DestType', description='outputType'),
}

model PutExporterOutputResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
  success: boolean(name='Success', description='code'),
}

async function putExporterOutputWithOptions(request: PutExporterOutputRequest, runtime: Util.RuntimeOptions): PutExporterOutputResponse {
  Util.validateModel(request);
  return doRequest('PutExporterOutput', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putExporterOutput(request: PutExporterOutputRequest): PutExporterOutputResponse {
  var runtime = new Util.RuntimeOptions{};
  return putExporterOutputWithOptions(request, runtime);
}

model DescribeFolderListRequest = {
  appName?: string(name='AppName', description='name'),
}

model DescribeFolderListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  total: integer(name='Total', description='total'),
  resource: {
    name: string(name='Name', description='name'),
    serviceId: long(name='ServiceId', description='id'),
  }(name='Resource', description='resource'),
}

async function describeFolderListWithOptions(request: DescribeFolderListRequest, runtime: Util.RuntimeOptions): DescribeFolderListResponse {
  Util.validateModel(request);
  return doRequest('DescribeFolderList', 'HTTPS', 'GET', '2019-01-01', 'AK', request, null, runtime);
}

async function describeFolderList(request: DescribeFolderListRequest): DescribeFolderListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFolderListWithOptions(request, runtime);
}

model DeleteExporterRuleRequest = {
  ruleName: string(name='RuleName', description='ruleName'),
}

model DeleteExporterRuleResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
  success: boolean(name='Success', description='code'),
}

async function deleteExporterRuleWithOptions(request: DeleteExporterRuleRequest, runtime: Util.RuntimeOptions): DeleteExporterRuleResponse {
  Util.validateModel(request);
  return doRequest('DeleteExporterRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteExporterRule(request: DeleteExporterRuleRequest): DeleteExporterRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExporterRuleWithOptions(request, runtime);
}

model DescribeExporterRuleListRequest = {
  pageNumber?: integer(name='PageNumber', description='page'),
  pageSize?: integer(name='PageSize', description='pageSize'),
}

model DescribeExporterRuleListResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
  total: integer(name='Total', description='total'),
  pageNumber: integer(name='PageNumber', description='currentPage'),
  success: boolean(name='Success', description='code'),
  datapoints: {
    datapoint: [
      {
        ruleName: string(name='RuleName', description='name'),
        namespace: string(name='Namespace', description='namespace'),
        metricName: string(name='MetricName', description='metric'),
        enabled: boolean(name='Enabled', description='enabled'),
        targetWindows: string(name='TargetWindows', description='targetWindows'),
        describe: string(name='Describe', description='desc'),
        dimension: string(name='Dimension', description='dimension'),
        createTime: long(name='CreateTime', description='createTime'),
        dstName: {
          dstName: [ string ](name='DstName', description='DstName'),
        }(name='DstName', description='dstNames'),
      }
    ](name='Datapoint', description='Datapoint'),
  }(name='Datapoints', description='datapoints'),
}

async function describeExporterRuleListWithOptions(request: DescribeExporterRuleListRequest, runtime: Util.RuntimeOptions): DescribeExporterRuleListResponse {
  Util.validateModel(request);
  return doRequest('DescribeExporterRuleList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeExporterRuleList(request: DescribeExporterRuleListRequest): DescribeExporterRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExporterRuleListWithOptions(request, runtime);
}

model PutExporterRuleRequest = {
  ruleName?: string(name='RuleName', description='name'),
  dstNames?: [ string ](name='DstNames', description='dstNameJson'),
  namespace?: string(name='Namespace', description='namespace'),
  metricName?: string(name='MetricName', description='metric'),
  targetWindows?: string(name='TargetWindows', description='targetWindows'),
  describe?: string(name='Describe', description='desc'),
}

model PutExporterRuleResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
  success: boolean(name='Success', description='code'),
}

async function putExporterRuleWithOptions(request: PutExporterRuleRequest, runtime: Util.RuntimeOptions): PutExporterRuleResponse {
  Util.validateModel(request);
  return doRequest('PutExporterRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putExporterRule(request: PutExporterRuleRequest): PutExporterRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putExporterRuleWithOptions(request, runtime);
}

model DescribeDynamicTagRuleListRequest = {
  tagKey?: string(name='TagKey', description='tagKey'),
  pageNumber?: string(name='PageNumber', description='pageNumber'),
  pageSize?: string(name='PageSize', description='pageSize'),
}

model DescribeDynamicTagRuleListResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
  total: integer(name='Total', description='total'),
  pageNumber: string(name='PageNumber', description='pageNumber'),
  pageSize: string(name='PageSize', description='pageSize'),
  tagGroupList: {
    tagGroup: [
      {
        dynamicTagRuleId: string(name='DynamicTagRuleId', description='uuid'),
        tagKey: string(name='TagKey', description='tagKey'),
        regionId: string(name='RegionId', description='regionId'),
        matchExpressFilterRelation: string(name='MatchExpressFilterRelation', description='filterRelation'),
        status: string(name='Status', description='runningStatus'),
        matchExpress: {
          matchExpress: [
            {
              tagValueMatchFunction: string(name='TagValueMatchFunction', description='function'),
              tagValue: string(name='TagValue', description='value'),
            }
          ](name='MatchExpress', description='MatchExpress'),
        }(name='MatchExpress', description='filters'),
        templateIdList: {
          templateIdList: [ string ](name='TemplateIdList', description='TemplateIdList'),
        }(name='TemplateIdList', description='templateList'),
      }
    ](name='TagGroup', description='TagGroup'),
  }(name='TagGroupList', description='resources'),
}

async function describeDynamicTagRuleListWithOptions(request: DescribeDynamicTagRuleListRequest, runtime: Util.RuntimeOptions): DescribeDynamicTagRuleListResponse {
  Util.validateModel(request);
  return doRequest('DescribeDynamicTagRuleList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeDynamicTagRuleList(request: DescribeDynamicTagRuleListRequest): DescribeDynamicTagRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDynamicTagRuleListWithOptions(request, runtime);
}

model DescribeProductResourceTagKeyListRequest = {
  nextToken?: string(name='NextToken', description='nextToken'),
}

model DescribeProductResourceTagKeyListResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  nextToken: string(name='NextToken', description='nextToken'),
  tagKeys: {
    tagKey: [ string ](name='TagKey', description='TagKey'),
  }(name='TagKeys', description='resources'),
}

async function describeProductResourceTagKeyListWithOptions(request: DescribeProductResourceTagKeyListRequest, runtime: Util.RuntimeOptions): DescribeProductResourceTagKeyListResponse {
  Util.validateModel(request);
  return doRequest('DescribeProductResourceTagKeyList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeProductResourceTagKeyList(request: DescribeProductResourceTagKeyListRequest): DescribeProductResourceTagKeyListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeProductResourceTagKeyListWithOptions(request, runtime);
}

model CreateDynamicTagGroupRequest = {
  tagKey: string(name='TagKey', description='tagKey'),
  enableSubscribeEvent?: boolean(name='EnableSubscribeEvent', description='enableSubscribeEvent'),
  enableInstallAgent?: boolean(name='EnableInstallAgent', description='enableInstallAgent'),
  regionId: string(name='RegionId', description='regionId'),
  matchExpressFilterRelation?: string(name='MatchExpressFilterRelation', description='filterRelation'),
  matchExpress?: [
    {
      tagValueMatchFunction?: string(name='TagValueMatchFunction', description='function'),
      tagValue?: string(name='TagValue', description='value'),
    }
  ](name='MatchExpress', description='filterJson'),
  contactGroupList: [ string ](name='ContactGroupList', description='contactList'),
  templateIdList?: [ string ](name='TemplateIdList', description='templateIdList'),
}

model CreateDynamicTagGroupResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
}

async function createDynamicTagGroupWithOptions(request: CreateDynamicTagGroupRequest, runtime: Util.RuntimeOptions): CreateDynamicTagGroupResponse {
  Util.validateModel(request);
  return doRequest('CreateDynamicTagGroup', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createDynamicTagGroup(request: CreateDynamicTagGroupRequest): CreateDynamicTagGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDynamicTagGroupWithOptions(request, runtime);
}

model DeleteDynamicTagGroupRequest = {
  dynamicTagRuleId: string(name='DynamicTagRuleId', description='uuid'),
}

model DeleteDynamicTagGroupResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteDynamicTagGroupWithOptions(request: DeleteDynamicTagGroupRequest, runtime: Util.RuntimeOptions): DeleteDynamicTagGroupResponse {
  Util.validateModel(request);
  return doRequest('DeleteDynamicTagGroup', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteDynamicTagGroup(request: DeleteDynamicTagGroupRequest): DeleteDynamicTagGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDynamicTagGroupWithOptions(request, runtime);
}

model ModifyGroupMonitoringAgentProcessRequest = {
  id: string(name='Id', description='uuid'),
  groupId: string(name='GroupId', description='groupId'),
  matchExpressFilterRelation?: string(name='MatchExpressFilterRelation', description='filterRelation'),
  alertConfig: [
    {
      effectiveInterval: string(name='EffectiveInterval', description='effectiveInterval'),
      noEffectiveInterval: string(name='NoEffectiveInterval', description='noEffectiveInterval'),
      silenceTime: string(name='SilenceTime', description='silenceTime'),
      webhook: string(name='Webhook', description='webhook'),
      escalationsLevel: string(name='EscalationsLevel', description='escalationsLevel'),
      comparisonOperator: string(name='ComparisonOperator', description='comparisonOperator'),
      statistics?: string(name='Statistics', description='statistics'),
      threshold: string(name='Threshold', description='threshold'),
      times: string(name='Times', description='times'),
    }
  ](name='AlertConfig', description='groupAlertJson'),
}

model ModifyGroupMonitoringAgentProcessResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
}

async function modifyGroupMonitoringAgentProcessWithOptions(request: ModifyGroupMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): ModifyGroupMonitoringAgentProcessResponse {
  Util.validateModel(request);
  return doRequest('ModifyGroupMonitoringAgentProcess', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function modifyGroupMonitoringAgentProcess(request: ModifyGroupMonitoringAgentProcessRequest): ModifyGroupMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGroupMonitoringAgentProcessWithOptions(request, runtime);
}

model DeleteGroupMonitoringAgentProcessRequest = {
  groupId: string(name='GroupId', description='groupId'),
  id?: string(name='Id', description='uuid'),
}

model DeleteGroupMonitoringAgentProcessResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteGroupMonitoringAgentProcessWithOptions(request: DeleteGroupMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): DeleteGroupMonitoringAgentProcessResponse {
  Util.validateModel(request);
  return doRequest('DeleteGroupMonitoringAgentProcess', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteGroupMonitoringAgentProcess(request: DeleteGroupMonitoringAgentProcessRequest): DeleteGroupMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGroupMonitoringAgentProcessWithOptions(request, runtime);
}

model CreateGroupMonitoringAgentProcessRequest = {
  groupId: string(name='GroupId', description='groupId'),
  processName?: string(name='ProcessName', description='processKeyword'),
  matchExpressFilterRelation?: string(name='MatchExpressFilterRelation', description='filterRelation'),
  matchExpress?: [
    {
      name?: string(name='Name', description='name'),
      function?: string(name='Function', description='function'),
      value?: string(name='Value', description='value'),
    }
  ](name='MatchExpress', description='filterJson'),
  alertConfig: [
    {
      effectiveInterval: string(name='EffectiveInterval', description='effectiveInterval'),
      noEffectiveInterval: string(name='NoEffectiveInterval', description='noEffectiveInterval'),
      silenceTime: string(name='SilenceTime', description='silenceTime'),
      webhook: string(name='Webhook', description='webhook'),
      escalationsLevel: string(name='EscalationsLevel', description='escalationsLevel'),
      comparisonOperator: string(name='ComparisonOperator', description='comparisonOperator'),
      statistics?: string(name='Statistics', description='statistics'),
      threshold: string(name='Threshold', description='threshold'),
      times: string(name='Times', description='times'),
    }
  ](name='AlertConfig', description='groupAlertJson'),
}

model CreateGroupMonitoringAgentProcessResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
}

async function createGroupMonitoringAgentProcessWithOptions(request: CreateGroupMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): CreateGroupMonitoringAgentProcessResponse {
  Util.validateModel(request);
  return doRequest('CreateGroupMonitoringAgentProcess', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createGroupMonitoringAgentProcess(request: CreateGroupMonitoringAgentProcessRequest): CreateGroupMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGroupMonitoringAgentProcessWithOptions(request, runtime);
}

model DescribeTagKeyListRequest = {
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  pageSize?: integer(name='PageSize', description='pageSize'),
}

model DescribeTagKeyListResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  tagKeys: {
    tagKey: [ string ](name='TagKey', description='TagKey'),
  }(name='TagKeys', description='resources'),
}

async function describeTagKeyListWithOptions(request: DescribeTagKeyListRequest, runtime: Util.RuntimeOptions): DescribeTagKeyListResponse {
  Util.validateModel(request);
  return doRequest('DescribeTagKeyList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeTagKeyList(request: DescribeTagKeyListRequest): DescribeTagKeyListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTagKeyListWithOptions(request, runtime);
}

model DescribeTagValueListRequest = {
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  tagKey: string(name='TagKey', description='tagKey'),
}

model DescribeTagValueListResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  tagValues: {
    tagValue: [ string ](name='TagValue', description='TagValue'),
  }(name='TagValues', description='resources'),
}

async function describeTagValueListWithOptions(request: DescribeTagValueListRequest, runtime: Util.RuntimeOptions): DescribeTagValueListResponse {
  Util.validateModel(request);
  return doRequest('DescribeTagValueList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeTagValueList(request: DescribeTagValueListRequest): DescribeTagValueListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTagValueListWithOptions(request, runtime);
}

model RemoveTagsRequest = {
  tag?: [
    {
      key: string(name='Key', description='key'),
      value: string(name='Value', description='value'),
    }
  ](name='Tag', description='tags'),
  groupIds: [ string ](name='GroupIds', description='groupIdList'),
}

model RemoveTagsResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  tag: {
    tags: [ string ](name='Tags', description='Tags'),
  }(name='Tag', description='resources'),
}

async function removeTagsWithOptions(request: RemoveTagsRequest, runtime: Util.RuntimeOptions): RemoveTagsResponse {
  Util.validateModel(request);
  return doRequest('RemoveTags', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function removeTags(request: RemoveTagsRequest): RemoveTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeTagsWithOptions(request, runtime);
}

model AddTagsRequest = {
  tag: [
    {
      key: string(name='Key', description='key'),
      value: string(name='Value', description='value'),
    }
  ](name='Tag', description='tags'),
  groupIds: [ string ](name='GroupIds', description='groupIdList'),
}

model AddTagsResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
}

async function addTagsWithOptions(request: AddTagsRequest, runtime: Util.RuntimeOptions): AddTagsResponse {
  Util.validateModel(request);
  return doRequest('AddTags', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function addTags(request: AddTagsRequest): AddTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTagsWithOptions(request, runtime);
}

model DescribeGroupMonitoringAgentProcessRequest = {
  groupId: string(name='GroupId', description='groupId'),
  processName?: string(name='ProcessName', description='processKeyword'),
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  pageSize?: integer(name='PageSize', description='pageSize'),
}

model DescribeGroupMonitoringAgentProcessResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  total: string(name='Total', description='total'),
  pageSize: string(name='PageSize', description='pageSize'),
  pageNumber: string(name='PageNumber', description='pageNumber'),
  processes: {
    process: [
      {
        id: string(name='Id', description='uuid'),
        groupId: string(name='GroupId', description='groupId'),
        processName: string(name='ProcessName', description='processKeyword'),
        matchExpressFilterRelation: string(name='MatchExpressFilterRelation', description='matchExpress.filterRelation'),
        matchExpress: {
          matchExpress: [
            {
              name: string(name='Name', description='name'),
              function: string(name='Function', description='function'),
              value: string(name='Value', description='value'),
            }
          ](name='MatchExpress', description='MatchExpress'),
        }(name='MatchExpress', description='matchExpress.filters'),
        alertConfig: {
          alertConfig: [
            {
              effectiveInterval: string(name='EffectiveInterval', description='effectiveInterval'),
              noEffectiveInterval: string(name='NoEffectiveInterval', description='noEffectiveInterval'),
              silenceTime: string(name='SilenceTime', description='silenceTime'),
              webhook: string(name='Webhook', description='webhook'),
              escalationsLevel: string(name='EscalationsLevel', description='escalationsLevel'),
              comparisonOperator: string(name='ComparisonOperator', description='comparisonOperator'),
              statistics: string(name='Statistics', description='statistics'),
              threshold: string(name='Threshold', description='threshold'),
              times: string(name='Times', description='times'),
            }
          ](name='AlertConfig', description='AlertConfig'),
        }(name='AlertConfig', description='groupAlert'),
      }
    ](name='Process', description='Process'),
  }(name='Processes', description='resources'),
}

async function describeGroupMonitoringAgentProcessWithOptions(request: DescribeGroupMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): DescribeGroupMonitoringAgentProcessResponse {
  Util.validateModel(request);
  return doRequest('DescribeGroupMonitoringAgentProcess', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeGroupMonitoringAgentProcess(request: DescribeGroupMonitoringAgentProcessRequest): DescribeGroupMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGroupMonitoringAgentProcessWithOptions(request, runtime);
}

model PutResourceMetricRulesRequest = {
  rules: [
    {
      ruleId: string(name='RuleId', description='alertName'),
      ruleName: string(name='RuleName', description='displayName'),
      namespace: string(name='Namespace', description='namespace'),
      metricName: string(name='MetricName', description='metricName'),
      resources: string(name='Resources', description='resources'),
      contactGroups: string(name='ContactGroups', description='contactGroups'),
      webhook?: string(name='Webhook', description='webhook'),
      effectiveInterval?: string(name='EffectiveInterval', description='effectiveInterval'),
      noEffectiveInterval?: string(name='NoEffectiveInterval', description='noEffectiveInterval'),
      silenceTime?: integer(name='SilenceTime', description='silenceTime'),
      period?: string(name='Period', description='period'),
      interval?: string(name='Interval', description='interval'),
      emailSubject?: string(name='EmailSubject', description='subject'),
      escalations: {
        critical: {
          statistics?: string(name='Statistics', description='criticalStatistics'),
          comparisonOperator?: string(name='ComparisonOperator', description='criticalComparisonOperator'),
          threshold?: string(name='Threshold', description='criticalThreshold'),
          times?: integer(name='Times', description='criticalTimes'),
        }(name='Critical', description='Critical'),
        warn: {
          statistics?: string(name='Statistics', description='warnStatistics'),
          comparisonOperator?: string(name='ComparisonOperator', description='warnComparisonOperator'),
          threshold?: string(name='Threshold', description='warnThreshold'),
          times?: integer(name='Times', description='warnTimes'),
        }(name='Warn', description='Warn'),
        info: {
          statistics?: string(name='Statistics', description='infoStatistics'),
          comparisonOperator?: string(name='ComparisonOperator', description='infoComparisonOperator'),
          threshold?: string(name='Threshold', description='infoThreshold'),
          times?: integer(name='Times', description='infoTimes'),
        }(name='Info', description='Info'),
      }(name='Escalations', description='Escalations'),
    }
  ](name='Rules', description='alarms'),
}

model PutResourceMetricRulesResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='requestId'),
  failedListResult: {
    target: [
      {
        ruleId: string(name='RuleId', description='ruleId'),
        result: {
          code: string(name='Code', description='code'),
          message: string(name='Message', description='message'),
          success: boolean(name='Success', description='success'),
        }(name='Result', description='result'),
      }
    ](name='Target', description='Target'),
  }(name='FailedListResult', description='datapoints'),
}

async function putResourceMetricRulesWithOptions(request: PutResourceMetricRulesRequest, runtime: Util.RuntimeOptions): PutResourceMetricRulesResponse {
  Util.validateModel(request);
  return doRequest('PutResourceMetricRules', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putResourceMetricRules(request: PutResourceMetricRulesRequest): PutResourceMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return putResourceMetricRulesWithOptions(request, runtime);
}

model CreateMetricRuleResourcesRequest = {
  ruleId?: string(name='RuleId', description='alertName'),
  overwrite?: string(name='Overwrite', description='overwrite'),
  resources: string(name='Resources', description='resources'),
}

model CreateMetricRuleResourcesResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  requestId: string(name='RequestId', description='requestId'),
}

async function createMetricRuleResourcesWithOptions(request: CreateMetricRuleResourcesRequest, runtime: Util.RuntimeOptions): CreateMetricRuleResourcesResponse {
  Util.validateModel(request);
  return doRequest('CreateMetricRuleResources', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createMetricRuleResources(request: CreateMetricRuleResourcesRequest): CreateMetricRuleResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMetricRuleResourcesWithOptions(request, runtime);
}

model DeleteMetricRuleResourcesRequest = {
  ruleId?: string(name='RuleId', description='alertName'),
  resources: string(name='Resources', description='resources'),
}

model DeleteMetricRuleResourcesResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteMetricRuleResourcesWithOptions(request: DeleteMetricRuleResourcesRequest, runtime: Util.RuntimeOptions): DeleteMetricRuleResourcesResponse {
  Util.validateModel(request);
  return doRequest('DeleteMetricRuleResources', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteMetricRuleResources(request: DeleteMetricRuleResourcesRequest): DeleteMetricRuleResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetricRuleResourcesWithOptions(request, runtime);
}

model DeleteMetricRuleTargetsRequest = {
  ruleId: string(name='RuleId', description='ruleName'),
  targetIds?: [ string ](name='TargetIds', description='targetIds'),
}

model DeleteMetricRuleTargetsResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
  failIds: {
    targetIds: {
      targetId: [ string ](name='TargetId', description='TargetId'),
    }(name='TargetIds', description='targetIds'),
  }(name='FailIds', description='result'),
}

async function deleteMetricRuleTargetsWithOptions(request: DeleteMetricRuleTargetsRequest, runtime: Util.RuntimeOptions): DeleteMetricRuleTargetsResponse {
  Util.validateModel(request);
  return doRequest('DeleteMetricRuleTargets', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteMetricRuleTargets(request: DeleteMetricRuleTargetsRequest): DeleteMetricRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetricRuleTargetsWithOptions(request, runtime);
}

model PutMetricRuleTargetsRequest = {
  ruleId: string(name='RuleId', description='ruleName'),
  targets: [
    {
      id: string(name='Id', description='id'),
      arn: string(name='Arn', description='arn'),
      level?: string(name='Level', description='level'),
    }
  ](name='Targets', description='commonTargets'),
}

model PutMetricRuleTargetsResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
  failData: {
    targets: {
      target: [
        {
          id: string(name='Id', description='id'),
          arn: string(name='Arn', description='arn'),
          level: string(name='Level', description='level'),
        }
      ](name='Target', description='Target'),
    }(name='Targets', description='targets'),
  }(name='FailData', description='result'),
}

async function putMetricRuleTargetsWithOptions(request: PutMetricRuleTargetsRequest, runtime: Util.RuntimeOptions): PutMetricRuleTargetsResponse {
  Util.validateModel(request);
  return doRequest('PutMetricRuleTargets', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putMetricRuleTargets(request: PutMetricRuleTargetsRequest): PutMetricRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return putMetricRuleTargetsWithOptions(request, runtime);
}

model DescribeMetricRuleTargetsRequest = {
  ruleId: string(name='RuleId', description='ruleName'),
}

model DescribeMetricRuleTargetsResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='traceId'),
  targets: {
    target: [
      {
        id: string(name='Id', description='id'),
        arn: string(name='Arn', description='arn'),
        level: string(name='Level', description='level'),
      }
    ](name='Target', description='Target'),
  }(name='Targets', description='result.targets'),
}

async function describeMetricRuleTargetsWithOptions(request: DescribeMetricRuleTargetsRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleTargetsResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricRuleTargets', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMetricRuleTargets(request: DescribeMetricRuleTargetsRequest): DescribeMetricRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleTargetsWithOptions(request, runtime);
}

model ModifyMonitorGroupInstancesRequest = {
  groupId: long(name='GroupId', description='groupId'),
  instances: [
    {
      category: string(name='Category', description='category'),
      instanceId: string(name='InstanceId', description='instanceId'),
      regionId: string(name='RegionId', description='regionId'),
      instanceName: string(name='InstanceName', description='instanceName'),
    }
  ](name='Instances', description='instances'),
}

model ModifyMonitorGroupInstancesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
}

async function modifyMonitorGroupInstancesWithOptions(request: ModifyMonitorGroupInstancesRequest, runtime: Util.RuntimeOptions): ModifyMonitorGroupInstancesResponse {
  Util.validateModel(request);
  return doRequest('ModifyMonitorGroupInstances', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function modifyMonitorGroupInstances(request: ModifyMonitorGroupInstancesRequest): ModifyMonitorGroupInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMonitorGroupInstancesWithOptions(request, runtime);
}

model DescribeMonitoringAgentStatusesRequest = {
  instanceIds: string(name='InstanceIds', description='instanceIds'),
}

model DescribeMonitoringAgentStatusesResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  nodeStatusList: {
    nodeStatus: [
      {
        instanceId: string(name='InstanceId', description='instanceId'),
        autoInstall: boolean(name='AutoInstall', description='autoInstall'),
        status: string(name='Status', description='status'),
      }
    ](name='NodeStatus', description='NodeStatus'),
  }(name='NodeStatusList', description='nodeStatusList'),
}

async function describeMonitoringAgentStatusesWithOptions(request: DescribeMonitoringAgentStatusesRequest, runtime: Util.RuntimeOptions): DescribeMonitoringAgentStatusesResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitoringAgentStatuses', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitoringAgentStatuses(request: DescribeMonitoringAgentStatusesRequest): DescribeMonitoringAgentStatusesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentStatusesWithOptions(request, runtime);
}

model CreateMonitorAgentProcessRequest = {
  processName: string(name='ProcessName', description='name'),
  instanceId: string(name='InstanceId', description='instanceId'),
  processUser?: string(name='ProcessUser', description='processUser'),
}

model CreateMonitorAgentProcessResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  id: long(name='Id', description='resource'),
}

async function createMonitorAgentProcessWithOptions(request: CreateMonitorAgentProcessRequest, runtime: Util.RuntimeOptions): CreateMonitorAgentProcessResponse {
  Util.validateModel(request);
  return doRequest('CreateMonitorAgentProcess', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createMonitorAgentProcess(request: CreateMonitorAgentProcessRequest): CreateMonitorAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorAgentProcessWithOptions(request, runtime);
}

model DescribeAlertHistoryListRequest = {
  ruleId?: string(name='RuleId', description='alertName'),
  ruleName?: string(name='RuleName', description='ruleName'),
  namespace?: string(name='Namespace', description='metricProject'),
  metricName?: string(name='MetricName', description='metricName'),
  groupId?: string(name='GroupId', description='groupId'),
  status?: string(name='Status', description='status'),
  state?: string(name='State', description='state'),
  ascending?: boolean(name='Ascending', description='ascending'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  page?: integer(name='Page', description='page'),
}

model DescribeAlertHistoryListResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  total: string(name='Total', description='total'),
  requestId: string(name='RequestId', description='traceId'),
  alarmHistoryList: {
    alarmHistory: [
      {
        ruleId: string(name='RuleId', description='alertName'),
        groupId: string(name='GroupId', description='groupId'),
        namespace: string(name='Namespace', description='namespace'),
        metricName: string(name='MetricName', description='metricName'),
        dimensions: string(name='Dimensions', description='dimensions'),
        expression: string(name='Expression', description='expression'),
        evaluationCount: integer(name='EvaluationCount', description='evaluationCount'),
        value: string(name='Value', description='value'),
        alertTime: long(name='AlertTime', description='alertTime'),
        lastTime: long(name='LastTime', description='lastTime'),
        level: string(name='Level', description='level'),
        preLevel: string(name='PreLevel', description='preLevel'),
        ruleName: string(name='RuleName', description='ruleName'),
        state: string(name='State', description='state'),
        status: integer(name='Status', description='notifyStatus'),
        webhooks: string(name='Webhooks', description='webhook'),
        instanceName: string(name='InstanceName', description='instanceName'),
        contactGroups: {
          contactGroup: [ string ](name='ContactGroup', description='ContactGroup'),
        }(name='ContactGroups', description='contactGroups'),
        contacts: {
          contact: [ string ](name='Contact', description='Contact'),
        }(name='Contacts', description='contacts'),
        contactALIIMs: {
          contactALIIM: [ string ](name='ContactALIIM', description='ContactALIIM'),
        }(name='ContactALIIMs', description='contactALIIM'),
        contactSmses: {
          contactSms: [ string ](name='ContactSms', description='ContactSms'),
        }(name='ContactSmses', description='contactSms'),
        contactMails: {
          contactMail: [ string ](name='ContactMail', description='ContactMail'),
        }(name='ContactMails', description='contactMail'),
      }
    ](name='AlarmHistory', description='AlarmHistory'),
  }(name='AlarmHistoryList', description='datapoints'),
}

async function describeAlertHistoryListWithOptions(request: DescribeAlertHistoryListRequest, runtime: Util.RuntimeOptions): DescribeAlertHistoryListResponse {
  Util.validateModel(request);
  return doRequest('DescribeAlertHistoryList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeAlertHistoryList(request: DescribeAlertHistoryListRequest): DescribeAlertHistoryListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlertHistoryListWithOptions(request, runtime);
}

model DescribeAlertingMetricRuleResourcesRequest = {
  ruleId?: string(name='RuleId', description='alertName'),
  groupId?: string(name='GroupId', description='groupId'),
  page?: integer(name='Page', description='page'),
  pageSize?: integer(name='PageSize', description='pageSize'),
}

model DescribeAlertingMetricRuleResourcesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  total: integer(name='Total', description='total'),
  resources: {
    resource: [
      {
        ruleId: string(name='RuleId', description='alertName'),
        ruleName: string(name='RuleName', description='ruleName'),
        groupId: string(name='GroupId', description='groupId'),
        resource: string(name='Resource', description='dimensions'),
        enable: string(name='Enable', description='enable'),
        lastAlertTime: string(name='LastAlertTime', description='lastAlertTime'),
        lastModifyTime: string(name='LastModifyTime', description='lstModTime'),
        startTime: string(name='StartTime', description='startTime'),
        metricValues: string(name='MetricValues', description='metricValues'),
        retryTimes: string(name='RetryTimes', description='retryTimes'),
        threshold: string(name='Threshold', description='threshold'),
      }
    ](name='Resource', description='Resource'),
  }(name='Resources', description='datapoints'),
}

async function describeAlertingMetricRuleResourcesWithOptions(request: DescribeAlertingMetricRuleResourcesRequest, runtime: Util.RuntimeOptions): DescribeAlertingMetricRuleResourcesResponse {
  Util.validateModel(request);
  return doRequest('DescribeAlertingMetricRuleResources', 'HTTPS', 'GET', '2019-01-01', 'AK', request, null, runtime);
}

async function describeAlertingMetricRuleResources(request: DescribeAlertingMetricRuleResourcesRequest): DescribeAlertingMetricRuleResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlertingMetricRuleResourcesWithOptions(request, runtime);
}

model DisableActiveMetricRuleRequest = {
  product: string(name='Product', description='product'),
}

model DisableActiveMetricRuleResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
}

async function disableActiveMetricRuleWithOptions(request: DisableActiveMetricRuleRequest, runtime: Util.RuntimeOptions): DisableActiveMetricRuleResponse {
  Util.validateModel(request);
  return doRequest('DisableActiveMetricRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function disableActiveMetricRule(request: DisableActiveMetricRuleRequest): DisableActiveMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableActiveMetricRuleWithOptions(request, runtime);
}

model DescribeActiveMetricRuleListRequest = {
  product: string(name='Product', description='product'),
}

model DescribeActiveMetricRuleListResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  requestId: string(name='RequestId', description='traceId'),
  datapoints: {
    alarm: [
      {
        ruleId: string(name='RuleId', description='name'),
        namespace: string(name='Namespace', description='namespace'),
        metricName: string(name='MetricName', description='metricName'),
        period: string(name='Period', description='period'),
        statistics: string(name='Statistics', description='statistics'),
        comparisonOperator: string(name='ComparisonOperator', description='comparisonOperator'),
        threshold: string(name='Threshold', description='threshold'),
        evaluationCount: string(name='EvaluationCount', description='evaluationCount'),
        startTime: string(name='StartTime', description='startTime'),
        endTime: string(name='EndTime', description='endTime'),
        silenceTime: string(name='SilenceTime', description='silenceTime'),
        enable: string(name='Enable', description='enable'),
        state: string(name='State', description='state'),
        contactGroups: string(name='ContactGroups', description='contactGroups'),
        webhook: string(name='Webhook', description='webhook'),
        ruleName: string(name='RuleName', description='ruleName'),
      }
    ](name='Alarm', description='Alarm'),
  }(name='Datapoints', description='datapoints'),
  alertList: {
    alert: [
      {
        ruleId: string(name='RuleId', description='alertName'),
        namespace: string(name='Namespace', description='namespace'),
        metricName: string(name='MetricName', description='metricName'),
        period: string(name='Period', description='period'),
        effectiveInterval: string(name='EffectiveInterval', description='effectiveInterval'),
        noEffectiveInterval: string(name='NoEffectiveInterval', description='noEffectiveInterval'),
        silenceTime: string(name='SilenceTime', description='silenceTime'),
        enableState: boolean(name='EnableState', description='enable'),
        alertState: string(name='AlertState', description='state'),
        contactGroups: string(name='ContactGroups', description='contactGroups'),
        webhook: string(name='Webhook', description='webhook'),
        mailSubject: string(name='MailSubject', description='subject'),
        ruleName: string(name='RuleName', description='displayName'),
        resources: string(name='Resources', description='resources'),
        dimensions: string(name='Dimensions', description='dimensions'),
        escalations: {
          info: {
            comparisonOperator: string(name='ComparisonOperator', description='comparisonOperator'),
            statistics: string(name='Statistics', description='statistics'),
            threshold: string(name='Threshold', description='threshold'),
            times: string(name='Times', description='times'),
          }(name='Info', description='info'),
          warn: {
            comparisonOperator: string(name='ComparisonOperator', description='comparisonOperator'),
            statistics: string(name='Statistics', description='statistics'),
            threshold: string(name='Threshold', description='threshold'),
            times: string(name='Times', description='times'),
          }(name='Warn', description='warn'),
          critical: {
            comparisonOperator: string(name='ComparisonOperator', description='comparisonOperator'),
            statistics: string(name='Statistics', description='statistics'),
            threshold: string(name='Threshold', description='threshold'),
            times: string(name='Times', description='times'),
          }(name='Critical', description='critical'),
        }(name='Escalations', description='escalations'),
      }
    ](name='Alert', description='Alert'),
  }(name='AlertList', description='dataList'),
}

async function describeActiveMetricRuleListWithOptions(request: DescribeActiveMetricRuleListRequest, runtime: Util.RuntimeOptions): DescribeActiveMetricRuleListResponse {
  Util.validateModel(request);
  return doRequest('DescribeActiveMetricRuleList', 'HTTPS', 'GET', '2019-01-01', 'AK', request, null, runtime);
}

async function describeActiveMetricRuleList(request: DescribeActiveMetricRuleListRequest): DescribeActiveMetricRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeActiveMetricRuleListWithOptions(request, runtime);
}

model DescribeProductsOfActiveMetricRuleRequest = {
}

model DescribeProductsOfActiveMetricRuleResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
  datapoints: string(name='Datapoints', description='resource'),
  allProductInitMetricRuleList: {
    allProductInitMetricRule: [
      {
        product: string(name='Product', description='productId'),
        alertInitConfigList: {
          alertInitConfig: [
            {
              namespace: string(name='Namespace', description='namespace'),
              metricName: string(name='MetricName', description='metricName'),
              statistics: string(name='Statistics', description='statistics'),
              evaluationCount: string(name='EvaluationCount', description='evaluationCount'),
              threshold: string(name='Threshold', description='threshold'),
              period: string(name='Period', description='period'),
            }
          ](name='AlertInitConfig', description='AlertInitConfig'),
        }(name='AlertInitConfigList', description='alertConfigs'),
      }
    ](name='AllProductInitMetricRule', description='AllProductInitMetricRule'),
  }(name='AllProductInitMetricRuleList', description='dataList'),
}

async function describeProductsOfActiveMetricRuleWithOptions(request: DescribeProductsOfActiveMetricRuleRequest, runtime: Util.RuntimeOptions): DescribeProductsOfActiveMetricRuleResponse {
  Util.validateModel(request);
  return doRequest('DescribeProductsOfActiveMetricRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeProductsOfActiveMetricRule(request: DescribeProductsOfActiveMetricRuleRequest): DescribeProductsOfActiveMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeProductsOfActiveMetricRuleWithOptions(request, runtime);
}

model EnableActiveMetricRuleRequest = {
  product: string(name='Product', description='product'),
}

model EnableActiveMetricRuleResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  requestId: string(name='RequestId', description='requestId'),
}

async function enableActiveMetricRuleWithOptions(request: EnableActiveMetricRuleRequest, runtime: Util.RuntimeOptions): EnableActiveMetricRuleResponse {
  Util.validateModel(request);
  return doRequest('EnableActiveMetricRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function enableActiveMetricRule(request: EnableActiveMetricRuleRequest): EnableActiveMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableActiveMetricRuleWithOptions(request, runtime);
}

model DescribeMonitorGroupInstanceAttributeRequest = {
  groupId: long(name='GroupId', description='groupId'),
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  total?: boolean(name='Total', description='total'),
  category?: string(name='Category', description='category'),
  keyword?: string(name='Keyword', description='keyword'),
  instanceIds?: string(name='InstanceIds', description='instanceIds'),
}

model DescribeMonitorGroupInstanceAttributeResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  total: integer(name='Total', description='total'),
  resources: {
    resource: [
      {
        instanceName: string(name='InstanceName', description='instanceName'),
        instanceId: string(name='InstanceId', description='instanceId'),
        desc: string(name='Desc', description='desc'),
        networkType: string(name='NetworkType', description='networkType'),
        category: string(name='Category', description='category'),
        dimension: string(name='Dimension', description='dimension'),
        tags: {
          tag: [
            {
              key: string(name='Key', description='key'),
              value: string(name='Value', description='value'),
            }
          ](name='Tag', description='Tag'),
        }(name='Tags', description='tags'),
        region: {
          regionId: string(name='RegionId', description='regionId'),
          availabilityZone: string(name='AvailabilityZone', description='availabilityZone'),
        }(name='Region', description='region'),
        vpc: {
          vpcInstanceId: string(name='VpcInstanceId', description='vpcInstanceId'),
          vswitchInstanceId: string(name='VswitchInstanceId', description='vswitchInstanceId'),
        }(name='Vpc', description='vpc'),
      }
    ](name='Resource', description='Resource'),
  }(name='Resources', description='resources'),
}

async function describeMonitorGroupInstanceAttributeWithOptions(request: DescribeMonitorGroupInstanceAttributeRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupInstanceAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitorGroupInstanceAttribute', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitorGroupInstanceAttribute(request: DescribeMonitorGroupInstanceAttributeRequest): DescribeMonitorGroupInstanceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupInstanceAttributeWithOptions(request, runtime);
}

model DescribeMonitorGroupNotifyPolicyListRequest = {
  policyType: string(name='PolicyType', description='type'),
  pageNumber?: integer(name='PageNumber', description='page'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  groupId?: string(name='GroupId', description='groupId'),
}

model DescribeMonitorGroupNotifyPolicyListResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  success: string(name='Success', description='success'),
  requestId: string(name='RequestId', description='traceId'),
  total: integer(name='Total', description='total'),
  notifyPolicyList: {
    notifyPolicy: [
      {
        type: string(name='Type', description='type'),
        id: string(name='Id', description='id'),
        startTime: long(name='StartTime', description='startTime'),
        endTime: long(name='EndTime', description='endTime'),
        groupId: string(name='GroupId', description='groupId'),
      }
    ](name='NotifyPolicy', description='NotifyPolicy'),
  }(name='NotifyPolicyList', description='datapoints'),
}

async function describeMonitorGroupNotifyPolicyListWithOptions(request: DescribeMonitorGroupNotifyPolicyListRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupNotifyPolicyListResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitorGroupNotifyPolicyList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitorGroupNotifyPolicyList(request: DescribeMonitorGroupNotifyPolicyListRequest): DescribeMonitorGroupNotifyPolicyListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupNotifyPolicyListWithOptions(request, runtime);
}

model DeleteMonitorGroupRequest = {
  groupId: long(name='GroupId', description='id'),
}

model DeleteMonitorGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  group: {
    groupName: string(name='GroupName', description='name'),
    contactGroups: {
      contactGroup: [
        {
          name: string(name='Name', description='name'),
        }
      ](name='ContactGroup', description='ContactGroup'),
    }(name='ContactGroups', description='contactGroups'),
  }(name='Group', description='resource'),
}

async function deleteMonitorGroupWithOptions(request: DeleteMonitorGroupRequest, runtime: Util.RuntimeOptions): DeleteMonitorGroupResponse {
  Util.validateModel(request);
  return doRequest('DeleteMonitorGroup', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteMonitorGroup(request: DeleteMonitorGroupRequest): DeleteMonitorGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitorGroupWithOptions(request, runtime);
}

model CreateMonitorGroupRequest = {
  groupName: string(name='GroupName', description='name'),
  contactGroups?: string(name='ContactGroups', description='contactGroups'),
}

model CreateMonitorGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  groupId: long(name='GroupId', description='resource'),
}

async function createMonitorGroupWithOptions(request: CreateMonitorGroupRequest, runtime: Util.RuntimeOptions): CreateMonitorGroupResponse {
  Util.validateModel(request);
  return doRequest('CreateMonitorGroup', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createMonitorGroup(request: CreateMonitorGroupRequest): CreateMonitorGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorGroupWithOptions(request, runtime);
}

model DescribeMonitorGroupsRequest = {
  selectContactGroups?: boolean(name='SelectContactGroups', description='selectContactGroups'),
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  keyword?: string(name='Keyword', description='keyword'),
  instanceId?: string(name='InstanceId', description='instanceId'),
  groupName?: string(name='GroupName', description='name'),
  includeTemplateHistory?: boolean(name='IncludeTemplateHistory', description='hasTemplateHistory'),
  tag?: [
    {
      key?: string(name='Key', description='key'),
      value?: string(name='Value', description='value'),
    }
  ](name='Tag', description='tags'),
  type?: string(name='Type', description='type'),
  dynamicTagRuleId?: string(name='DynamicTagRuleId', description='tagUUID'),
  groupId?: string(name='GroupId', description='id'),
}

model DescribeMonitorGroupsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  total: integer(name='Total', description='total'),
  resources: {
    resource: [
      {
        groupId: long(name='GroupId', description='id'),
        groupName: string(name='GroupName', description='name'),
        serviceId: string(name='ServiceId', description='serviceId'),
        type: string(name='Type', description='type'),
        gmtModified: long(name='GmtModified', description='gmtModified'),
        gmtCreate: long(name='GmtCreate', description='gmtCreate'),
        bindUrl: string(name='BindUrl', description='bindUrl'),
        dynamicTagRuleId: string(name='DynamicTagRuleId', description='options.TagUUID'),
        groupFounderTagKey: string(name='GroupFounderTagKey', description='options.TagKey'),
        groupFounderTagValue: string(name='GroupFounderTagValue', description='options.TagValue'),
        contactGroups: {
          contactGroup: [
            {
              name: string(name='Name', description='name'),
            }
          ](name='ContactGroup', description='ContactGroup'),
        }(name='ContactGroups', description='contactGroups'),
        tags: {
          tag: [
            {
              key: string(name='Key', description='key'),
              value: string(name='Value', description='value'),
            }
          ](name='Tag', description='Tag'),
        }(name='Tags', description='tags'),
        templateIds: {
          templateId: [ string ](name='TemplateId', description='TemplateId'),
        }(name='TemplateIds', description='templateIds'),
      }
    ](name='Resource', description='Resource'),
  }(name='Resources', description='resources'),
}

async function describeMonitorGroupsWithOptions(request: DescribeMonitorGroupsRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupsResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitorGroups', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitorGroups(request: DescribeMonitorGroupsRequest): DescribeMonitorGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupsWithOptions(request, runtime);
}

model DeleteMonitorGroupNotifyPolicyRequest = {
  policyType: string(name='PolicyType', description='type'),
  groupId?: string(name='GroupId', description='groupId'),
}

model DeleteMonitorGroupNotifyPolicyResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  success: string(name='Success', description='success'),
  requestId: string(name='RequestId', description='traceId'),
  result: integer(name='Result', description='result'),
}

async function deleteMonitorGroupNotifyPolicyWithOptions(request: DeleteMonitorGroupNotifyPolicyRequest, runtime: Util.RuntimeOptions): DeleteMonitorGroupNotifyPolicyResponse {
  Util.validateModel(request);
  return doRequest('DeleteMonitorGroupNotifyPolicy', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteMonitorGroupNotifyPolicy(request: DeleteMonitorGroupNotifyPolicyRequest): DeleteMonitorGroupNotifyPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitorGroupNotifyPolicyWithOptions(request, runtime);
}

model DescribeMonitorGroupDynamicRulesRequest = {
  groupId: long(name='GroupId', description='groupId'),
}

model DescribeMonitorGroupDynamicRulesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  resource: {
    resource: [
      {
        groupId: long(name='GroupId', description='groupId'),
        category: string(name='Category', description='category'),
        filterRelation: string(name='FilterRelation', description='filterRelation'),
        filters: {
          filter: [
            {
              function: string(name='Function', description='function'),
              name: string(name='Name', description='name'),
              value: string(name='Value', description='value'),
            }
          ](name='Filter', description='Filter'),
        }(name='Filters', description='filters'),
      }
    ](name='Resource', description='Resource'),
  }(name='Resource', description='resource'),
}

async function describeMonitorGroupDynamicRulesWithOptions(request: DescribeMonitorGroupDynamicRulesRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupDynamicRulesResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitorGroupDynamicRules', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitorGroupDynamicRules(request: DescribeMonitorGroupDynamicRulesRequest): DescribeMonitorGroupDynamicRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupDynamicRulesWithOptions(request, runtime);
}

model CreateMonitorGroupInstancesRequest = {
  groupId: long(name='GroupId', description='groupId'),
  instances: [
    {
      category: string(name='Category', description='category'),
      instanceId: string(name='InstanceId', description='instanceId'),
      regionId: string(name='RegionId', description='regionId'),
      instanceName: string(name='InstanceName', description='instanceName'),
    }
  ](name='Instances', description='instances'),
}

model CreateMonitorGroupInstancesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
}

async function createMonitorGroupInstancesWithOptions(request: CreateMonitorGroupInstancesRequest, runtime: Util.RuntimeOptions): CreateMonitorGroupInstancesResponse {
  Util.validateModel(request);
  return doRequest('CreateMonitorGroupInstances', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createMonitorGroupInstances(request: CreateMonitorGroupInstancesRequest): CreateMonitorGroupInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorGroupInstancesWithOptions(request, runtime);
}

model CreateMonitorGroupNotifyPolicyRequest = {
  policyType: string(name='PolicyType', description='type'),
  groupId: string(name='GroupId', description='groupId'),
  startTime: long(name='StartTime', description='startTime'),
  endTime: long(name='EndTime', description='endTime'),
}

model CreateMonitorGroupNotifyPolicyResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  success: string(name='Success', description='success'),
  requestId: string(name='RequestId', description='traceId'),
  result: integer(name='Result', description='result'),
}

async function createMonitorGroupNotifyPolicyWithOptions(request: CreateMonitorGroupNotifyPolicyRequest, runtime: Util.RuntimeOptions): CreateMonitorGroupNotifyPolicyResponse {
  Util.validateModel(request);
  return doRequest('CreateMonitorGroupNotifyPolicy', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createMonitorGroupNotifyPolicy(request: CreateMonitorGroupNotifyPolicyRequest): CreateMonitorGroupNotifyPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorGroupNotifyPolicyWithOptions(request, runtime);
}

model DeleteMonitorGroupInstancesRequest = {
  groupId: long(name='GroupId', description='groupId'),
  instanceIdList: string(name='InstanceIdList', description='instanceIdList'),
  category: string(name='Category', description='category'),
}

model DeleteMonitorGroupInstancesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
}

async function deleteMonitorGroupInstancesWithOptions(request: DeleteMonitorGroupInstancesRequest, runtime: Util.RuntimeOptions): DeleteMonitorGroupInstancesResponse {
  Util.validateModel(request);
  return doRequest('DeleteMonitorGroupInstances', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteMonitorGroupInstances(request: DeleteMonitorGroupInstancesRequest): DeleteMonitorGroupInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitorGroupInstancesWithOptions(request, runtime);
}

model DeleteMonitorGroupDynamicRuleRequest = {
  groupId: long(name='GroupId', description='groupId'),
  category: string(name='Category', description='category'),
}

model DeleteMonitorGroupDynamicRuleResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
}

async function deleteMonitorGroupDynamicRuleWithOptions(request: DeleteMonitorGroupDynamicRuleRequest, runtime: Util.RuntimeOptions): DeleteMonitorGroupDynamicRuleResponse {
  Util.validateModel(request);
  return doRequest('DeleteMonitorGroupDynamicRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteMonitorGroupDynamicRule(request: DeleteMonitorGroupDynamicRuleRequest): DeleteMonitorGroupDynamicRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitorGroupDynamicRuleWithOptions(request, runtime);
}

model PutMonitorGroupDynamicRuleRequest = {
  groupId: long(name='GroupId', description='groupId'),
  groupRules: [
    {
      category: string(name='Category', description='category'),
      filterRelation: string(name='FilterRelation', description='filterRelation'),
      filters: [
        {
          name: string(name='Name', description='name'),
          function: string(name='Function', description='function'),
          value: string(name='Value', description='value'),
        }
      ](name='Filters', description='filters'),
    }
  ](name='GroupRules', description='groupRuleArrayJson'),
}

model PutMonitorGroupDynamicRuleResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
}

async function putMonitorGroupDynamicRuleWithOptions(request: PutMonitorGroupDynamicRuleRequest, runtime: Util.RuntimeOptions): PutMonitorGroupDynamicRuleResponse {
  Util.validateModel(request);
  return doRequest('PutMonitorGroupDynamicRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putMonitorGroupDynamicRule(request: PutMonitorGroupDynamicRuleRequest): PutMonitorGroupDynamicRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putMonitorGroupDynamicRuleWithOptions(request, runtime);
}

model DescribeMonitorGroupInstancesRequest = {
  pageSize?: integer(name='PageSize', description='pageSize'),
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  groupId: long(name='GroupId', description='groupId'),
  category?: string(name='Category', description='category'),
  keyword?: string(name='Keyword', description='keyword'),
  instanceIds?: string(name='InstanceIds', description='instanceIds'),
}

model DescribeMonitorGroupInstancesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  total: integer(name='Total', description='total'),
  resources: {
    resource: [
      {
        id: long(name='Id', description='id'),
        regionId: string(name='RegionId', description='regionId'),
        instanceId: string(name='InstanceId', description='instanceId'),
        category: string(name='Category', description='category'),
        instanceName: string(name='InstanceName', description='instanceName'),
      }
    ](name='Resource', description='Resource'),
  }(name='Resources', description='resources'),
}

async function describeMonitorGroupInstancesWithOptions(request: DescribeMonitorGroupInstancesRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupInstancesResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitorGroupInstances', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitorGroupInstances(request: DescribeMonitorGroupInstancesRequest): DescribeMonitorGroupInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupInstancesWithOptions(request, runtime);
}

model DescribeMonitorGroupCategoriesRequest = {
  groupId: long(name='GroupId', description='id'),
}

model DescribeMonitorGroupCategoriesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  monitorGroupCategories: {
    groupId: long(name='GroupId', description='groupId'),
    monitorGroupCategory: {
      categoryItem: [
        {
          category: string(name='Category', description='category'),
          count: integer(name='Count', description='count'),
        }
      ](name='CategoryItem', description='CategoryItem'),
    }(name='MonitorGroupCategory', description='categoryItems'),
  }(name='MonitorGroupCategories', description='resource'),
}

async function describeMonitorGroupCategoriesWithOptions(request: DescribeMonitorGroupCategoriesRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupCategoriesResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitorGroupCategories', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitorGroupCategories(request: DescribeMonitorGroupCategoriesRequest): DescribeMonitorGroupCategoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupCategoriesWithOptions(request, runtime);
}

model ModifyMonitorGroupRequest = {
  groupId: string(name='GroupId', description='id'),
  groupName?: string(name='GroupName', description='name'),
  contactGroups?: string(name='ContactGroups', description='contactGroups'),
}

model ModifyMonitorGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
}

async function modifyMonitorGroupWithOptions(request: ModifyMonitorGroupRequest, runtime: Util.RuntimeOptions): ModifyMonitorGroupResponse {
  Util.validateModel(request);
  return doRequest('ModifyMonitorGroup', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function modifyMonitorGroup(request: ModifyMonitorGroupRequest): ModifyMonitorGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMonitorGroupWithOptions(request, runtime);
}

model DescribeMetricRuleListRequest = {
  metricName?: string(name='MetricName', description='metricName'),
  enableState?: boolean(name='EnableState', description='enableState'),
  namespace?: string(name='Namespace', description='namespace'),
  page?: string(name='Page', description='page'),
  pageSize?: string(name='PageSize', description='pageSize'),
  alertState?: string(name='AlertState', description='alertState'),
  dimensions?: string(name='Dimensions', description='dimensions'),
  ruleName?: string(name='RuleName', description='displayName'),
  groupId?: string(name='GroupId', description='groupId'),
  ruleIds?: string(name='RuleIds', description='alarmNames'),
}

model DescribeMetricRuleListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
  total: string(name='Total', description='total'),
  alarms: {
    alarm: [
      {
        ruleId: string(name='RuleId', description='name'),
        namespace: string(name='Namespace', description='namespace'),
        metricName: string(name='MetricName', description='metricName'),
        period: string(name='Period', description='period'),
        effectiveInterval: string(name='EffectiveInterval', description='effectiveInterval'),
        noEffectiveInterval: string(name='NoEffectiveInterval', description='noEffectiveInterval'),
        silenceTime: string(name='SilenceTime', description='silenceTime'),
        enableState: boolean(name='EnableState', description='enable'),
        alertState: string(name='AlertState', description='state'),
        contactGroups: string(name='ContactGroups', description='contactGroups'),
        webhook: string(name='Webhook', description='webhook'),
        mailSubject: string(name='MailSubject', description='subject'),
        ruleName: string(name='RuleName', description='ruleName'),
        resources: string(name='Resources', description='resources'),
        groupId: string(name='GroupId', description='groupId'),
        groupName: string(name='GroupName', description='groupName'),
        dimensions: string(name='Dimensions', description='dimensions'),
        sourceType: string(name='SourceType', description='sourceType'),
        escalations: {
          info: {
            comparisonOperator: string(name='ComparisonOperator', description='comparisonOperator'),
            statistics: string(name='Statistics', description='statistics'),
            threshold: string(name='Threshold', description='threshold'),
            times: string(name='Times', description='times'),
          }(name='Info', description='info'),
          warn: {
            comparisonOperator: string(name='ComparisonOperator', description='comparisonOperator'),
            statistics: string(name='Statistics', description='statistics'),
            threshold: string(name='Threshold', description='threshold'),
            times: string(name='Times', description='times'),
          }(name='Warn', description='warn'),
          critical: {
            comparisonOperator: string(name='ComparisonOperator', description='comparisonOperator'),
            statistics: string(name='Statistics', description='statistics'),
            threshold: string(name='Threshold', description='threshold'),
            times: string(name='Times', description='times'),
          }(name='Critical', description='critical'),
        }(name='Escalations', description='escalations'),
      }
    ](name='Alarm', description='Alarm'),
  }(name='Alarms', description='datapoints'),
}

async function describeMetricRuleListWithOptions(request: DescribeMetricRuleListRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleListResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricRuleList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMetricRuleList(request: DescribeMetricRuleListRequest): DescribeMetricRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleListWithOptions(request, runtime);
}

model PutResourceMetricRuleRequest = {
  ruleId: string(name='RuleId', description='alertName'),
  ruleName?: string(name='RuleName', description='displayName'),
  namespace: string(name='Namespace', description='namespace'),
  metricName: string(name='MetricName', description='metricName'),
  resources: string(name='Resources', description='resources'),
  contactGroups: string(name='ContactGroups', description='contactGroups'),
  webhook?: string(name='Webhook', description='webhook'),
  effectiveInterval?: string(name='EffectiveInterval', description='effectiveInterval'),
  noEffectiveInterval?: string(name='NoEffectiveInterval', description='noEffectiveInterval'),
  silenceTime?: integer(name='SilenceTime', description='silenceTime'),
  period?: string(name='Period', description='period'),
  interval?: string(name='Interval', description='interval'),
  emailSubject?: string(name='EmailSubject', description='subject'),
  escalations: {
    critical: {
      statistics?: string(name='Statistics', description='criticalStatistics'),
      comparisonOperator?: string(name='ComparisonOperator', description='criticalComparisonOperator'),
      threshold?: string(name='Threshold', description='criticalThreshold'),
      times?: integer(name='Times', description='criticalTimes'),
    }(name='Critical', description='Critical'),
    warn: {
      statistics?: string(name='Statistics', description='warnStatistics'),
      comparisonOperator?: string(name='ComparisonOperator', description='warnComparisonOperator'),
      threshold?: string(name='Threshold', description='warnThreshold'),
      times?: integer(name='Times', description='warnTimes'),
    }(name='Warn', description='Warn'),
    info: {
      statistics?: string(name='Statistics', description='infoStatistics'),
      comparisonOperator?: string(name='ComparisonOperator', description='infoComparisonOperator'),
      threshold?: string(name='Threshold', description='infoThreshold'),
      times?: integer(name='Times', description='infoTimes'),
    }(name='Info', description='Info'),
  }(name='Escalations', description='Escalations'),
}

model PutResourceMetricRuleResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  requestId: string(name='RequestId', description='requestId'),
}

async function putResourceMetricRuleWithOptions(request: PutResourceMetricRuleRequest, runtime: Util.RuntimeOptions): PutResourceMetricRuleResponse {
  Util.validateModel(request);
  return doRequest('PutResourceMetricRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putResourceMetricRule(request: PutResourceMetricRuleRequest): PutResourceMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putResourceMetricRuleWithOptions(request, runtime);
}

model PutGroupMetricRuleRequest = {
  groupId: string(name='GroupId', description='groupId'),
  ruleId: string(name='RuleId', description='alertName'),
  category: string(name='Category', description='category'),
  ruleName?: string(name='RuleName', description='displayName'),
  namespace: string(name='Namespace', description='namespace'),
  metricName: string(name='MetricName', description='metricName'),
  dimensions?: string(name='Dimensions', description='dimensions'),
  effectiveInterval?: string(name='EffectiveInterval', description='effectiveInterval'),
  noEffectiveInterval?: string(name='NoEffectiveInterval', description='noEffectiveInterval'),
  silenceTime?: integer(name='SilenceTime', description='silenceTime'),
  period?: string(name='Period', description='period'),
  interval?: string(name='Interval', description='interval'),
  webhook?: string(name='Webhook', description='webhook'),
  emailSubject?: string(name='EmailSubject', description='subject'),
  escalations: {
    critical: {
      statistics?: string(name='Statistics', description='criticalStatistics'),
      comparisonOperator?: string(name='ComparisonOperator', description='criticalComparisonOperator'),
      threshold?: string(name='Threshold', description='criticalThreshold'),
      times?: integer(name='Times', description='criticalTimes'),
    }(name='Critical', description='Critical'),
    warn: {
      statistics?: string(name='Statistics', description='warnStatistics'),
      comparisonOperator?: string(name='ComparisonOperator', description='warnComparisonOperator'),
      threshold?: string(name='Threshold', description='warnThreshold'),
      times?: integer(name='Times', description='warnTimes'),
    }(name='Warn', description='Warn'),
    info: {
      statistics?: string(name='Statistics', description='infoStatistics'),
      comparisonOperator?: string(name='ComparisonOperator', description='infoComparisonOperator'),
      threshold?: string(name='Threshold', description='infoThreshold'),
      times?: integer(name='Times', description='infoTimes'),
    }(name='Info', description='Info'),
  }(name='Escalations', description='Escalations'),
}

model PutGroupMetricRuleResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  requestId: string(name='RequestId', description='requestId'),
}

async function putGroupMetricRuleWithOptions(request: PutGroupMetricRuleRequest, runtime: Util.RuntimeOptions): PutGroupMetricRuleResponse {
  Util.validateModel(request);
  return doRequest('PutGroupMetricRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putGroupMetricRule(request: PutGroupMetricRuleRequest): PutGroupMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putGroupMetricRuleWithOptions(request, runtime);
}

model EnableMetricRulesRequest = {
  ruleId: [ string ](name='RuleId', description='ids'),
}

model EnableMetricRulesResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
}

async function enableMetricRulesWithOptions(request: EnableMetricRulesRequest, runtime: Util.RuntimeOptions): EnableMetricRulesResponse {
  Util.validateModel(request);
  return doRequest('EnableMetricRules', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function enableMetricRules(request: EnableMetricRulesRequest): EnableMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableMetricRulesWithOptions(request, runtime);
}

model DescribeMetricRuleCountRequest = {
  namespace?: string(name='Namespace', description='namespace'),
  metricName?: string(name='MetricName', description='metricName'),
}

model DescribeMetricRuleCountResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  requestId: string(name='RequestId', description='requestId'),
  metricRuleCount: {
    alarm: integer(name='Alarm', description='alarm'),
    disable: integer(name='Disable', description='disable'),
    nodata: integer(name='Nodata', description='nodata'),
    ok: integer(name='Ok', description='ok'),
    total: integer(name='Total', description='total'),
  }(name='MetricRuleCount', description='result'),
}

async function describeMetricRuleCountWithOptions(request: DescribeMetricRuleCountRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleCountResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricRuleCount', 'HTTPS', 'GET', '2019-01-01', 'AK', request, null, runtime);
}

async function describeMetricRuleCount(request: DescribeMetricRuleCountRequest): DescribeMetricRuleCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleCountWithOptions(request, runtime);
}

model CreateGroupMetricRulesRequest = {
  groupId: long(name='GroupId', description='groupId'),
  groupMetricRules?: [
    {
      category: string(name='Category', description='category'),
      ruleName: string(name='RuleName', description='displayName'),
      ruleId: string(name='RuleId', description='alertName'),
      namespace: string(name='Namespace', description='namespace'),
      metricName: string(name='MetricName', description='metricName'),
      dimensions?: string(name='Dimensions', description='dimensions'),
      effectiveInterval?: string(name='EffectiveInterval', description='effectiveInterval'),
      noEffectiveInterval?: string(name='NoEffectiveInterval', description='noEffectiveInterval'),
      silenceTime?: integer(name='SilenceTime', description='silenceTime'),
      period?: string(name='Period', description='period'),
      interval?: string(name='Interval', description='interval'),
      webhook?: string(name='Webhook', description='webhook'),
      emailSubject?: string(name='EmailSubject', description='subject'),
      escalations: {
        critical: {
          statistics?: string(name='Statistics', description='criticalStatistics'),
          comparisonOperator?: string(name='ComparisonOperator', description='criticalComparisonOperator'),
          threshold?: string(name='Threshold', description='criticalThreshold'),
          times?: integer(name='Times', description='criticalTimes'),
        }(name='Critical', description='Critical'),
        warn: {
          statistics?: string(name='Statistics', description='warnStatistics'),
          comparisonOperator?: string(name='ComparisonOperator', description='warnComparisonOperator'),
          threshold?: string(name='Threshold', description='warnThreshold'),
          times?: integer(name='Times', description='warnTimes'),
        }(name='Warn', description='Warn'),
        info: {
          statistics?: string(name='Statistics', description='infoStatistics'),
          comparisonOperator?: string(name='ComparisonOperator', description='infoComparisonOperator'),
          threshold?: string(name='Threshold', description='infoThreshold'),
          times?: integer(name='Times', description='infoTimes'),
        }(name='Info', description='Info'),
      }(name='Escalations', description='Escalations'),
    }
  ](name='GroupMetricRules', description='groupAlertJsonArray'),
}

model CreateGroupMetricRulesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  resources: {
    alertResult: [
      {
        ruleId: string(name='RuleId', description='alertName'),
        ruleName: string(name='RuleName', description='displayName'),
        message: string(name='Message', description='message'),
        code: integer(name='Code', description='code'),
        success: boolean(name='Success', description='success'),
      }
    ](name='AlertResult', description='AlertResult'),
  }(name='Resources', description='resource'),
}

async function createGroupMetricRulesWithOptions(request: CreateGroupMetricRulesRequest, runtime: Util.RuntimeOptions): CreateGroupMetricRulesResponse {
  Util.validateModel(request);
  return doRequest('CreateGroupMetricRules', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createGroupMetricRules(request: CreateGroupMetricRulesRequest): CreateGroupMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGroupMetricRulesWithOptions(request, runtime);
}

model DisableMetricRulesRequest = {
  ruleId: [ string ](name='RuleId', description='ids'),
}

model DisableMetricRulesResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
}

async function disableMetricRulesWithOptions(request: DisableMetricRulesRequest, runtime: Util.RuntimeOptions): DisableMetricRulesResponse {
  Util.validateModel(request);
  return doRequest('DisableMetricRules', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function disableMetricRules(request: DisableMetricRulesRequest): DisableMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableMetricRulesWithOptions(request, runtime);
}

model DeleteMetricRulesRequest = {
  id: [ string ](name='Id', description='ids'),
}

model DeleteMetricRulesResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
}

async function deleteMetricRulesWithOptions(request: DeleteMetricRulesRequest, runtime: Util.RuntimeOptions): DeleteMetricRulesResponse {
  Util.validateModel(request);
  return doRequest('DeleteMetricRules', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteMetricRules(request: DeleteMetricRulesRequest): DeleteMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetricRulesWithOptions(request, runtime);
}

model ModifyMetricRuleTemplateRequest = {
  templateId: long(name='TemplateId', description='id'),
  name?: string(name='Name', description='name'),
  description?: string(name='Description', description='description'),
  restVersion: long(name='RestVersion', description='version'),
  alertTemplates?: [
    {
      metricName: string(name='MetricName', description='metricName'),
      ruleName: string(name='RuleName', description='displayName'),
      category: string(name='Category', description='category'),
      namespace: string(name='Namespace', description='namespace'),
      period: integer(name='Period', description='period'),
      selector: string(name='Selector', description='selectorJson'),
      webhook: string(name='Webhook', description='webhook'),
      escalations: {
        critical: {
          statistics: string(name='Statistics', description='criticalStatistics'),
          comparisonOperator: string(name='ComparisonOperator', description='criticalComparisonOperator'),
          threshold: string(name='Threshold', description='criticalThreshold'),
          times: integer(name='Times', description='criticalTimes'),
        }(name='Critical', description='Critical'),
        warn: {
          statistics: string(name='Statistics', description='warnStatistics'),
          comparisonOperator: string(name='ComparisonOperator', description='warnComparisonOperator'),
          threshold: string(name='Threshold', description='warnThreshold'),
          times: integer(name='Times', description='warnTimes'),
        }(name='Warn', description='Warn'),
        info: {
          statistics: string(name='Statistics', description='infoStatistics'),
          comparisonOperator: string(name='ComparisonOperator', description='infoComparisonOperator'),
          threshold: string(name='Threshold', description='infoThreshold'),
          times: integer(name='Times', description='infoTimes'),
        }(name='Info', description='Info'),
      }(name='Escalations', description='Escalations'),
    }
  ](name='AlertTemplates', description='alertTemplatesJson'),
}

model ModifyMetricRuleTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
}

async function modifyMetricRuleTemplateWithOptions(request: ModifyMetricRuleTemplateRequest, runtime: Util.RuntimeOptions): ModifyMetricRuleTemplateResponse {
  Util.validateModel(request);
  return doRequest('ModifyMetricRuleTemplate', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function modifyMetricRuleTemplate(request: ModifyMetricRuleTemplateRequest): ModifyMetricRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMetricRuleTemplateWithOptions(request, runtime);
}

model ApplyMetricRuleTemplateRequest = {
  silenceTime?: long(name='SilenceTime', description='silenceTime'),
  groupId: long(name='GroupId', description='groupId'),
  templateIds: string(name='TemplateIds', description='templateIds'),
  enableStartTime?: long(name='EnableStartTime', description='enableStartTime'),
  enableEndTime?: long(name='EnableEndTime', description='enableEndTime'),
  notifyLevel?: long(name='NotifyLevel', description='notifyLevel'),
  applyMode?: string(name='ApplyMode', description='applyMode'),
  webhook?: string(name='Webhook', description='webhook'),
}

model ApplyMetricRuleTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  resource: {
    groupId: long(name='GroupId', description='groupId'),
    alertResults: [
      {
        groupId: long(name='GroupId', description='groupId'),
        ruleId: string(name='RuleId', description='name'),
        message: string(name='Message', description='message'),
        ruleName: string(name='RuleName', description='displayName'),
        code: string(name='Code', description='code'),
        success: boolean(name='Success', description='success'),
      }
    ](name='AlertResults', description='alertResults'),
  }(name='Resource', description='resource'),
}

async function applyMetricRuleTemplateWithOptions(request: ApplyMetricRuleTemplateRequest, runtime: Util.RuntimeOptions): ApplyMetricRuleTemplateResponse {
  Util.validateModel(request);
  return doRequest('ApplyMetricRuleTemplate', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function applyMetricRuleTemplate(request: ApplyMetricRuleTemplateRequest): ApplyMetricRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyMetricRuleTemplateWithOptions(request, runtime);
}

model DescribeMetricRuleTemplateAttributeRequest = {
  name?: string(name='Name', description='name'),
  templateId?: string(name='TemplateId', description='id'),
}

model DescribeMetricRuleTemplateAttributeResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  resource: {
    name: string(name='Name', description='name'),
    templateId: string(name='TemplateId', description='id'),
    restVersion: string(name='RestVersion', description='version'),
    description: string(name='Description', description='description'),
    alertTemplates: {
      alertTemplate: [
        {
          ruleName: string(name='RuleName', description='displayName'),
          category: string(name='Category', description='category'),
          namespace: string(name='Namespace', description='namespace'),
          metricName: string(name='MetricName', description='metricName'),
          selector: string(name='Selector', description='selector'),
          webhook: string(name='Webhook', description='webhook'),
          escalations: {
            info: {
              statistics: string(name='Statistics', description='statistics'),
              comparisonOperator: string(name='ComparisonOperator', description='comparisonOperator'),
              threshold: string(name='Threshold', description='threshold'),
              times: integer(name='Times', description='times'),
            }(name='Info', description='info'),
            warn: {
              statistics: string(name='Statistics', description='statistics'),
              comparisonOperator: string(name='ComparisonOperator', description='comparisonOperator'),
              threshold: string(name='Threshold', description='threshold'),
              times: integer(name='Times', description='times'),
            }(name='Warn', description='warn'),
            critical: {
              statistics: string(name='Statistics', description='statistics'),
              comparisonOperator: string(name='ComparisonOperator', description='comparisonOperator'),
              threshold: string(name='Threshold', description='threshold'),
              times: integer(name='Times', description='times'),
            }(name='Critical', description='critical'),
          }(name='Escalations', description='escalations'),
        }
      ](name='AlertTemplate', description='AlertTemplate'),
    }(name='AlertTemplates', description='alertTemplates'),
  }(name='Resource', description='resource'),
}

async function describeMetricRuleTemplateAttributeWithOptions(request: DescribeMetricRuleTemplateAttributeRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleTemplateAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricRuleTemplateAttribute', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMetricRuleTemplateAttribute(request: DescribeMetricRuleTemplateAttributeRequest): DescribeMetricRuleTemplateAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleTemplateAttributeWithOptions(request, runtime);
}

model CreateMetricRuleTemplateRequest = {
  name: string(name='Name', description='name'),
  description?: string(name='Description', description='description'),
  alertTemplates?: [
    {
      metricName: string(name='MetricName', description='metricName'),
      ruleName: string(name='RuleName', description='displayName'),
      category: string(name='Category', description='category'),
      namespace: string(name='Namespace', description='namespace'),
      period: integer(name='Period', description='period'),
      selector: string(name='Selector', description='selectorJson'),
      webhook: string(name='Webhook', description='webhook'),
      escalations: {
        critical: {
          statistics: string(name='Statistics', description='criticalStatistics'),
          comparisonOperator: string(name='ComparisonOperator', description='criticalComparisonOperator'),
          threshold: string(name='Threshold', description='criticalThreshold'),
          times: integer(name='Times', description='criticalTimes'),
        }(name='Critical', description='Critical'),
        warn: {
          statistics: string(name='Statistics', description='warnStatistics'),
          comparisonOperator: string(name='ComparisonOperator', description='warnComparisonOperator'),
          threshold: string(name='Threshold', description='warnThreshold'),
          times: integer(name='Times', description='warnTimes'),
        }(name='Warn', description='Warn'),
        info: {
          statistics: string(name='Statistics', description='infoStatistics'),
          comparisonOperator: string(name='ComparisonOperator', description='infoComparisonOperator'),
          threshold: string(name='Threshold', description='infoThreshold'),
          times: integer(name='Times', description='infoTimes'),
        }(name='Info', description='Info'),
      }(name='Escalations', description='Escalations'),
    }
  ](name='AlertTemplates', description='alertTemplatesJson'),
}

model CreateMetricRuleTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  id: long(name='Id', description='resource'),
}

async function createMetricRuleTemplateWithOptions(request: CreateMetricRuleTemplateRequest, runtime: Util.RuntimeOptions): CreateMetricRuleTemplateResponse {
  Util.validateModel(request);
  return doRequest('CreateMetricRuleTemplate', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createMetricRuleTemplate(request: CreateMetricRuleTemplateRequest): CreateMetricRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMetricRuleTemplateWithOptions(request, runtime);
}

model DeleteMetricRuleTemplateRequest = {
  templateId: string(name='TemplateId', description='id'),
}

model DeleteMetricRuleTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  resource: {
    templateId: string(name='TemplateId', description='id'),
  }(name='Resource', description='resource'),
}

async function deleteMetricRuleTemplateWithOptions(request: DeleteMetricRuleTemplateRequest, runtime: Util.RuntimeOptions): DeleteMetricRuleTemplateResponse {
  Util.validateModel(request);
  return doRequest('DeleteMetricRuleTemplate', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteMetricRuleTemplate(request: DeleteMetricRuleTemplateRequest): DeleteMetricRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetricRuleTemplateWithOptions(request, runtime);
}

model DescribeMetricRuleTemplateListRequest = {
  name?: string(name='Name', description='name'),
  keyword?: string(name='Keyword', description='keyword'),
  templateId?: long(name='TemplateId', description='id'),
  pageNumber?: long(name='PageNumber', description='pageNumber'),
  pageSize?: long(name='PageSize', description='pageSize'),
  history?: boolean(name='History', description='history'),
}

model DescribeMetricRuleTemplateListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  total: long(name='Total', description='total'),
  templates: {
    template: [
      {
        name: string(name='Name', description='name'),
        description: string(name='Description', description='description'),
        restVersion: long(name='RestVersion', description='version'),
        templateId: long(name='TemplateId', description='id'),
        gmtCreate: long(name='GmtCreate', description='gmtCreate'),
        gmtModified: long(name='GmtModified', description='gmtModified'),
        applyHistories: {
          applyHistory: [
            {
              groupId: long(name='GroupId', description='groupId'),
              groupName: string(name='GroupName', description='groupName'),
              applyTime: long(name='ApplyTime', description='applyTime'),
            }
          ](name='ApplyHistory', description='ApplyHistory'),
        }(name='ApplyHistories', description='applyHistories'),
      }
    ](name='Template', description='Template'),
  }(name='Templates', description='resources'),
}

async function describeMetricRuleTemplateListWithOptions(request: DescribeMetricRuleTemplateListRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleTemplateListResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricRuleTemplateList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMetricRuleTemplateList(request: DescribeMetricRuleTemplateListRequest): DescribeMetricRuleTemplateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleTemplateListWithOptions(request, runtime);
}

model PutCustomEventRequest = {
  eventInfo: [
    {
      eventName: string(name='EventName', description='name'),
      content: string(name='Content', description='content'),
      time: string(name='Time', description='time'),
      groupId: string(name='GroupId', description='groupId'),
    }
  ](name='EventInfo', description='eventInfo'),
}

model PutCustomEventResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
}

async function putCustomEventWithOptions(request: PutCustomEventRequest, runtime: Util.RuntimeOptions): PutCustomEventResponse {
  Util.validateModel(request);
  return doRequest('PutCustomEvent', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putCustomEvent(request: PutCustomEventRequest): PutCustomEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return putCustomEventWithOptions(request, runtime);
}

model DescribeCustomEventCountRequest = {
  name?: string(name='Name', description='name'),
  eventId?: string(name='EventId', description='eventId'),
  groupId?: string(name='GroupId', description='groupId'),
  searchKeywords?: string(name='SearchKeywords', description='express'),
  startTime?: string(name='StartTime', description='timeStart'),
  endTime?: string(name='EndTime', description='timeEnd'),
}

model DescribeCustomEventCountResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  customEventCounts: {
    customEventCount: [
      {
        name: string(name='Name', description='name'),
        num: integer(name='Num', description='num'),
        time: long(name='Time', description='time'),
      }
    ](name='CustomEventCount', description='CustomEventCount'),
  }(name='CustomEventCounts', description='data'),
}

async function describeCustomEventCountWithOptions(request: DescribeCustomEventCountRequest, runtime: Util.RuntimeOptions): DescribeCustomEventCountResponse {
  Util.validateModel(request);
  return doRequest('DescribeCustomEventCount', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeCustomEventCount(request: DescribeCustomEventCountRequest): DescribeCustomEventCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomEventCountWithOptions(request, runtime);
}

model DescribeCustomEventAttributeRequest = {
  name?: string(name='Name', description='name'),
  eventId?: string(name='EventId', description='eventId'),
  groupId?: string(name='GroupId', description='groupId'),
  searchKeywords?: string(name='SearchKeywords', description='express'),
  startTime?: string(name='StartTime', description='timeStart'),
  endTime?: string(name='EndTime', description='timeEnd'),
  pageNumber?: integer(name='PageNumber', description='page'),
  pageSize?: integer(name='PageSize', description='size'),
}

model DescribeCustomEventAttributeResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  requestId: string(name='RequestId', description='requestId'),
  success: string(name='Success', description='success'),
  customEvents: {
    customEvent: [
      {
        id: string(name='Id', description='id'),
        content: string(name='Content', description='content'),
        groupId: string(name='GroupId', description='groupId'),
        name: string(name='Name', description='name'),
        time: string(name='Time', description='time'),
      }
    ](name='CustomEvent', description='CustomEvent'),
  }(name='CustomEvents', description='data'),
}

async function describeCustomEventAttributeWithOptions(request: DescribeCustomEventAttributeRequest, runtime: Util.RuntimeOptions): DescribeCustomEventAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeCustomEventAttribute', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeCustomEventAttribute(request: DescribeCustomEventAttributeRequest): DescribeCustomEventAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomEventAttributeWithOptions(request, runtime);
}

model DescribeCustomEventHistogramRequest = {
  name?: string(name='Name', description='name'),
  level?: string(name='Level', description='level'),
  eventId?: string(name='EventId', description='eventId'),
  groupId?: string(name='GroupId', description='groupId'),
  searchKeywords?: string(name='SearchKeywords', description='express'),
  startTime?: string(name='StartTime', description='timeStart'),
  endTime?: string(name='EndTime', description='timeEnd'),
}

model DescribeCustomEventHistogramResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  requestId: string(name='RequestId', description='requestId'),
  success: string(name='Success', description='success'),
  eventHistograms: {
    eventHistogram: [
      {
        count: long(name='Count', description='count'),
        startTime: long(name='StartTime', description='startTime'),
        endTime: long(name='EndTime', description='endTime'),
      }
    ](name='EventHistogram', description='EventHistogram'),
  }(name='EventHistograms', description='data'),
}

async function describeCustomEventHistogramWithOptions(request: DescribeCustomEventHistogramRequest, runtime: Util.RuntimeOptions): DescribeCustomEventHistogramResponse {
  Util.validateModel(request);
  return doRequest('DescribeCustomEventHistogram', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeCustomEventHistogram(request: DescribeCustomEventHistogramRequest): DescribeCustomEventHistogramResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomEventHistogramWithOptions(request, runtime);
}

model DeleteCustomMetricRequest = {
  groupId: string(name='GroupId', description='groupId'),
  metricName: string(name='MetricName', description='metricName'),
  md5?: string(name='Md5', description='md5'),
  UUID?: string(name='UUID', description='uuid'),
}

model DeleteCustomMetricResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteCustomMetricWithOptions(request: DeleteCustomMetricRequest, runtime: Util.RuntimeOptions): DeleteCustomMetricResponse {
  Util.validateModel(request);
  return doRequest('DeleteCustomMetric', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteCustomMetric(request: DeleteCustomMetricRequest): DeleteCustomMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomMetricWithOptions(request, runtime);
}

model DescribeCustomMetricListRequest = {
  groupId: string(name='GroupId', description='groupId'),
  metricName?: string(name='MetricName', description='metricName'),
  dimension?: string(name='Dimension', description='dimension'),
  md5?: string(name='Md5', description='md5'),
  pageNumber?: string(name='PageNumber', description='page'),
  pageSize?: string(name='PageSize', description='size'),
}

model DescribeCustomMetricListResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  requestId: string(name='RequestId', description='requestId'),
  result: string(name='Result', description='data'),
}

async function describeCustomMetricListWithOptions(request: DescribeCustomMetricListRequest, runtime: Util.RuntimeOptions): DescribeCustomMetricListResponse {
  Util.validateModel(request);
  return doRequest('DescribeCustomMetricList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeCustomMetricList(request: DescribeCustomMetricListRequest): DescribeCustomMetricListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomMetricListWithOptions(request, runtime);
}

model PutCustomMetricRequest = {
  metricList: [
    {
      groupId: string(name='GroupId', description='groupId'),
      metricName: string(name='MetricName', description='metricName'),
      dimensions: string(name='Dimensions', description='dimensions'),
      time?: string(name='Time', description='time'),
      type?: string(name='Type', description='type'),
      period?: string(name='Period', description='period'),
      values: string(name='Values', description='values'),
    }
  ](name='MetricList', description='metricList'),
}

model PutCustomMetricResponse = {
  requestId: string(name='RequestId', description='requestId'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
}

async function putCustomMetricWithOptions(request: PutCustomMetricRequest, runtime: Util.RuntimeOptions): PutCustomMetricResponse {
  Util.validateModel(request);
  return doRequest('PutCustomMetric', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putCustomMetric(request: PutCustomMetricRequest): PutCustomMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return putCustomMetricWithOptions(request, runtime);
}

model DescribeEventRuleAttributeRequest = {
  ruleName: string(name='RuleName', description='ruleName'),
}

model DescribeEventRuleAttributeResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
  result: {
    description: string(name='Description', description='description'),
    name: string(name='Name', description='name'),
    eventType: string(name='EventType', description='eventType'),
    groupId: string(name='GroupId', description='groupId'),
    state: string(name='State', description='state'),
    eventPattern: {
      product: string(name='Product', description='product'),
      nameList: {
        nameList: [ string ](name='NameList', description='NameList'),
      }(name='NameList', description='nameList'),
      statusList: {
        statusList: [ string ](name='StatusList', description='StatusList'),
      }(name='StatusList', description='statusList'),
      levelList: {
        levelList: [ string ](name='LevelList', description='LevelList'),
      }(name='LevelList', description='levelList'),
    }(name='EventPattern', description='eventPattern'),
  }(name='Result', description='result'),
}

async function describeEventRuleAttributeWithOptions(request: DescribeEventRuleAttributeRequest, runtime: Util.RuntimeOptions): DescribeEventRuleAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeEventRuleAttribute', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeEventRuleAttribute(request: DescribeEventRuleAttributeRequest): DescribeEventRuleAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEventRuleAttributeWithOptions(request, runtime);
}

model DeleteContactGroupRequest = {
  contactGroupName: string(name='ContactGroupName', description='contactGroupName'),
}

model DeleteContactGroupResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
}

async function deleteContactGroupWithOptions(request: DeleteContactGroupRequest, runtime: Util.RuntimeOptions): DeleteContactGroupResponse {
  Util.validateModel(request);
  return doRequest('DeleteContactGroup', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteContactGroup(request: DeleteContactGroupRequest): DeleteContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContactGroupWithOptions(request, runtime);
}

model DescribeContactListRequest = {
  pageSize?: integer(name='PageSize', description='pageSize'),
  pageNumber?: integer(name='PageNumber', description='page'),
  contactName?: string(name='ContactName', description='contactName'),
  chanelType?: string(name='ChanelType', description='chanelType'),
  chanelValue?: string(name='ChanelValue', description='chanelValue'),
}

model DescribeContactListResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  total: integer(name='Total', description='total'),
  requestId: string(name='RequestId', description='traceId'),
  contacts: {
    contact: [
      {
        name: string(name='Name', description='name'),
        desc: string(name='Desc', description='desc'),
        createTime: long(name='CreateTime', description='createTime'),
        updateTime: long(name='UpdateTime', description='updateTime'),
        channels: {
          SMS: string(name='SMS', description='SMS'),
          mail: string(name='Mail', description='Mail'),
          aliIM: string(name='AliIM', description='ALIIM'),
          dingWebHook: string(name='DingWebHook', description='DingWebHook'),
        }(name='Channels', description='channels'),
        channelsState: {
          SMS: string(name='SMS', description='SMS'),
          mail: string(name='Mail', description='Mail'),
          aliIM: string(name='AliIM', description='ALIIM'),
          dingWebHook: string(name='DingWebHook', description='DingWebHook'),
        }(name='ChannelsState', description='channelsState'),
        contactGroups: {
          contactGroup: [ string ](name='ContactGroup', description='ContactGroup'),
        }(name='ContactGroups', description='contactGroup'),
      }
    ](name='Contact', description='Contact'),
  }(name='Contacts', description='datapoints'),
}

async function describeContactListWithOptions(request: DescribeContactListRequest, runtime: Util.RuntimeOptions): DescribeContactListResponse {
  Util.validateModel(request);
  return doRequest('DescribeContactList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeContactList(request: DescribeContactListRequest): DescribeContactListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContactListWithOptions(request, runtime);
}

model DescribeContactListByContactGroupRequest = {
  contactGroupName: string(name='ContactGroupName', description='contactGroup'),
}

model DescribeContactListByContactGroupResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
  contacts: {
    contact: [
      {
        name: string(name='Name', description='name'),
        desc: string(name='Desc', description='desc'),
        createTime: long(name='CreateTime', description='createTime'),
        updateTime: long(name='UpdateTime', description='updateTime'),
        channels: {
          SMS: string(name='SMS', description='SMS'),
          mail: string(name='Mail', description='Mail'),
          aliIM: string(name='AliIM', description='ALIIM'),
          dingWebHook: string(name='DingWebHook', description='DingWebHook'),
        }(name='Channels', description='channels'),
      }
    ](name='Contact', description='Contact'),
  }(name='Contacts', description='datapoints'),
}

async function describeContactListByContactGroupWithOptions(request: DescribeContactListByContactGroupRequest, runtime: Util.RuntimeOptions): DescribeContactListByContactGroupResponse {
  Util.validateModel(request);
  return doRequest('DescribeContactListByContactGroup', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeContactListByContactGroup(request: DescribeContactListByContactGroupRequest): DescribeContactListByContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContactListByContactGroupWithOptions(request, runtime);
}

model DeleteContactRequest = {
  contactName: string(name='ContactName', description='contactName'),
}

model DeleteContactResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
}

async function deleteContactWithOptions(request: DeleteContactRequest, runtime: Util.RuntimeOptions): DeleteContactResponse {
  Util.validateModel(request);
  return doRequest('DeleteContact', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteContact(request: DeleteContactRequest): DeleteContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContactWithOptions(request, runtime);
}

model PutContactGroupRequest = {
  contactGroupName: string(name='ContactGroupName', description='name'),
  describe?: string(name='Describe', description='desc'),
  contactNames: [ string ](name='ContactNames', description='contactNames'),
}

model PutContactGroupResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
}

async function putContactGroupWithOptions(request: PutContactGroupRequest, runtime: Util.RuntimeOptions): PutContactGroupResponse {
  Util.validateModel(request);
  return doRequest('PutContactGroup', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putContactGroup(request: PutContactGroupRequest): PutContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return putContactGroupWithOptions(request, runtime);
}

model PutContactRequest = {
  contactName: string(name='ContactName', description='name'),
  describe: string(name='Describe', description='desc'),
  channels: {
    SMS?: string(name='SMS', description='sms'),
    mail?: string(name='Mail', description='mail'),
    aliIM?: string(name='AliIM', description='aliim'),
    dingWebHook?: string(name='DingWebHook', description='dingwebhook'),
  }(name='Channels', description='Channels'),
}

model PutContactResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
}

async function putContactWithOptions(request: PutContactRequest, runtime: Util.RuntimeOptions): PutContactResponse {
  Util.validateModel(request);
  return doRequest('PutContact', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putContact(request: PutContactRequest): PutContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return putContactWithOptions(request, runtime);
}

model DescribeContactGroupListRequest = {
  pageSize?: integer(name='PageSize', description='size'),
  pageNumber?: integer(name='PageNumber', description='page'),
}

model DescribeContactGroupListResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  total: integer(name='Total', description='total'),
  requestId: string(name='RequestId', description='traceId'),
  contactGroupList: {
    contactGroup: [
      {
        name: string(name='Name', description='name'),
        describe: string(name='Describe', description='desc'),
        createTime: long(name='CreateTime', description='gmtCreate'),
        updateTime: long(name='UpdateTime', description='gmtUpdate'),
        enabledWeeklyReport: boolean(name='EnabledWeeklyReport', description='wrEnabled'),
        enableSubscribed: boolean(name='EnableSubscribed', description='wrSubscribed'),
        contacts: {
          contact: [ string ](name='Contact', description='Contact'),
        }(name='Contacts', description='contacts'),
      }
    ](name='ContactGroup', description='ContactGroup'),
  }(name='ContactGroupList', description='dataList'),
  contactGroups: {
    contactGroup: [ string ](name='ContactGroup', description='ContactGroup'),
  }(name='ContactGroups', description='datapoints'),
}

async function describeContactGroupListWithOptions(request: DescribeContactGroupListRequest, runtime: Util.RuntimeOptions): DescribeContactGroupListResponse {
  Util.validateModel(request);
  return doRequest('DescribeContactGroupList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeContactGroupList(request: DescribeContactGroupListRequest): DescribeContactGroupListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContactGroupListWithOptions(request, runtime);
}

model PutEventRuleTargetsRequest = {
  ruleName: string(name='RuleName', description='ruleName'),
  fcParameters?: [
    {
      id?: string(name='Id', description='id'),
      region?: string(name='Region', description='region'),
      serviceName?: string(name='ServiceName', description='serviceName'),
      functionName?: string(name='FunctionName', description='functionName'),
    }
  ](name='FcParameters', description='fcParameterList'),
  contactParameters?: [
    {
      id?: string(name='Id', description='id'),
      contactGroupName?: string(name='ContactGroupName', description='contactGroupName'),
      level?: string(name='Level', description='level'),
    }
  ](name='ContactParameters', description='contactParameterList'),
  mnsParameters?: [
    {
      id?: string(name='Id', description='id'),
      region?: string(name='Region', description='region'),
      queue?: string(name='Queue', description='queue'),
    }
  ](name='MnsParameters', description='mnsParameterList'),
  webhookParameters?: [
    {
      id?: string(name='Id', description='id'),
      protocol?: string(name='Protocol', description='protocol'),
      url?: string(name='Url', description='url'),
      method?: string(name='Method', description='method'),
    }
  ](name='WebhookParameters', description='webhookParameterList'),
  slsParameters?: [
    {
      id?: string(name='Id', description='id'),
      region?: string(name='Region', description='region'),
      project?: string(name='Project', description='project'),
      logStore?: string(name='LogStore', description='logstore'),
    }
  ](name='SlsParameters', description='slsParameterList'),
}

model PutEventRuleTargetsResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
  failedParameterCount: string(name='FailedParameterCount', description='failedParameterCount'),
  failedContactParameters: {
    contactParameter: [
      {
        id: integer(name='Id', description='id'),
        contactGroupName: string(name='ContactGroupName', description='contactGroupName'),
        level: string(name='Level', description='level'),
      }
    ](name='ContactParameter', description='ContactParameter'),
  }(name='FailedContactParameters', description='failedContactParameters'),
  failedMnsParameters: {
    mnsParameter: [
      {
        id: integer(name='Id', description='id'),
        region: string(name='Region', description='region'),
        queue: string(name='Queue', description='name'),
      }
    ](name='MnsParameter', description='MnsParameter'),
  }(name='FailedMnsParameters', description='failedMnsParameters'),
  failedFcParameters: {
    fcParameter: [
      {
        id: integer(name='Id', description='id'),
        region: string(name='Region', description='region'),
        serviceName: string(name='ServiceName', description='serviceName'),
        functionName: string(name='FunctionName', description='functionName'),
      }
    ](name='FcParameter', description='FcParameter'),
  }(name='FailedFcParameters', description='failedFcParameters'),
}

async function putEventRuleTargetsWithOptions(request: PutEventRuleTargetsRequest, runtime: Util.RuntimeOptions): PutEventRuleTargetsResponse {
  Util.validateModel(request);
  return doRequest('PutEventRuleTargets', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putEventRuleTargets(request: PutEventRuleTargetsRequest): PutEventRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return putEventRuleTargetsWithOptions(request, runtime);
}

model DeleteEventRuleTargetsRequest = {
  ruleName: string(name='RuleName', description='ruleName'),
  ids: [ string ](name='Ids', description='ids'),
}

model DeleteEventRuleTargetsResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
}

async function deleteEventRuleTargetsWithOptions(request: DeleteEventRuleTargetsRequest, runtime: Util.RuntimeOptions): DeleteEventRuleTargetsResponse {
  Util.validateModel(request);
  return doRequest('DeleteEventRuleTargets', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteEventRuleTargets(request: DeleteEventRuleTargetsRequest): DeleteEventRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventRuleTargetsWithOptions(request, runtime);
}

model DisableEventRulesRequest = {
  ruleNames: [ string ](name='RuleNames', description='ruleNames'),
}

model DisableEventRulesResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
}

async function disableEventRulesWithOptions(request: DisableEventRulesRequest, runtime: Util.RuntimeOptions): DisableEventRulesResponse {
  Util.validateModel(request);
  return doRequest('DisableEventRules', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function disableEventRules(request: DisableEventRulesRequest): DisableEventRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableEventRulesWithOptions(request, runtime);
}

model DescribeEventRuleTargetListRequest = {
  ruleName: string(name='RuleName', description='ruleName'),
}

model DescribeEventRuleTargetListResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
  contactParameters: {
    contactParameter: [
      {
        contactGroupName: string(name='ContactGroupName', description='contactGroupName'),
        level: string(name='Level', description='level'),
        id: string(name='Id', description='id'),
      }
    ](name='ContactParameter', description='ContactParameter'),
  }(name='ContactParameters', description='contactParameters'),
  fcParameters: {
    FCParameter: [
      {
        region: string(name='Region', description='region'),
        serviceName: string(name='ServiceName', description='serviceName'),
        functionName: string(name='FunctionName', description='functionName'),
        id: string(name='Id', description='id'),
        arn: string(name='Arn', description='arn'),
      }
    ](name='FCParameter', description='FCParameter'),
  }(name='FcParameters', description='fcParameters'),
  mnsParameters: {
    mnsParameter: [
      {
        region: string(name='Region', description='region'),
        queue: string(name='Queue', description='queue'),
        id: string(name='Id', description='id'),
        arn: string(name='Arn', description='arn'),
      }
    ](name='MnsParameter', description='MnsParameter'),
  }(name='MnsParameters', description='mnsParameters'),
  webhookParameters: {
    webhookParameter: [
      {
        id: string(name='Id', description='id'),
        protocol: string(name='Protocol', description='protocol'),
        method: string(name='Method', description='method'),
        url: string(name='Url', description='url'),
      }
    ](name='WebhookParameter', description='WebhookParameter'),
  }(name='WebhookParameters', description='webhookParameters'),
  slsParameters: {
    slsParameter: [
      {
        id: string(name='Id', description='id'),
        region: string(name='Region', description='region'),
        project: string(name='Project', description='project'),
        logStore: string(name='LogStore', description='logstore'),
        arn: string(name='Arn', description='arn'),
      }
    ](name='SlsParameter', description='SlsParameter'),
  }(name='SlsParameters', description='slsParameters'),
}

async function describeEventRuleTargetListWithOptions(request: DescribeEventRuleTargetListRequest, runtime: Util.RuntimeOptions): DescribeEventRuleTargetListResponse {
  Util.validateModel(request);
  return doRequest('DescribeEventRuleTargetList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeEventRuleTargetList(request: DescribeEventRuleTargetListRequest): DescribeEventRuleTargetListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEventRuleTargetListWithOptions(request, runtime);
}

model DeleteEventRulesRequest = {
  ruleNames: [ string ](name='RuleNames', description='ruleNames'),
}

model DeleteEventRulesResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
}

async function deleteEventRulesWithOptions(request: DeleteEventRulesRequest, runtime: Util.RuntimeOptions): DeleteEventRulesResponse {
  Util.validateModel(request);
  return doRequest('DeleteEventRules', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteEventRules(request: DeleteEventRulesRequest): DeleteEventRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventRulesWithOptions(request, runtime);
}

model EnableEventRulesRequest = {
  ruleNames: [ string ](name='RuleNames', description='ruleNames'),
}

model EnableEventRulesResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
}

async function enableEventRulesWithOptions(request: EnableEventRulesRequest, runtime: Util.RuntimeOptions): EnableEventRulesResponse {
  Util.validateModel(request);
  return doRequest('EnableEventRules', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function enableEventRules(request: EnableEventRulesRequest): EnableEventRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableEventRulesWithOptions(request, runtime);
}

model PutEventRuleRequest = {
  ruleName: string(name='RuleName', description='name'),
  groupId?: string(name='GroupId', description='groupId'),
  eventType?: string(name='EventType', description='eventType'),
  description?: string(name='Description', description='description'),
  state?: string(name='State', description='state'),
  eventPattern: [
    {
      product: string(name='Product', description='product'),
      nameList: [ string ](name='NameList', description='nameList'),
      statusList: [ string ](name='StatusList', description='statusList'),
      levelList: [ string ](name='LevelList', description='levelList'),
      eventTypeList: [ string ](name='EventTypeList', description='eventType'),
    }
  ](name='EventPattern', description='eventPatterns'),
}

model PutEventRuleResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
  data: string(name='Data', description='data'),
}

async function putEventRuleWithOptions(request: PutEventRuleRequest, runtime: Util.RuntimeOptions): PutEventRuleResponse {
  Util.validateModel(request);
  return doRequest('PutEventRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putEventRule(request: PutEventRuleRequest): PutEventRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putEventRuleWithOptions(request, runtime);
}

model DescribeEventRuleListRequest = {
  namePrefix?: string(name='NamePrefix', description='namePrefix'),
  pageNumber?: string(name='PageNumber', description='page'),
  pageSize?: string(name='PageSize', description='pageSize'),
  groupId?: string(name='GroupId', description='groupId'),
}

model DescribeEventRuleListResponse = {
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
  total: integer(name='Total', description='total'),
  eventRules: {
    eventRule: [
      {
        name: string(name='Name', description='name'),
        groupId: string(name='GroupId', description='groupId'),
        eventType: string(name='EventType', description='eventType'),
        state: string(name='State', description='state'),
        description: string(name='Description', description='description'),
        eventPattern: {
          eventPattern: [
            {
              product: string(name='Product', description='product'),
              nameList: {
                nameList: [ string ](name='NameList', description='NameList'),
              }(name='NameList', description='nameList'),
              levelList: {
                levelList: [ string ](name='LevelList', description='LevelList'),
              }(name='LevelList', description='levelList'),
              eventTypeList: {
                eventTypeList: [ string ](name='EventTypeList', description='EventTypeList'),
              }(name='EventTypeList', description='eventType'),
            }
          ](name='EventPattern', description='EventPattern'),
        }(name='EventPattern', description='eventPattern'),
      }
    ](name='EventRule', description='EventRule'),
  }(name='EventRules', description='datapoints'),
}

async function describeEventRuleListWithOptions(request: DescribeEventRuleListRequest, runtime: Util.RuntimeOptions): DescribeEventRuleListResponse {
  Util.validateModel(request);
  return doRequest('DescribeEventRuleList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeEventRuleList(request: DescribeEventRuleListRequest): DescribeEventRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEventRuleListWithOptions(request, runtime);
}

model DescribeSystemEventAttributeRequest = {
  product?: string(name='Product', description='product'),
  eventType?: string(name='EventType', description='eventType'),
  name?: string(name='Name', description='name'),
  level?: string(name='Level', description='level'),
  status?: string(name='Status', description='status'),
  groupId?: string(name='GroupId', description='groupId'),
  searchKeywords?: string(name='SearchKeywords', description='express'),
  startTime?: string(name='StartTime', description='timeStart'),
  endTime?: string(name='EndTime', description='timeEnd'),
  pageNumber?: integer(name='PageNumber', description='page'),
  pageSize?: integer(name='PageSize', description='size'),
}

model DescribeSystemEventAttributeResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  requestId: string(name='RequestId', description='requestId'),
  success: string(name='Success', description='success'),
  systemEvents: {
    systemEvent: [
      {
        content: string(name='Content', description='content'),
        product: string(name='Product', description='product'),
        name: string(name='Name', description='name'),
        groupId: string(name='GroupId', description='groupId'),
        level: string(name='Level', description='level'),
        status: string(name='Status', description='status'),
        resourceId: string(name='ResourceId', description='resourceId'),
        regionId: string(name='RegionId', description='regionId'),
        instanceName: string(name='InstanceName', description='instanceName'),
        time: long(name='Time', description='time'),
      }
    ](name='SystemEvent', description='SystemEvent'),
  }(name='SystemEvents', description='data'),
}

async function describeSystemEventAttributeWithOptions(request: DescribeSystemEventAttributeRequest, runtime: Util.RuntimeOptions): DescribeSystemEventAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeSystemEventAttribute', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSystemEventAttribute(request: DescribeSystemEventAttributeRequest): DescribeSystemEventAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSystemEventAttributeWithOptions(request, runtime);
}

model DescribeSystemEventHistogramRequest = {
  product?: string(name='Product', description='product'),
  eventType?: string(name='EventType', description='eventType'),
  name?: string(name='Name', description='name'),
  level?: string(name='Level', description='level'),
  status?: string(name='Status', description='status'),
  groupId?: string(name='GroupId', description='groupId'),
  searchKeywords?: string(name='SearchKeywords', description='express'),
  startTime?: string(name='StartTime', description='timeStart'),
  endTime?: string(name='EndTime', description='timeEnd'),
}

model DescribeSystemEventHistogramResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  requestId: string(name='RequestId', description='requestId'),
  success: string(name='Success', description='success'),
  systemEventHistograms: {
    systemEventHistogram: [
      {
        count: long(name='Count', description='count'),
        startTime: long(name='StartTime', description='startTime'),
        endTime: long(name='EndTime', description='endTime'),
      }
    ](name='SystemEventHistogram', description='SystemEventHistogram'),
  }(name='SystemEventHistograms', description='data'),
}

async function describeSystemEventHistogramWithOptions(request: DescribeSystemEventHistogramRequest, runtime: Util.RuntimeOptions): DescribeSystemEventHistogramResponse {
  Util.validateModel(request);
  return doRequest('DescribeSystemEventHistogram', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSystemEventHistogram(request: DescribeSystemEventHistogramRequest): DescribeSystemEventHistogramResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSystemEventHistogramWithOptions(request, runtime);
}

model DescribeSystemEventCountRequest = {
  product?: string(name='Product', description='product'),
  eventType?: string(name='EventType', description='eventType'),
  name?: string(name='Name', description='name'),
  level?: string(name='Level', description='level'),
  status?: string(name='Status', description='status'),
  groupId?: string(name='GroupId', description='groupId'),
  searchKeywords?: string(name='SearchKeywords', description='express'),
  startTime?: string(name='StartTime', description='timeStart'),
  endTime?: string(name='EndTime', description='timeEnd'),
}

model DescribeSystemEventCountResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  requestId: string(name='RequestId', description='requestId'),
  success: string(name='Success', description='success'),
  systemEventCounts: {
    systemEventCount: [
      {
        content: string(name='Content', description='content'),
        product: string(name='Product', description='product'),
        name: string(name='Name', description='name'),
        groupId: string(name='GroupId', description='groupId'),
        num: long(name='Num', description='num'),
        level: string(name='Level', description='level'),
        status: string(name='Status', description='status'),
        resourceId: string(name='ResourceId', description='resourceId'),
        regionId: string(name='RegionId', description='regionId'),
        instanceName: string(name='InstanceName', description='instanceName'),
        time: long(name='Time', description='time'),
      }
    ](name='SystemEventCount', description='SystemEventCount'),
  }(name='SystemEventCounts', description='data'),
}

async function describeSystemEventCountWithOptions(request: DescribeSystemEventCountRequest, runtime: Util.RuntimeOptions): DescribeSystemEventCountResponse {
  Util.validateModel(request);
  return doRequest('DescribeSystemEventCount', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSystemEventCount(request: DescribeSystemEventCountRequest): DescribeSystemEventCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSystemEventCountWithOptions(request, runtime);
}

model DescribeSystemEventMetaListRequest = {
}

model DescribeSystemEventMetaListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
  data: {
    resource: [
      {
        product: string(name='Product', description='product'),
        name: string(name='Name', description='name'),
        nameDesc: string(name='NameDesc', description='nameDesc'),
        level: string(name='Level', description='level'),
        status: string(name='Status', description='status'),
        statusDesc: string(name='StatusDesc', description='statusDesc'),
        eventType: string(name='EventType', description='eventType'),
      }
    ](name='Resource', description='Resource'),
  }(name='Data', description='data'),
}

async function describeSystemEventMetaListWithOptions(request: DescribeSystemEventMetaListRequest, runtime: Util.RuntimeOptions): DescribeSystemEventMetaListResponse {
  Util.validateModel(request);
  return doRequest('DescribeSystemEventMetaList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSystemEventMetaList(request: DescribeSystemEventMetaListRequest): DescribeSystemEventMetaListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSystemEventMetaListWithOptions(request, runtime);
}

model DescribeMonitoringAgentProcessesRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
}

model DescribeMonitoringAgentProcessesResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  nodeProcesses: {
    nodeProcess: [
      {
        processId: long(name='ProcessId', description='id'),
        instanceId: string(name='InstanceId', description='instanceId'),
        processName: string(name='ProcessName', description='name'),
        processUser: string(name='ProcessUser', description='processUser'),
        command: string(name='Command', description='command'),
        groupId: string(name='GroupId', description='groupId'),
      }
    ](name='NodeProcess', description='NodeProcess'),
  }(name='NodeProcesses', description='nodeProcesses'),
}

async function describeMonitoringAgentProcessesWithOptions(request: DescribeMonitoringAgentProcessesRequest, runtime: Util.RuntimeOptions): DescribeMonitoringAgentProcessesResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitoringAgentProcesses', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitoringAgentProcesses(request: DescribeMonitoringAgentProcessesRequest): DescribeMonitoringAgentProcessesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentProcessesWithOptions(request, runtime);
}

model UninstallMonitoringAgentRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
}

model UninstallMonitoringAgentResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
}

async function uninstallMonitoringAgentWithOptions(request: UninstallMonitoringAgentRequest, runtime: Util.RuntimeOptions): UninstallMonitoringAgentResponse {
  Util.validateModel(request);
  return doRequest('UninstallMonitoringAgent', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function uninstallMonitoringAgent(request: UninstallMonitoringAgentRequest): UninstallMonitoringAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallMonitoringAgentWithOptions(request, runtime);
}

model DescribeMonitoringAgentAccessKeyRequest = {
}

model DescribeMonitoringAgentAccessKeyResponse = {
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  accessKey: string(name='AccessKey', description='accessKey'),
  secretKey: string(name='SecretKey', description='secretKey'),
}

async function describeMonitoringAgentAccessKeyWithOptions(request: DescribeMonitoringAgentAccessKeyRequest, runtime: Util.RuntimeOptions): DescribeMonitoringAgentAccessKeyResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitoringAgentAccessKey', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitoringAgentAccessKey(request: DescribeMonitoringAgentAccessKeyRequest): DescribeMonitoringAgentAccessKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentAccessKeyWithOptions(request, runtime);
}

model InstallMonitoringAgentRequest = {
  force?: boolean(name='Force', description='force'),
  instanceIds: [ string ](name='InstanceIds', description='instanceList'),
}

model InstallMonitoringAgentResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
}

async function installMonitoringAgentWithOptions(request: InstallMonitoringAgentRequest, runtime: Util.RuntimeOptions): InstallMonitoringAgentResponse {
  Util.validateModel(request);
  return doRequest('InstallMonitoringAgent', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function installMonitoringAgent(request: InstallMonitoringAgentRequest): InstallMonitoringAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  return installMonitoringAgentWithOptions(request, runtime);
}

model SendDryRunSystemEventRequest = {
  product: string(name='Product', description='product'),
  eventName: string(name='EventName', description='eventName'),
  groupId?: string(name='GroupId', description='groupId'),
  eventContent?: string(name='EventContent', description='eventContent'),
}

model SendDryRunSystemEventResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  requestId: string(name='RequestId', description='requestId'),
  success: string(name='Success', description='success'),
}

async function sendDryRunSystemEventWithOptions(request: SendDryRunSystemEventRequest, runtime: Util.RuntimeOptions): SendDryRunSystemEventResponse {
  Util.validateModel(request);
  return doRequest('SendDryRunSystemEvent', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function sendDryRunSystemEvent(request: SendDryRunSystemEventRequest): SendDryRunSystemEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendDryRunSystemEventWithOptions(request, runtime);
}

model CreateMonitoringAgentProcessRequest = {
  processName?: string(name='ProcessName', description='name'),
  instanceId: string(name='InstanceId', description='instanceId'),
  processUser?: string(name='ProcessUser', description='processUser'),
}

model CreateMonitoringAgentProcessResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  id: long(name='Id', description='resource'),
}

async function createMonitoringAgentProcessWithOptions(request: CreateMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): CreateMonitoringAgentProcessResponse {
  Util.validateModel(request);
  return doRequest('CreateMonitoringAgentProcess', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createMonitoringAgentProcess(request: CreateMonitoringAgentProcessRequest): CreateMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitoringAgentProcessWithOptions(request, runtime);
}

model DescribeMonitoringAgentConfigRequest = {
}

model DescribeMonitoringAgentConfigResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  autoInstall: boolean(name='AutoInstall', description='autoInstall'),
  enableInstallAgentNewECS: boolean(name='EnableInstallAgentNewECS', description='enableInstallAgentNewECS'),
  enableActiveAlert: string(name='EnableActiveAlert', description='enableActiveAlert'),
}

async function describeMonitoringAgentConfigWithOptions(request: DescribeMonitoringAgentConfigRequest, runtime: Util.RuntimeOptions): DescribeMonitoringAgentConfigResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitoringAgentConfig', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitoringAgentConfig(request: DescribeMonitoringAgentConfigRequest): DescribeMonitoringAgentConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentConfigWithOptions(request, runtime);
}

model DeleteMonitoringAgentProcessRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
  processName?: string(name='ProcessName', description='name'),
  processId?: string(name='ProcessId', description='id'),
}

model DeleteMonitoringAgentProcessResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteMonitoringAgentProcessWithOptions(request: DeleteMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): DeleteMonitoringAgentProcessResponse {
  Util.validateModel(request);
  return doRequest('DeleteMonitoringAgentProcess', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteMonitoringAgentProcess(request: DeleteMonitoringAgentProcessRequest): DeleteMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitoringAgentProcessWithOptions(request, runtime);
}

model DescribeMonitoringAgentHostsRequest = {
  keyWord?: string(name='KeyWord', description='keyWord'),
  hostName?: string(name='HostName', description='hostName'),
  instanceIds?: string(name='InstanceIds', description='instanceIds'),
  serialNumbers?: string(name='SerialNumbers', description='serialNumbers'),
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  instanceRegionId?: string(name='InstanceRegionId', description='instanceRegionId'),
}

model DescribeMonitoringAgentHostsResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  pageTotal: integer(name='PageTotal', description='pageTotal'),
  total: integer(name='Total', description='total'),
  hosts: {
    host: [
      {
        instanceId: string(name='InstanceId', description='instanceId'),
        serialNumber: string(name='SerialNumber', description='serialNumber'),
        hostName: string(name='HostName', description='hostName'),
        aliUid: long(name='AliUid', description='aliUid'),
        operatingSystem: string(name='OperatingSystem', description='operatingSystem'),
        ipGroup: string(name='IpGroup', description='ipGroup'),
        region: string(name='Region', description='region'),
        agentVersion: string(name='AgentVersion', description='tianjimonVersion'),
        eipAddress: string(name='EipAddress', description='eipAddress'),
        eipId: string(name='EipId', description='eipId'),
        isAliyunHost: boolean(name='isAliyunHost', description='aliyunHost'),
        natIp: string(name='NatIp', description='natIp'),
        networkType: string(name='NetworkType', description='networkType'),
        instanceTypeFamily: string(name='InstanceTypeFamily', description='instanceTypeFamily'),
      }
    ](name='Host', description='Host'),
  }(name='Hosts', description='nodes'),
}

async function describeMonitoringAgentHostsWithOptions(request: DescribeMonitoringAgentHostsRequest, runtime: Util.RuntimeOptions): DescribeMonitoringAgentHostsResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitoringAgentHosts', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitoringAgentHosts(request: DescribeMonitoringAgentHostsRequest): DescribeMonitoringAgentHostsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentHostsWithOptions(request, runtime);
}

model DescribeSiteMonitorDataRequest = {
  taskId: string(name='TaskId', description='taskId'),
  type?: string(name='Type', description='type'),
  metricName: string(name='MetricName', description='metricName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  period?: string(name='Period', description='period'),
  nextToken?: string(name='NextToken', description='cursor'),
  length?: integer(name='Length', description='length'),
}

model DescribeSiteMonitorDataResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: string(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  nextToken: string(name='NextToken', description='cursor'),
  data: string(name='Data', description='data'),
}

async function describeSiteMonitorDataWithOptions(request: DescribeSiteMonitorDataRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeSiteMonitorData', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSiteMonitorData(request: DescribeSiteMonitorDataRequest): DescribeSiteMonitorDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorDataWithOptions(request, runtime);
}

model ModifySiteMonitorRequest = {
  address?: string(name='Address', description='address'),
  taskId: string(name='TaskId', description='taskId'),
  taskName?: string(name='TaskName', description='taskName'),
  interval?: string(name='Interval', description='interval'),
  ispCities?: string(name='IspCities', description='ispCity'),
  optionsJson?: string(name='OptionsJson', description='options'),
  alertIds?: string(name='AlertIds', description='alertIds'),
}

model ModifySiteMonitorResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: string(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    count: integer(name='count', description='count'),
  }(name='Data', description='data'),
}

async function modifySiteMonitorWithOptions(request: ModifySiteMonitorRequest, runtime: Util.RuntimeOptions): ModifySiteMonitorResponse {
  Util.validateModel(request);
  return doRequest('ModifySiteMonitor', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function modifySiteMonitor(request: ModifySiteMonitorRequest): ModifySiteMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySiteMonitorWithOptions(request, runtime);
}

model DescribeSiteMonitorISPCityListRequest = {
  isp?: string(name='Isp', description='isp'),
  city?: string(name='City', description='city'),
}

model DescribeSiteMonitorISPCityListResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: string(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  ispCityList: {
    ispCity: [
      {
        isp: string(name='Isp', description='cityIspCode.isp'),
        city: string(name='City', description='cityIspCode.city'),
        region: string(name='Region', description='regionCode'),
        country: string(name='Country', description='countryCode'),
        ispName: {
          en: string(name='en', description='ispEn'),
          zhCN: string(name='zh_CN', description='isp'),
        }(name='IspName', description='IspName'),
        cityName: {
          en: string(name='en', description='cityEn'),
          zhCN: string(name='zh_CN', description='city'),
        }(name='CityName', description='CityName'),
      }
    ](name='IspCity', description='IspCity'),
  }(name='IspCityList', description='data'),
}

async function describeSiteMonitorISPCityListWithOptions(request: DescribeSiteMonitorISPCityListRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorISPCityListResponse {
  Util.validateModel(request);
  return doRequest('DescribeSiteMonitorISPCityList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSiteMonitorISPCityList(request: DescribeSiteMonitorISPCityListRequest): DescribeSiteMonitorISPCityListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorISPCityListWithOptions(request, runtime);
}

model DescribeSiteMonitorQuotaRequest = {
}

model DescribeSiteMonitorQuotaResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: string(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    siteMonitorIdcQuota: integer(name='SiteMonitorIdcQuota', description='idcQuota'),
    siteMonitorOperatorQuotaQuota: integer(name='SiteMonitorOperatorQuotaQuota', description='operatorQuota'),
    siteMonitorTaskQuota: integer(name='SiteMonitorTaskQuota', description='taskQuota'),
    siteMonitorQuotaTaskUsed: integer(name='SiteMonitorQuotaTaskUsed', description='taskQuotaUsed'),
    siteMonitorVersion: string(name='SiteMonitorVersion', description='taskVersion'),
    secondMonitor: boolean(name='SecondMonitor', description='secondMonitor'),
  }(name='Data', description='data'),
}

async function describeSiteMonitorQuotaWithOptions(request: DescribeSiteMonitorQuotaRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorQuotaResponse {
  Util.validateModel(request);
  return doRequest('DescribeSiteMonitorQuota', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSiteMonitorQuota(request: DescribeSiteMonitorQuotaRequest): DescribeSiteMonitorQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorQuotaWithOptions(request, runtime);
}

model DescribeSiteMonitorStatisticsRequest = {
  taskId: string(name='TaskId', description='taskId'),
  timeRange?: string(name='TimeRange', description='timeRange'),
  startTime?: string(name='StartTime', description='startTime'),
  metricName: string(name='MetricName', description='metricName'),
}

model DescribeSiteMonitorStatisticsResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: string(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  data: string(name='Data', description='data.value'),
}

async function describeSiteMonitorStatisticsWithOptions(request: DescribeSiteMonitorStatisticsRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorStatisticsResponse {
  Util.validateModel(request);
  return doRequest('DescribeSiteMonitorStatistics', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSiteMonitorStatistics(request: DescribeSiteMonitorStatisticsRequest): DescribeSiteMonitorStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorStatisticsWithOptions(request, runtime);
}

model EnableSiteMonitorsRequest = {
  taskIds: string(name='TaskIds', description='taskIds'),
}

model EnableSiteMonitorsResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: string(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    count: integer(name='count', description='count'),
  }(name='Data', description='data'),
}

async function enableSiteMonitorsWithOptions(request: EnableSiteMonitorsRequest, runtime: Util.RuntimeOptions): EnableSiteMonitorsResponse {
  Util.validateModel(request);
  return doRequest('EnableSiteMonitors', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function enableSiteMonitors(request: EnableSiteMonitorsRequest): EnableSiteMonitorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableSiteMonitorsWithOptions(request, runtime);
}

model DescribeSiteMonitorAttributeRequest = {
  taskId: string(name='TaskId', description='taskId'),
  includeAlert?: boolean(name='IncludeAlert', description='includeAlert'),
}

model DescribeSiteMonitorAttributeResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  metricRules: {
    metricRule: [
      {
        ruleId: string(name='RuleId', description='name'),
        ruleName: string(name='RuleName', description='ruleName'),
        namespace: string(name='Namespace', description='namespace'),
        metricName: string(name='MetricName', description='metricName'),
        okActions: string(name='OkActions', description='okActions'),
        alarmActions: string(name='AlarmActions', description='alarmActions'),
        statistics: string(name='Statistics', description='statistics'),
        actionEnable: string(name='ActionEnable', description='actionEnable'),
        period: string(name='Period', description='period'),
        comparisonOperator: string(name='ComparisonOperator', description='comparisonOperator'),
        threshold: string(name='Threshold', description='threshold'),
        evaluationCount: string(name='EvaluationCount', description='evaluationCount'),
        level: string(name='Level', description='level'),
        expression: string(name='Expression', description='expression'),
        stateValue: string(name='StateValue', description='stateValue'),
        dimensions: string(name='Dimensions', description='dimensions'),
      }
    ](name='MetricRule', description='MetricRule'),
  }(name='MetricRules', description='data.alarms'),
  siteMonitors: {
    taskType: string(name='TaskType', description='taskTypeAlias'),
    address: string(name='Address', description='address'),
    taskState: string(name='TaskState', description='taskState'),
    taskName: string(name='TaskName', description='taskName'),
    interval: string(name='Interval', description='interval'),
    taskId: string(name='TaskId', description='taskId'),
    ispCities: {
      ispCity: [
        {
          cityName: string(name='CityName', description='city'),
          ispName: string(name='IspName', description='isp'),
          city: string(name='City', description='cityCode'),
          isp: string(name='Isp', description='ispCode'),
        }
      ](name='IspCity', description='IspCity'),
    }(name='IspCities', description='ispCity'),
    optionJson: {
      dnsType: string(name='dns_type', description='dns_type'),
      dnsServer: string(name='dns_server', description='dns_server'),
      expectValue: string(name='expect_value', description='expect_value'),
      httpMethod: string(name='http_method', description='http_method'),
      responseContent: string(name='response_content', description='response_content'),
      matchRule: integer(name='match_rule', description='match_rule'),
      requestContent: string(name='request_content', description='request_content'),
      cookie: string(name='cookie', description='cookie'),
      header: string(name='header', description='header'),
      username: string(name='username', description='username'),
      password: string(name='password', description='password'),
      timeOut: long(name='time_out', description='time_out'),
      pingNum: integer(name='ping_num', description='ping_num'),
      failureRate: float(name='failure_rate', description='failure_rate'),
      requestFormat: string(name='request_format', description='request_format'),
      responseFormat: string(name='response_format', description='response_format'),
      port: integer(name='port', description='port'),
      authentication: integer(name='authentication', description='authentication'),
      traceroute: long(name='traceroute', description='traceroute'),
    }(name='OptionJson', description='options'),
  }(name='SiteMonitors', description='data'),
}

async function describeSiteMonitorAttributeWithOptions(request: DescribeSiteMonitorAttributeRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeSiteMonitorAttribute', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSiteMonitorAttribute(request: DescribeSiteMonitorAttributeRequest): DescribeSiteMonitorAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorAttributeWithOptions(request, runtime);
}

model DescribeSiteMonitorListRequest = {
  taskId?: string(name='TaskId', description='taskId'),
  taskType?: string(name='TaskType', description='taskTypeAlias'),
  keyword?: string(name='Keyword', description='keyword'),
  page?: integer(name='Page', description='page'),
  pageSize?: integer(name='PageSize', description='pageSize'),
}

model DescribeSiteMonitorListResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: string(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  pageNumber: integer(name='PageNumber', description='pageInfo.page'),
  pageSize: integer(name='PageSize', description='pageInfo.pageSize'),
  totalCount: integer(name='TotalCount', description='pageInfo.total'),
  siteMonitors: {
    siteMonitor: [
      {
        taskId: string(name='TaskId', description='taskId'),
        taskType: string(name='TaskType', description='taskTypeAlias'),
        address: string(name='Address', description='address'),
        taskState: string(name='TaskState', description='taskState'),
        createTime: string(name='CreateTime', description='createTime'),
        taskName: string(name='TaskName', description='taskName'),
        interval: string(name='Interval', description='interval'),
        updateTime: string(name='UpdateTime', description='ts'),
        optionsJson: {
          dnsType: string(name='dns_type', description='dns_type'),
          dnsServer: string(name='dns_server', description='dns_server'),
          expectValue: string(name='expect_value', description='expect_value'),
          httpMethod: string(name='http_method', description='http_method'),
          responseContent: string(name='response_content', description='response_content'),
          matchRule: integer(name='match_rule', description='match_rule'),
          requestContent: string(name='request_content', description='request_content'),
          cookie: string(name='cookie', description='cookie'),
          header: string(name='header', description='header'),
          username: string(name='username', description='username'),
          password: string(name='password', description='password'),
          timeOut: long(name='time_out', description='time_out'),
          pingNum: integer(name='ping_num', description='ping_num'),
          failureRate: float(name='failure_rate', description='failure_rate'),
          requestFormat: string(name='request_format', description='request_format'),
          responseFormat: string(name='response_format', description='response_format'),
          port: integer(name='port', description='port'),
          authentication: integer(name='authentication', description='authentication'),
          traceroute: long(name='traceroute', description='traceroute'),
        }(name='OptionsJson', description='options'),
      }
    ](name='SiteMonitor', description='SiteMonitor'),
  }(name='SiteMonitors', description='data'),
}

async function describeSiteMonitorListWithOptions(request: DescribeSiteMonitorListRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorListResponse {
  Util.validateModel(request);
  return doRequest('DescribeSiteMonitorList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSiteMonitorList(request: DescribeSiteMonitorListRequest): DescribeSiteMonitorListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorListWithOptions(request, runtime);
}

model DeleteSiteMonitorsRequest = {
  taskIds: string(name='TaskIds', description='taskIds'),
  isDeleteAlarms?: boolean(name='IsDeleteAlarms', description='isDeleteAlarms'),
}

model DeleteSiteMonitorsResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: string(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    count: integer(name='count', description='count'),
  }(name='Data', description='data'),
}

async function deleteSiteMonitorsWithOptions(request: DeleteSiteMonitorsRequest, runtime: Util.RuntimeOptions): DeleteSiteMonitorsResponse {
  Util.validateModel(request);
  return doRequest('DeleteSiteMonitors', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteSiteMonitors(request: DeleteSiteMonitorsRequest): DeleteSiteMonitorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSiteMonitorsWithOptions(request, runtime);
}

model DisableSiteMonitorsRequest = {
  taskIds: string(name='TaskIds', description='taskIds'),
}

model DisableSiteMonitorsResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: string(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    count: integer(name='count', description='count'),
  }(name='Data', description='data'),
}

async function disableSiteMonitorsWithOptions(request: DisableSiteMonitorsRequest, runtime: Util.RuntimeOptions): DisableSiteMonitorsResponse {
  Util.validateModel(request);
  return doRequest('DisableSiteMonitors', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function disableSiteMonitors(request: DisableSiteMonitorsRequest): DisableSiteMonitorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableSiteMonitorsWithOptions(request, runtime);
}

model CreateSiteMonitorRequest = {
  address: string(name='Address', description='address'),
  taskType: string(name='TaskType', description='taskTypeAlias'),
  taskName: string(name='TaskName', description='taskName'),
  interval?: string(name='Interval', description='interval'),
  ispCities?: string(name='IspCities', description='ispCity'),
  optionsJson?: string(name='OptionsJson', description='options'),
  alertIds?: string(name='AlertIds', description='alertIds'),
}

model CreateSiteMonitorResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='message'),
  success: string(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  alertRule: string(name='AlertRule', description='alertRule'),
  data: {
    attachAlertResult: {
      contact: [
        {
          message: string(name='Message', description='message'),
          requestId: string(name='RequestId', description='requestId'),
          code: string(name='Code', description='httpStatusCode'),
          success: string(name='Success', description='success'),
          ruleId: string(name='RuleId', description='ruleId'),
        }
      ](name='Contact', description='Contact'),
    }(name='AttachAlertResult', description='attachAlertResult'),
  }(name='Data', description='data'),
}

async function createSiteMonitorWithOptions(request: CreateSiteMonitorRequest, runtime: Util.RuntimeOptions): CreateSiteMonitorResponse {
  Util.validateModel(request);
  return doRequest('CreateSiteMonitor', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createSiteMonitor(request: CreateSiteMonitorRequest): CreateSiteMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSiteMonitorWithOptions(request, runtime);
}

model DescribeProjectMetaRequest = {
  labels?: string(name='Labels', description='labels'),
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  pageSize?: integer(name='PageSize', description='pageSize'),
}

model DescribeProjectMetaResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  total: string(name='Total', description='total'),
  pageNumber: string(name='PageNumber', description='pageNumber'),
  pageSize: string(name='PageSize', description='pageSize'),
  resources: {
    resource: [
      {
        namespace: string(name='Namespace', description='project'),
        description: string(name='Description', description='description'),
        labels: string(name='Labels', description='labels'),
      }
    ](name='Resource', description='Resource'),
  }(name='Resources', description='resources'),
}

async function describeProjectMetaWithOptions(request: DescribeProjectMetaRequest, runtime: Util.RuntimeOptions): DescribeProjectMetaResponse {
  Util.validateModel(request);
  return doRequest('DescribeProjectMeta', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeProjectMeta(request: DescribeProjectMetaRequest): DescribeProjectMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeProjectMetaWithOptions(request, runtime);
}

model DescribeMetricListRequest = {
  namespace: string(name='Namespace', description='project'),
  metricName: string(name='MetricName', description='metric'),
  period?: string(name='Period', description='period'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  dimensions?: string(name='Dimensions', description='dimensions'),
  nextToken?: string(name='NextToken', description='cursor'),
  length?: string(name='Length', description='length'),
  express?: string(name='Express', description='express'),
}

model DescribeMetricListResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
  nextToken: string(name='NextToken', description='cursor'),
  datapoints: string(name='Datapoints', description='datapoints'),
  period: string(name='Period', description='period'),
  success: boolean(name='Success', description='code'),
}

async function describeMetricListWithOptions(request: DescribeMetricListRequest, runtime: Util.RuntimeOptions): DescribeMetricListResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMetricList(request: DescribeMetricListRequest): DescribeMetricListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricListWithOptions(request, runtime);
}

model DescribeMetricMetaListRequest = {
  namespace?: string(name='Namespace', description='project'),
  labels?: string(name='Labels', description='labels'),
  metricName?: string(name='MetricName', description='metric'),
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  pageSize?: integer(name='PageSize', description='pageSize'),
}

model DescribeMetricMetaListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  totalCount: string(name='TotalCount', description='total'),
  resources: {
    resource: [
      {
        namespace: string(name='Namespace', description='project'),
        metricName: string(name='MetricName', description='metric'),
        statistics: string(name='Statistics', description='statistics'),
        unit: string(name='Unit', description='unit'),
        description: string(name='Description', description='description'),
        dimensions: string(name='Dimensions', description='dimensions'),
        periods: string(name='Periods', description='periods'),
        labels: string(name='Labels', description='labels'),
      }
    ](name='Resource', description='Resource'),
  }(name='Resources', description='resources'),
}

async function describeMetricMetaListWithOptions(request: DescribeMetricMetaListRequest, runtime: Util.RuntimeOptions): DescribeMetricMetaListResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricMetaList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMetricMetaList(request: DescribeMetricMetaListRequest): DescribeMetricMetaListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricMetaListWithOptions(request, runtime);
}

model DescribeMetricTopRequest = {
  period?: string(name='Period', description='period'),
  namespace: string(name='Namespace', description='project'),
  metricName: string(name='MetricName', description='metric'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  dimensions?: string(name='Dimensions', description='dimensions'),
  orderby: string(name='Orderby', description='orderby'),
  orderDesc?: string(name='OrderDesc', description='orderDesc'),
  length?: string(name='Length', description='limit'),
  express?: string(name='Express', description='express'),
}

model DescribeMetricTopResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
  datapoints: string(name='Datapoints', description='datapoints'),
  period: string(name='Period', description='period'),
}

async function describeMetricTopWithOptions(request: DescribeMetricTopRequest, runtime: Util.RuntimeOptions): DescribeMetricTopResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricTop', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMetricTop(request: DescribeMetricTopRequest): DescribeMetricTopResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricTopWithOptions(request, runtime);
}

model DescribeMetricDataRequest = {
  namespace: string(name='Namespace', description='project'),
  metricName: string(name='MetricName', description='metric'),
  period?: string(name='Period', description='period'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  dimensions?: string(name='Dimensions', description='dimensions'),
  express?: string(name='Express', description='express'),
  length?: string(name='Length', description='length'),
}

model DescribeMetricDataResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
  datapoints: string(name='Datapoints', description='datapoints'),
  period: string(name='Period', description='period'),
}

async function describeMetricDataWithOptions(request: DescribeMetricDataRequest, runtime: Util.RuntimeOptions): DescribeMetricDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricData', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMetricData(request: DescribeMetricDataRequest): DescribeMetricDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricDataWithOptions(request, runtime);
}

model DescribeMetricLastRequest = {
  namespace: string(name='Namespace', description='project'),
  metricName: string(name='MetricName', description='metric'),
  period?: string(name='Period', description='period'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  dimensions?: string(name='Dimensions', description='dimensions'),
  nextToken?: string(name='NextToken', description='cursor'),
  length?: string(name='Length', description='length'),
  express?: string(name='Express', description='express'),
}

model DescribeMetricLastResponse = {
  code: string(name='Code', description='code'),
  message: string(name='Message', description='msg'),
  requestId: string(name='RequestId', description='traceId'),
  nextToken: string(name='NextToken', description='cursor'),
  datapoints: string(name='Datapoints', description='datapoints'),
  period: string(name='Period', description='period'),
  success: boolean(name='Success', description='code'),
}

async function describeMetricLastWithOptions(request: DescribeMetricLastRequest, runtime: Util.RuntimeOptions): DescribeMetricLastResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricLast', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMetricLast(request: DescribeMetricLastRequest): DescribeMetricLastResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricLastWithOptions(request, runtime);
}

model EnableHostAvailabilityRequest = {
  id: [ long ](name='Id', description='idListJson'),
}

model EnableHostAvailabilityResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
}

async function enableHostAvailabilityWithOptions(request: EnableHostAvailabilityRequest, runtime: Util.RuntimeOptions): EnableHostAvailabilityResponse {
  Util.validateModel(request);
  return doRequest('EnableHostAvailability', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function enableHostAvailability(request: EnableHostAvailabilityRequest): EnableHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableHostAvailabilityWithOptions(request, runtime);
}

model ModifyHostAvailabilityRequest = {
  groupId: long(name='GroupId', description='groupId'),
  id: long(name='Id', description='id'),
  taskName: string(name='TaskName', description='taskName'),
  taskScope?: string(name='TaskScope', description='taskScope'),
  taskOption: {
    httpURI?: string(name='HttpURI', description='uri'),
    telnetOrPingHost?: string(name='TelnetOrPingHost', description='host'),
    httpResponseCharset?: string(name='HttpResponseCharset', description='resposeCharset'),
    httpResponseMatchContent?: string(name='HttpResponseMatchContent', description='keyword'),
    httpMethod?: string(name='HttpMethod', description='method'),
    httpNegative?: boolean(name='HttpNegative', description='negative'),
  }(name='TaskOption', description='TaskOption'),
  alertConfig: {
    notifyType: integer(name='NotifyType', description='notifyType'),
    startTime?: integer(name='StartTime', description='startTime'),
    endTime?: integer(name='EndTime', description='endTime'),
    silenceTime?: integer(name='SilenceTime', description='silenceTime'),
    webHook?: string(name='WebHook', description='webhook'),
  }(name='AlertConfig', description='AlertConfig'),
  alertConfigEscalationList: [
    {
      metricName: string(name='MetricName', description='metric'),
      aggregate: string(name='Aggregate', description='aggregate'),
      times: integer(name='Times', description='times'),
      operator: string(name='Operator', description='operator'),
      value: string(name='Value', description='value'),
    }
  ](name='AlertConfigEscalationList', description='escalationListJson'),
  instanceList?: [ string ](name='InstanceList', description='instanceListJson'),
}

model ModifyHostAvailabilityResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
}

async function modifyHostAvailabilityWithOptions(request: ModifyHostAvailabilityRequest, runtime: Util.RuntimeOptions): ModifyHostAvailabilityResponse {
  Util.validateModel(request);
  return doRequest('ModifyHostAvailability', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function modifyHostAvailability(request: ModifyHostAvailabilityRequest): ModifyHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHostAvailabilityWithOptions(request, runtime);
}

model DisableHostAvailabilityRequest = {
  id: [ long ](name='Id', description='idListJson'),
}

model DisableHostAvailabilityResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
}

async function disableHostAvailabilityWithOptions(request: DisableHostAvailabilityRequest, runtime: Util.RuntimeOptions): DisableHostAvailabilityResponse {
  Util.validateModel(request);
  return doRequest('DisableHostAvailability', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function disableHostAvailability(request: DisableHostAvailabilityRequest): DisableHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableHostAvailabilityWithOptions(request, runtime);
}

model DescribeUnhealthyHostAvailabilityRequest = {
  id?: [ long ](name='Id', description='taskIdListJson'),
}

model DescribeUnhealthyHostAvailabilityResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  unhealthyList: {
    nodeTaskInstance: [
      {
        id: long(name='Id', description='taskId'),
        instanceList: {
          string: [ string ](name='String', description='String'),
        }(name='InstanceList', description='instanceList'),
      }
    ](name='NodeTaskInstance', description='NodeTaskInstance'),
  }(name='UnhealthyList', description='unhealthyList'),
}

async function describeUnhealthyHostAvailabilityWithOptions(request: DescribeUnhealthyHostAvailabilityRequest, runtime: Util.RuntimeOptions): DescribeUnhealthyHostAvailabilityResponse {
  Util.validateModel(request);
  return doRequest('DescribeUnhealthyHostAvailability', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeUnhealthyHostAvailability(request: DescribeUnhealthyHostAvailabilityRequest): DescribeUnhealthyHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUnhealthyHostAvailabilityWithOptions(request, runtime);
}

model CreateHostAvailabilityRequest = {
  groupId: long(name='GroupId', description='groupId'),
  taskName: string(name='TaskName', description='taskName'),
  taskScope?: string(name='TaskScope', description='taskScope'),
  taskType: string(name='TaskType', description='taskType'),
  taskOption: {
    httpURI?: string(name='HttpURI', description='uri'),
    telnetOrPingHost?: string(name='TelnetOrPingHost', description='host'),
    httpResponseCharset?: string(name='HttpResponseCharset', description='resposeCharset'),
    httpResponseMatchContent?: string(name='HttpResponseMatchContent', description='keyword'),
    httpMethod?: string(name='HttpMethod', description='method'),
    httpNegative?: boolean(name='HttpNegative', description='negative'),
  }(name='TaskOption', description='TaskOption'),
  alertConfig: {
    notifyType: integer(name='NotifyType', description='notifyType'),
    startTime?: integer(name='StartTime', description='startTime'),
    endTime?: integer(name='EndTime', description='endTime'),
    silenceTime?: integer(name='SilenceTime', description='silenceTime'),
    webHook?: string(name='WebHook', description='webhook'),
  }(name='AlertConfig', description='AlertConfig'),
  alertConfigEscalationList: [
    {
      metricName: string(name='MetricName', description='metric'),
      aggregate: string(name='Aggregate', description='aggregate'),
      times: integer(name='Times', description='times'),
      operator: string(name='Operator', description='operator'),
      value: string(name='Value', description='value'),
    }
  ](name='AlertConfigEscalationList', description='escalationListJson'),
  instanceList?: [ string ](name='InstanceList', description='instanceListJson'),
}

model CreateHostAvailabilityResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  taskId: long(name='TaskId', description='taskId'),
}

async function createHostAvailabilityWithOptions(request: CreateHostAvailabilityRequest, runtime: Util.RuntimeOptions): CreateHostAvailabilityResponse {
  Util.validateModel(request);
  return doRequest('CreateHostAvailability', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createHostAvailability(request: CreateHostAvailabilityRequest): CreateHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHostAvailabilityWithOptions(request, runtime);
}

model DescribeHostAvailabilityListRequest = {
  id?: long(name='Id', description='id'),
  taskName?: string(name='TaskName', description='taskName'),
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  groupId?: long(name='GroupId', description='groupId'),
}

model DescribeHostAvailabilityListResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  total: integer(name='Total', description='total'),
  taskList: {
    nodeTaskConfig: [
      {
        id: long(name='Id', description='id'),
        taskName: string(name='TaskName', description='taskName'),
        taskType: string(name='TaskType', description='taskType'),
        taskScope: string(name='TaskScope', description='taskScope'),
        disabled: boolean(name='Disabled', description='disabled'),
        groupId: long(name='GroupId', description='groupId'),
        groupName: string(name='GroupName', description='groupName'),
        taskOption: {
          httpURI: string(name='HttpURI', description='uri'),
          telnetOrPingHost: string(name='TelnetOrPingHost', description='host'),
          httpResponseCharset: string(name='HttpResponseCharset', description='resposeCharset'),
          httpKeyword: string(name='HttpKeyword', description='keyword'),
          httpMethod: string(name='HttpMethod', description='method'),
          httpNegative: boolean(name='HttpNegative', description='negative'),
        }(name='TaskOption', description='taskOption'),
        alertConfig: {
          notifyType: integer(name='NotifyType', description='notifyType'),
          startTime: integer(name='StartTime', description='startTime'),
          endTime: integer(name='EndTime', description='endTime'),
          silenceTime: integer(name='SilenceTime', description='silenceTime'),
          webHook: string(name='WebHook', description='webhook'),
          escalationList: {
            escalationList: [
              {
                metricName: string(name='MetricName', description='metric'),
                aggregate: string(name='Aggregate', description='aggregate'),
                operator: string(name='Operator', description='operator'),
                value: string(name='Value', description='value'),
                times: string(name='Times', description='times'),
              }
            ](name='escalationList', description='escalationList'),
          }(name='EscalationList', description='escalationList'),
        }(name='AlertConfig', description='alertConfig'),
        instances: {
          instance: [ string ](name='Instance', description='Instance'),
        }(name='Instances', description='instanceList'),
      }
    ](name='NodeTaskConfig', description='NodeTaskConfig'),
  }(name='TaskList', description='resources'),
}

async function describeHostAvailabilityListWithOptions(request: DescribeHostAvailabilityListRequest, runtime: Util.RuntimeOptions): DescribeHostAvailabilityListResponse {
  Util.validateModel(request);
  return doRequest('DescribeHostAvailabilityList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeHostAvailabilityList(request: DescribeHostAvailabilityListRequest): DescribeHostAvailabilityListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHostAvailabilityListWithOptions(request, runtime);
}

model DeleteHostAvailabilityRequest = {
  id: [ long ](name='Id', description='idListJson'),
}

model DeleteHostAvailabilityResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteHostAvailabilityWithOptions(request: DeleteHostAvailabilityRequest, runtime: Util.RuntimeOptions): DeleteHostAvailabilityResponse {
  Util.validateModel(request);
  return doRequest('DeleteHostAvailability', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteHostAvailability(request: DeleteHostAvailabilityRequest): DeleteHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHostAvailabilityWithOptions(request, runtime);
}

model DescribeMonitoringConfigRequest = {
}

model DescribeMonitoringConfigResponse = {
  code: string(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  autoInstall: boolean(name='AutoInstall', description='autoInstall'),
  enableInstallAgentNewECS: boolean(name='EnableInstallAgentNewECS', description='enableInstallAgentNewECS'),
}

async function describeMonitoringConfigWithOptions(request: DescribeMonitoringConfigRequest, runtime: Util.RuntimeOptions): DescribeMonitoringConfigResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitoringConfig', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitoringConfig(request: DescribeMonitoringConfigRequest): DescribeMonitoringConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringConfigWithOptions(request, runtime);
}

model PutMonitoringConfigRequest = {
  autoInstall?: boolean(name='AutoInstall', description='autoInstall'),
  enableInstallAgentNewECS?: boolean(name='EnableInstallAgentNewECS', description='enableInstallAgentNewECS'),
}

model PutMonitoringConfigResponse = {
  code: integer(name='Code', description='errorCode'),
  message: string(name='Message', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
}

async function putMonitoringConfigWithOptions(request: PutMonitoringConfigRequest, runtime: Util.RuntimeOptions): PutMonitoringConfigResponse {
  Util.validateModel(request);
  return doRequest('PutMonitoringConfig', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putMonitoringConfig(request: PutMonitoringConfigRequest): PutMonitoringConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return putMonitoringConfigWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
