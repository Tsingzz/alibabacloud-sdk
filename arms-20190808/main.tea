import Util;
import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'arms.ap-southeast-1.aliyuncs.com',
    ap-south-1 = 'arms.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'arms.ap-southeast-1.aliyuncs.com',
    ap-southeast-3 = 'arms.ap-southeast-1.aliyuncs.com',
    ap-southeast-5 = 'arms.ap-southeast-1.aliyuncs.com',
    cn-chengdu = 'arms.aliyuncs.com',
    cn-huhehaote = 'arms.aliyuncs.com',
    eu-central-1 = 'arms.ap-southeast-1.aliyuncs.com',
    eu-west-1 = 'arms.ap-southeast-1.aliyuncs.com',
    me-east-1 = 'arms.ap-southeast-1.aliyuncs.com',
    us-east-1 = 'arms.ap-southeast-1.aliyuncs.com',
    cn-hangzhou-finance = 'arms.aliyuncs.com',
    cn-shenzhen-finance-1 = 'arms.aliyuncs.com',
    cn-shanghai-finance-1 = 'arms.aliyuncs.com',
    cn-north-2-gov-1 = 'arms.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('arms', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model GetMultipleTraceRequest = {
  regionId: string(name='RegionId', description='regionId'),
  traceIDs?: [ string ](name='TraceIDs', description='traceIDS'),
}

model GetMultipleTraceResponse = {
  requestId: string(name='RequestId', description='requestId'),
  multiCallChainInfos: [
    {
      traceID: string(name='TraceID', description='traceID'),
      spans: [
        {
          traceID: string(name='TraceID', description='traceID'),
          operationName: string(name='OperationName', description='operationName'),
          duration: long(name='Duration', description='duration'),
          serviceName: string(name='ServiceName', description='serviceName'),
          serviceIp: string(name='ServiceIp', description='serviceIp'),
          timestamp: long(name='Timestamp', description='timestamp'),
          rpcId: string(name='RpcId', description='rpcId'),
          resultCode: string(name='ResultCode', description='resultCode'),
          haveStack: boolean(name='HaveStack', description='haveStack'),
          rpcType: integer(name='RpcType', description='rpcType'),
          tagEntryList: [
            {
              key: string(name='Key', description='key'),
              value: string(name='Value', description='value'),
            }
          ](name='TagEntryList', description='tagEntryList'),
          logEventList: [
            {
              timestamp: long(name='Timestamp', description='timestamp'),
              tagEntryList: [
                {
                  key: string(name='Key', description='key'),
                  value: string(name='Value', description='value'),
                }
              ](name='TagEntryList', description='tagEntryList'),
            }
          ](name='LogEventList', description='logEventList'),
        }
      ](name='Spans', description='callChainInfo'),
    }
  ](name='MultiCallChainInfos', description='data'),
}

async function getMultipleTraceWithOptions(request: GetMultipleTraceRequest, runtime: Util.RuntimeOptions): GetMultipleTraceResponse {
  Util.validateModel(request);
  return doRequest('GetMultipleTrace', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function getMultipleTrace(request: GetMultipleTraceRequest): GetMultipleTraceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMultipleTraceWithOptions(request, runtime);
}

model SearchTracesByPageRequest = {
  startTime: long(name='StartTime', description='startTime'),
  endTime: long(name='EndTime', description='endTime'),
  regionId: string(name='RegionId', description='regionId'),
  serviceName?: string(name='ServiceName', description='serviceName'),
  operationName?: string(name='OperationName', description='operationName'),
  minDuration?: long(name='MinDuration', description='minDuration'),
  serviceIp?: string(name='ServiceIp', description='serviceIp'),
  exclusionFilters?: [
    {
      key?: string(name='Key', description='key'),
      value?: string(name='Value', description='value'),
    }
  ](name='ExclusionFilters', description='exclusionFilters'),
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  pageSize?: integer(name='PageSize', description='pageSize'),
}

model SearchTracesByPageResponse = {
  requestId: string(name='RequestId', description='requestId'),
  pageBean: {
    total: integer(name='Total', description='total'),
    pageNumber: integer(name='PageNumber', description='page'),
    pageSize: integer(name='PageSize', description='pageSize'),
    traceInfos: [
      {
        traceID: string(name='TraceID', description='traceID'),
        operationName: string(name='OperationName', description='operationName'),
        serviceName: string(name='ServiceName', description='serviceName'),
        serviceIp: string(name='ServiceIp', description='serviceIp'),
        duration: long(name='Duration', description='duration'),
        timestamp: long(name='Timestamp', description='timestamp'),
      }
    ](name='TraceInfos', description='items'),
  }(name='PageBean', description='data'),
}

async function searchTracesByPageWithOptions(request: SearchTracesByPageRequest, runtime: Util.RuntimeOptions): SearchTracesByPageResponse {
  Util.validateModel(request);
  return doRequest('SearchTracesByPage', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function searchTracesByPage(request: SearchTracesByPageRequest): SearchTracesByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTracesByPageWithOptions(request, runtime);
}

model GetStackRequest = {
  traceID: string(name='TraceID', description='traceId'),
  regionId: string(name='RegionId', description='regionId'),
  rpcID?: string(name='RpcID', description='rpcId'),
}

model GetStackResponse = {
  requestId: string(name='RequestId', description='requestId'),
  stackInfo: [
    {
      startTime: long(name='StartTime', description='startTime'),
      duration: long(name='Duration', description='duration'),
      rpcId: string(name='RpcId', description='rpcId'),
      serviceName: string(name='ServiceName', description='serviceName'),
      api: string(name='Api', description='api'),
      exception: string(name='Exception', description='exception'),
      line: string(name='Line', description='line'),
      extInfo: [
        {
          type: string(name='Type', description='type'),
          info: string(name='Info', description='info'),
        }
      ](name='ExtInfo', description='extInfo'),
    }
  ](name='StackInfo', description='data'),
}

async function getStackWithOptions(request: GetStackRequest, runtime: Util.RuntimeOptions): GetStackResponse {
  Util.validateModel(request);
  return doRequest('GetStack', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function getStack(request: GetStackRequest): GetStackResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStackWithOptions(request, runtime);
}

model DescribeTraceLocationRequest = {
  regionId?: string(name='RegionId', description='regionId'),
}

model DescribeTraceLocationResponse = {
  requestId: string(name='RequestId', description='requestId'),
  regionConfigs: [
    {
      regionNo: string(name='RegionNo', description='regionNo'),
      url: string(name='Url', description='url'),
    }
  ](name='RegionConfigs', description='data'),
}

async function describeTraceLocationWithOptions(request: DescribeTraceLocationRequest, runtime: Util.RuntimeOptions): DescribeTraceLocationResponse {
  Util.validateModel(request);
  return doRequest('DescribeTraceLocation', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function describeTraceLocation(request: DescribeTraceLocationRequest): DescribeTraceLocationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTraceLocationWithOptions(request, runtime);
}

model DeleteTraceAppRequest = {
  appId: string(name='AppId', description='appId'),
  regionId: string(name='RegionId', description='regionId'),
  type: string(name='Type', description='type'),
}

model DeleteTraceAppResponse = {
  requestId: string(name='RequestId', description='requestId'),
  data: string(name='Data', description='data'),
}

async function deleteTraceAppWithOptions(request: DeleteTraceAppRequest, runtime: Util.RuntimeOptions): DeleteTraceAppResponse {
  Util.validateModel(request);
  return doRequest('DeleteTraceApp', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function deleteTraceApp(request: DeleteTraceAppRequest): DeleteTraceAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTraceAppWithOptions(request, runtime);
}

model DescribeTraceLicenseKeyRequest = {
  regionId?: string(name='RegionId', description='regionId'),
}

model DescribeTraceLicenseKeyResponse = {
  requestId: string(name='RequestId', description='requestId'),
  licenseKey: string(name='LicenseKey', description='data'),
}

async function describeTraceLicenseKeyWithOptions(request: DescribeTraceLicenseKeyRequest, runtime: Util.RuntimeOptions): DescribeTraceLicenseKeyResponse {
  Util.validateModel(request);
  return doRequest('DescribeTraceLicenseKey', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function describeTraceLicenseKey(request: DescribeTraceLicenseKeyRequest): DescribeTraceLicenseKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTraceLicenseKeyWithOptions(request, runtime);
}

model ConfigAppRequest = {
  appIds: string(name='AppIds', description='appIds'),
  enable?: boolean(name='Enable', description='enable'),
  regionId: string(name='RegionId', description='regionId'),
}

model ConfigAppResponse = {
  requestId: string(name='RequestId', description='requestId'),
  data: string(name='Data', description='data'),
}

async function configAppWithOptions(request: ConfigAppRequest, runtime: Util.RuntimeOptions): ConfigAppResponse {
  Util.validateModel(request);
  return doRequest('ConfigApp', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function configApp(request: ConfigAppRequest): ConfigAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return configAppWithOptions(request, runtime);
}

model CheckServiceLinkedRoleForDeletingRequest = {
  roleArn: string(name='RoleArn', description='roleArn'),
  serviceName: string(name='ServiceName', description='serviceName'),
  SPIRegionId: string(name='SPIRegionId', description='spiRegionId'),
  deletionTaskId: string(name='DeletionTaskId', description='deletionTaskId'),
  regionId?: string(name='RegionId', description='regionId'),
}

model CheckServiceLinkedRoleForDeletingResponse = {
  requestId: string(name='RequestId', description='requestId'),
  deletable: boolean(name='Deletable', description='deletable'),
  roleUsages: [
    {
      region: string(name='Region', description='region'),
      resources: [ string ](name='Resources', description='resources'),
    }
  ](name='RoleUsages', description='roleUsages'),
}

async function checkServiceLinkedRoleForDeletingWithOptions(request: CheckServiceLinkedRoleForDeletingRequest, runtime: Util.RuntimeOptions): CheckServiceLinkedRoleForDeletingResponse {
  Util.validateModel(request);
  return doRequest('CheckServiceLinkedRoleForDeleting', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function checkServiceLinkedRoleForDeleting(request: CheckServiceLinkedRoleForDeletingRequest): CheckServiceLinkedRoleForDeletingResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkServiceLinkedRoleForDeletingWithOptions(request, runtime);
}

model ListDashboardsRequest = {
  regionId: string(name='RegionId', description='regionId'),
  clusterId: string(name='ClusterId', description='clusterId'),
}

model ListDashboardsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  dashboardVos: [
    {
      id: string(name='Id', description='id'),
      uid: string(name='Uid', description='uid'),
      title: string(name='Title', description='title'),
      time: string(name='Time', description='time'),
      url: string(name='Url', description='url'),
      type: string(name='Type', description='type'),
      exporter: string(name='Exporter', description='exporter'),
      isArmsExporter: boolean(name='IsArmsExporter', description='isArmsExporter'),
      tags: [ string ](name='Tags', description='tags'),
    }
  ](name='DashboardVos', description='data'),
}

async function listDashboardsWithOptions(request: ListDashboardsRequest, runtime: Util.RuntimeOptions): ListDashboardsResponse {
  Util.validateModel(request);
  return doRequest('ListDashboards', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function listDashboards(request: ListDashboardsRequest): ListDashboardsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDashboardsWithOptions(request, runtime);
}

model GetConsistencySnapshotRequest = {
  currentTimestamp?: long(name='CurrentTimestamp', description='currentTimestamp'),
  regionId: string(name='RegionId', description='regionId'),
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
  pid: string(name='Pid', description='pid'),
  appType: string(name='AppType', description='appType'),
}

model GetConsistencySnapshotResponse = {
  requestId: string(name='RequestId', description='requestId'),
  consistencyResultJsonStr: string(name='ConsistencyResultJsonStr', description='data'),
}

async function getConsistencySnapshotWithOptions(request: GetConsistencySnapshotRequest, runtime: Util.RuntimeOptions): GetConsistencySnapshotResponse {
  Util.validateModel(request);
  return doRequest('GetConsistencySnapshot', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function getConsistencySnapshot(request: GetConsistencySnapshotRequest): GetConsistencySnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConsistencySnapshotWithOptions(request, runtime);
}

model CheckDataConsistencyRequest = {
  currentTimestamp?: long(name='CurrentTimestamp', description='currentTimestamp'),
  regionId: string(name='RegionId', description='regionId'),
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
  pid: string(name='Pid', description='pid'),
  appType: string(name='AppType', description='appType'),
}

model CheckDataConsistencyResponse = {
  requestId: string(name='RequestId', description='requestId'),
  isDataConsistency: boolean(name='IsDataConsistency', description='data'),
}

async function checkDataConsistencyWithOptions(request: CheckDataConsistencyRequest, runtime: Util.RuntimeOptions): CheckDataConsistencyResponse {
  Util.validateModel(request);
  return doRequest('CheckDataConsistency', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function checkDataConsistency(request: CheckDataConsistencyRequest): CheckDataConsistencyResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkDataConsistencyWithOptions(request, runtime);
}

model AddGrafanaRequest = {
  regionId: string(name='RegionId', description='regionId'),
  clusterId: string(name='ClusterId', description='clusterId'),
  integration: string(name='Integration', description='integration'),
}

model AddGrafanaResponse = {
  requestId: string(name='RequestId', description='requestId'),
  data: string(name='Data', description='data'),
}

async function addGrafanaWithOptions(request: AddGrafanaRequest, runtime: Util.RuntimeOptions): AddGrafanaResponse {
  Util.validateModel(request);
  return doRequest('AddGrafana', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function addGrafana(request: AddGrafanaRequest): AddGrafanaResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGrafanaWithOptions(request, runtime);
}

model AddIntegrationRequest = {
  regionId: string(name='RegionId', description='regionId'),
  clusterId: string(name='ClusterId', description='clusterId'),
  integration: string(name='Integration', description='integration'),
}

model AddIntegrationResponse = {
  requestId: string(name='RequestId', description='requestId'),
  data: string(name='Data', description='data'),
}

async function addIntegrationWithOptions(request: AddIntegrationRequest, runtime: Util.RuntimeOptions): AddIntegrationResponse {
  Util.validateModel(request);
  return doRequest('AddIntegration', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function addIntegration(request: AddIntegrationRequest): AddIntegrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return addIntegrationWithOptions(request, runtime);
}

model GetTraceRequest = {
  traceID: string(name='TraceID', description='traceID'),
  regionId: string(name='RegionId', description='regionId'),
}

model GetTraceResponse = {
  requestId: string(name='RequestId', description='requestId'),
  spans: [
    {
      traceID: string(name='TraceID', description='traceID'),
      operationName: string(name='OperationName', description='operationName'),
      duration: long(name='Duration', description='duration'),
      serviceName: string(name='ServiceName', description='serviceName'),
      serviceIp: string(name='ServiceIp', description='serviceIp'),
      timestamp: long(name='Timestamp', description='timestamp'),
      rpcId: string(name='RpcId', description='rpcId'),
      resultCode: string(name='ResultCode', description='resultCode'),
      haveStack: boolean(name='HaveStack', description='haveStack'),
      rpcType: integer(name='RpcType', description='rpcType'),
      tagEntryList: [
        {
          key: string(name='Key', description='key'),
          value: string(name='Value', description='value'),
        }
      ](name='TagEntryList', description='tagEntryList'),
      logEventList: [
        {
          timestamp: long(name='Timestamp', description='timestamp'),
          tagEntryList: [
            {
              key: string(name='Key', description='key'),
              value: string(name='Value', description='value'),
            }
          ](name='TagEntryList', description='tagEntryList'),
        }
      ](name='LogEventList', description='logEventList'),
    }
  ](name='Spans', description='data'),
}

async function getTraceWithOptions(request: GetTraceRequest, runtime: Util.RuntimeOptions): GetTraceResponse {
  Util.validateModel(request);
  return doRequest('GetTrace', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function getTrace(request: GetTraceRequest): GetTraceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTraceWithOptions(request, runtime);
}

model ListClusterFromGrafanaRequest = {
  regionId: string(name='RegionId', description='regionId'),
}

model ListClusterFromGrafanaResponse = {
  requestId: string(name='RequestId', description='requestId'),
  promClusterList: [
    {
      id: long(name='Id', description='id'),
      clusterId: string(name='ClusterId', description='clusterId'),
      clusterName: string(name='ClusterName', description='clusterName'),
      agentStatus: string(name='AgentStatus', description='agentStatus'),
      clusterType: string(name='ClusterType', description='clusterType'),
      controllerId: string(name='ControllerId', description='controllerId'),
      isControllerInstalled: boolean(name='IsControllerInstalled', description='isControllerInstalled'),
      userId: string(name='UserId', description='userId'),
      regionId: string(name='RegionId', description='regionId'),
      pluginsJsonArray: string(name='PluginsJsonArray', description='plugins_json_array'),
      stateJson: string(name='StateJson', description='state_json'),
      nodeNum: integer(name='NodeNum', description='node_num'),
      createTime: long(name='CreateTime', description='createTime'),
      updateTime: long(name='UpdateTime', description='updateTime'),
      lastHeartBeatTime: long(name='LastHeartBeatTime', description='lastHeartBeatTime'),
      installTime: long(name='InstallTime', description='installTime'),
      extra: string(name='Extra', description='extra'),
      options: string(name='Options', description='options'),
    }
  ](name='PromClusterList', description='data'),
}

async function listClusterFromGrafanaWithOptions(request: ListClusterFromGrafanaRequest, runtime: Util.RuntimeOptions): ListClusterFromGrafanaResponse {
  Util.validateModel(request);
  return doRequest('ListClusterFromGrafana', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function listClusterFromGrafana(request: ListClusterFromGrafanaRequest): ListClusterFromGrafanaResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterFromGrafanaWithOptions(request, runtime);
}

model SearchTracesRequest = {
  startTime: long(name='StartTime', description='startTime'),
  endTime: long(name='EndTime', description='endTime'),
  regionId: string(name='RegionId', description='regionId'),
  serviceName?: string(name='ServiceName', description='serviceName'),
  operationName?: string(name='OperationName', description='operationName'),
  minDuration?: long(name='MinDuration', description='minDuration'),
  tag?: [
    {
      key?: string(name='Key', description='key'),
      value?: string(name='Value', description='value'),
    }
  ](name='Tag', description='tags'),
  serviceIp?: string(name='ServiceIp', description='serviceIp'),
  exclusionFilters?: [
    {
      key?: string(name='Key', description='key'),
      value?: string(name='Value', description='value'),
    }
  ](name='ExclusionFilters', description='exclusionFilters'),
}

model SearchTracesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  traceInfos: [
    {
      traceID: string(name='TraceID', description='traceID'),
      operationName: string(name='OperationName', description='operationName'),
      serviceName: string(name='ServiceName', description='serviceName'),
      serviceIp: string(name='ServiceIp', description='serviceIp'),
      duration: long(name='Duration', description='duration'),
      timestamp: long(name='Timestamp', description='timestamp'),
    }
  ](name='TraceInfos', description='data'),
}

async function searchTracesWithOptions(request: SearchTracesRequest, runtime: Util.RuntimeOptions): SearchTracesResponse {
  Util.validateModel(request);
  return doRequest('SearchTraces', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function searchTraces(request: SearchTracesRequest): SearchTracesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTracesWithOptions(request, runtime);
}

model GetPrometheusApiTokenRequest = {
  regionId: string(name='RegionId', description='regionId'),
}

model GetPrometheusApiTokenResponse = {
  requestId: string(name='RequestId', description='requestId'),
  token: string(name='Token', description='data'),
}

async function getPrometheusApiTokenWithOptions(request: GetPrometheusApiTokenRequest, runtime: Util.RuntimeOptions): GetPrometheusApiTokenResponse {
  Util.validateModel(request);
  return doRequest('GetPrometheusApiToken', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function getPrometheusApiToken(request: GetPrometheusApiTokenRequest): GetPrometheusApiTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPrometheusApiTokenWithOptions(request, runtime);
}

model SetRetcodeShareStatusRequest = {
  pid: string(name='Pid', description='pid'),
  status: boolean(name='Status', description='status'),
}

model SetRetcodeShareStatusResponse = {
  requestId: string(name='RequestId', description='requestId'),
  isSuccess: boolean(name='IsSuccess', description='data'),
}

async function setRetcodeShareStatusWithOptions(request: SetRetcodeShareStatusRequest, runtime: Util.RuntimeOptions): SetRetcodeShareStatusResponse {
  Util.validateModel(request);
  return doRequest('SetRetcodeShareStatus', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function setRetcodeShareStatus(request: SetRetcodeShareStatusRequest): SetRetcodeShareStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setRetcodeShareStatusWithOptions(request, runtime);
}

model GetRetcodeShareUrlRequest = {
  pid: string(name='Pid', description='pid'),
}

model GetRetcodeShareUrlResponse = {
  requestId: string(name='RequestId', description='requestId'),
  url: string(name='Url', description='data'),
}

async function getRetcodeShareUrlWithOptions(request: GetRetcodeShareUrlRequest, runtime: Util.RuntimeOptions): GetRetcodeShareUrlResponse {
  Util.validateModel(request);
  return doRequest('GetRetcodeShareUrl', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function getRetcodeShareUrl(request: GetRetcodeShareUrlRequest): GetRetcodeShareUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRetcodeShareUrlWithOptions(request, runtime);
}

model ListPromClustersRequest = {
  regionId: string(name='RegionId', description='regionId'),
}

model ListPromClustersResponse = {
  requestId: string(name='RequestId', description='requestId'),
  promClusterList: [
    {
      id: long(name='Id', description='id'),
      clusterId: string(name='ClusterId', description='clusterId'),
      clusterName: string(name='ClusterName', description='clusterName'),
      agentStatus: string(name='AgentStatus', description='agentStatus'),
      clusterType: string(name='ClusterType', description='clusterType'),
      controllerId: string(name='ControllerId', description='controllerId'),
      isControllerInstalled: boolean(name='IsControllerInstalled', description='isControllerInstalled'),
      userId: string(name='UserId', description='userId'),
      regionId: string(name='RegionId', description='regionId'),
      pluginsJsonArray: string(name='PluginsJsonArray', description='plugins_json_array'),
      stateJson: string(name='StateJson', description='state_json'),
      nodeNum: integer(name='NodeNum', description='node_num'),
      createTime: long(name='CreateTime', description='createTime'),
      updateTime: long(name='UpdateTime', description='updateTime'),
      lastHeartBeatTime: long(name='LastHeartBeatTime', description='lastHeartBeatTime'),
      installTime: long(name='InstallTime', description='installTime'),
      extra: string(name='Extra', description='extra'),
      options: string(name='Options', description='options'),
    }
  ](name='PromClusterList', description='data'),
}

async function listPromClustersWithOptions(request: ListPromClustersRequest, runtime: Util.RuntimeOptions): ListPromClustersResponse {
  Util.validateModel(request);
  return doRequest('ListPromClusters', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function listPromClusters(request: ListPromClustersRequest): ListPromClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPromClustersWithOptions(request, runtime);
}

model UpdateAlertRuleRequest = {
  regionId: string(name='RegionId', description='regionId'),
  contactGroupIds?: string(name='ContactGroupIds', description='contactGroupIds'),
  isAutoStart?: boolean(name='IsAutoStart', description='isAutoStart'),
  templageAlertConfig: string(name='TemplageAlertConfig', description='TemplageAlertConfig'),
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
  alertId: long(name='AlertId', description='alertId'),
}

model UpdateAlertRuleResponse = {
  requestId: string(name='RequestId', description='requestId'),
  data: string(name='Data', description='data'),
  alertId: long(name='AlertId', description='data'),
}

async function updateAlertRuleWithOptions(request: UpdateAlertRuleRequest, runtime: Util.RuntimeOptions): UpdateAlertRuleResponse {
  Util.validateModel(request);
  return doRequest('UpdateAlertRule', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function updateAlertRule(request: UpdateAlertRuleRequest): UpdateAlertRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAlertRuleWithOptions(request, runtime);
}

model StartAlertRequest = {
  alertId: string(name='AlertId', description='id'),
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
  regionId: string(name='RegionId', description='regionId'),
}

model StartAlertResponse = {
  requestId: string(name='RequestId', description='requestId'),
  isSuccess: boolean(name='IsSuccess', description='data'),
}

async function startAlertWithOptions(request: StartAlertRequest, runtime: Util.RuntimeOptions): StartAlertResponse {
  Util.validateModel(request);
  return doRequest('StartAlert', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function startAlert(request: StartAlertRequest): StartAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  return startAlertWithOptions(request, runtime);
}

model StopAlertRequest = {
  alertId: string(name='AlertId', description='id'),
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
  regionId: string(name='RegionId', description='regionId'),
}

model StopAlertResponse = {
  requestId: string(name='RequestId', description='requestId'),
  isSuccess: boolean(name='IsSuccess', description='data'),
}

async function stopAlertWithOptions(request: StopAlertRequest, runtime: Util.RuntimeOptions): StopAlertResponse {
  Util.validateModel(request);
  return doRequest('StopAlert', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function stopAlert(request: StopAlertRequest): StopAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopAlertWithOptions(request, runtime);
}

model SearchEventsRequest = {
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
  alertId?: long(name='AlertId', description='alertId'),
  pid?: string(name='Pid', description='pid'),
  currentPage?: integer(name='CurrentPage', description='currentPage'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  regionId: string(name='RegionId', description='regionId'),
  appType?: string(name='AppType', description='appType'),
  alertType?: integer(name='AlertType', description='alertType'),
  isTrigger?: integer(name='IsTrigger', description='isTrigger'),
  startTime?: long(name='StartTime', description='startTime'),
  endTime?: long(name='EndTime', description='endTime'),
}

model SearchEventsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  isTrigger: integer(name='IsTrigger', description='isTrigger'),
  pageBean: {
    totalCount: integer(name='TotalCount', description='total'),
    pageNumber: integer(name='PageNumber', description='page'),
    pageSize: integer(name='PageSize', description='pageSize'),
    event: [
      {
        id: long(name='Id', description='id'),
        eventTime: long(name='EventTime', description='eventTime'),
        alertType: integer(name='AlertType', description='alertType'),
        eventLevel: integer(name='EventLevel', description='errorLevel'),
        message: string(name='Message', description='message'),
        alertId: long(name='AlertId', description='alertId'),
        alertName: string(name='AlertName', description='alertName'),
        alertRule: string(name='AlertRule', description='alertRule'),
        links: [ string ](name='Links', description='links'),
      }
    ](name='Event', description='items'),
  }(name='PageBean', description='data'),
}

async function searchEventsWithOptions(request: SearchEventsRequest, runtime: Util.RuntimeOptions): SearchEventsResponse {
  Util.validateModel(request);
  return doRequest('SearchEvents', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function searchEvents(request: SearchEventsRequest): SearchEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchEventsWithOptions(request, runtime);
}

model SearchAlertHistoriesRequest = {
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
  alertId?: long(name='AlertId', description='alertId'),
  alertType?: integer(name='AlertType', description='alertType'),
  currentPage?: integer(name='CurrentPage', description='currentPage'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  regionId: string(name='RegionId', description='regionId'),
  startTime?: long(name='StartTime', description='startTime'),
  endTime?: long(name='EndTime', description='endTime'),
}

model SearchAlertHistoriesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  pageBean: {
    totalCount: integer(name='TotalCount', description='total'),
    pageNumber: integer(name='PageNumber', description='page'),
    pageSize: integer(name='PageSize', description='pageSize'),
    alarmHistories: [
      {
        id: long(name='Id', description='id'),
        strategyId: string(name='StrategyId', description='strategyId'),
        userId: string(name='UserId', description='tenant'),
        target: string(name='Target', description='target'),
        phones: string(name='Phones', description='phones'),
        emails: string(name='Emails', description='emails'),
        alarmTime: long(name='AlarmTime', description='alarmTime'),
        alarmType: integer(name='AlarmType', description='alarmType'),
        alarmResponseCode: integer(name='AlarmResponseCode', description='alarmResponseCode'),
        alarmContent: string(name='AlarmContent', description='alarmContent'),
        alarmSources: string(name='AlarmSources', description='alarmSources'),
      }
    ](name='AlarmHistories', description='items'),
  }(name='PageBean', description='data'),
}

async function searchAlertHistoriesWithOptions(request: SearchAlertHistoriesRequest, runtime: Util.RuntimeOptions): SearchAlertHistoriesResponse {
  Util.validateModel(request);
  return doRequest('SearchAlertHistories', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function searchAlertHistories(request: SearchAlertHistoriesRequest): SearchAlertHistoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAlertHistoriesWithOptions(request, runtime);
}

model UpdateAlertContactRequest = {
  contactName?: string(name='ContactName', description='name'),
  phoneNum?: string(name='PhoneNum', description='phone'),
  email?: string(name='Email', description='email'),
  dingRobotWebhookUrl?: string(name='DingRobotWebhookUrl', description='dingRobot'),
  systemNoc?: boolean(name='SystemNoc', description='systemNoc'),
  regionId: string(name='RegionId', description='regionId'),
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
  contactId: long(name='ContactId', description='id'),
}

model UpdateAlertContactResponse = {
  requestId: string(name='RequestId', description='requestId'),
  isSuccess: boolean(name='IsSuccess', description='data'),
}

async function updateAlertContactWithOptions(request: UpdateAlertContactRequest, runtime: Util.RuntimeOptions): UpdateAlertContactResponse {
  Util.validateModel(request);
  return doRequest('UpdateAlertContact', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function updateAlertContact(request: UpdateAlertContactRequest): UpdateAlertContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAlertContactWithOptions(request, runtime);
}

model DeleteAlertContactGroupRequest = {
  regionId: string(name='RegionId', description='regionId'),
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
  contactGroupId: long(name='ContactGroupId', description='id'),
}

model DeleteAlertContactGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  isSuccess: boolean(name='IsSuccess', description='data'),
}

async function deleteAlertContactGroupWithOptions(request: DeleteAlertContactGroupRequest, runtime: Util.RuntimeOptions): DeleteAlertContactGroupResponse {
  Util.validateModel(request);
  return doRequest('DeleteAlertContactGroup', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function deleteAlertContactGroup(request: DeleteAlertContactGroupRequest): DeleteAlertContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAlertContactGroupWithOptions(request, runtime);
}

model DeleteAlertContactRequest = {
  regionId: string(name='RegionId', description='regionId'),
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
  contactId: long(name='ContactId', description='id'),
}

model DeleteAlertContactResponse = {
  requestId: string(name='RequestId', description='requestId'),
  isSuccess: boolean(name='IsSuccess', description='data'),
}

async function deleteAlertContactWithOptions(request: DeleteAlertContactRequest, runtime: Util.RuntimeOptions): DeleteAlertContactResponse {
  Util.validateModel(request);
  return doRequest('DeleteAlertContact', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function deleteAlertContact(request: DeleteAlertContactRequest): DeleteAlertContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAlertContactWithOptions(request, runtime);
}

model UpdateAlertContactGroupRequest = {
  contactGroupName: string(name='ContactGroupName', description='name'),
  contactIds?: string(name='ContactIds', description='ids'),
  regionId: string(name='RegionId', description='regionId'),
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
  contactGroupId: long(name='ContactGroupId', description='id'),
}

model UpdateAlertContactGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  isSuccess: boolean(name='IsSuccess', description='data'),
}

async function updateAlertContactGroupWithOptions(request: UpdateAlertContactGroupRequest, runtime: Util.RuntimeOptions): UpdateAlertContactGroupResponse {
  Util.validateModel(request);
  return doRequest('UpdateAlertContactGroup', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function updateAlertContactGroup(request: UpdateAlertContactGroupRequest): UpdateAlertContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAlertContactGroupWithOptions(request, runtime);
}

model ImportCustomAlertRulesRequest = {
  regionId: string(name='RegionId', description='regionId'),
  contactGroupIds?: string(name='ContactGroupIds', description='contactGroupIds'),
  isAutoStart?: boolean(name='IsAutoStart', description='isAutoStart'),
  templageAlertConfig?: string(name='TemplageAlertConfig', description='templageAlertConfig'),
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
}

model ImportCustomAlertRulesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  data: string(name='Data', description='data'),
}

async function importCustomAlertRulesWithOptions(request: ImportCustomAlertRulesRequest, runtime: Util.RuntimeOptions): ImportCustomAlertRulesResponse {
  Util.validateModel(request);
  return doRequest('ImportCustomAlertRules', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function importCustomAlertRules(request: ImportCustomAlertRulesRequest): ImportCustomAlertRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return importCustomAlertRulesWithOptions(request, runtime);
}

model SearchAlertRulesRequest = {
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
  title?: string(name='Title', description='title'),
  type?: string(name='Type', description='type'),
  currentPage?: integer(name='CurrentPage', description='currentPage'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  regionId: string(name='RegionId', description='regionId'),
  pid?: string(name='Pid', description='pid'),
  appType?: string(name='AppType', description='appType'),
}

model SearchAlertRulesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  pageBean: {
    totalCount: integer(name='TotalCount', description='total'),
    pageNumber: integer(name='PageNumber', description='page'),
    pageSize: integer(name='PageSize', description='pageSize'),
    alertRules: [
      {
        alertTitle: string(name='AlertTitle', description='title'),
        alertLevel: string(name='AlertLevel', description='alertLevel'),
        alertType: integer(name='AlertType', description='alertType'),
        alertVersion: integer(name='AlertVersion', description='alertVersion'),
        config: string(name='Config', description='config'),
        contactGroupIdList: string(name='ContactGroupIdList', description='contactGroupIds'),
        createTime: long(name='CreateTime', description='created'),
        id: long(name='Id', description='id'),
        regionId: string(name='RegionId', description='regionId'),
        status: string(name='Status', description='status'),
        taskId: long(name='TaskId', description='taskId'),
        taskStatus: string(name='TaskStatus', description='taskStatus'),
        updateTime: long(name='UpdateTime', description='updated'),
        userId: string(name='UserId', description='userId'),
        alarmContext: {
          alarmContentTemplate: string(name='AlarmContentTemplate', description='content'),
          alarmContentSubTitle: string(name='AlarmContentSubTitle', description='subTitle'),
        }(name='AlarmContext', description='alarmContext'),
        alertRule: {
          operator: string(name='Operator', description='operator'),
          rules: [
            {
              aggregates: string(name='Aggregates', description='aggregates'),
              alias: string(name='Alias', description='alias'),
              measure: string(name='Measure', description='measure'),
              NValue: integer(name='NValue', description='nValue'),
              operator: string(name='Operator', description='operator'),
              value: float(name='Value', description='value'),
            }
          ](name='Rules', description='rules'),
        }(name='AlertRule', description='alertRule'),
        metricParam: {
          appGroupId: string(name='AppGroupId', description='appGroupId'),
          appId: string(name='AppId', description='appId'),
          pid: string(name='Pid', description='pid'),
          type: string(name='Type', description='type'),
          dimensions: [
            {
              key: string(name='Key', description='key'),
              type: string(name='Type', description='type'),
              value: string(name='Value', description='value'),
            }
          ](name='Dimensions', description='dimensions'),
        }(name='MetricParam', description='metricParam'),
        notice: {
          endTime: long(name='EndTime', description='endTime'),
          noticeEndTime: long(name='NoticeEndTime', description='noticeEndTime'),
          noticeStartTime: long(name='NoticeStartTime', description='noticeStartTime'),
          startTime: long(name='StartTime', description='startTime'),
        }(name='Notice', description='notice'),
        alertWays: [ string ](name='AlertWays', description='alertWay'),
      }
    ](name='AlertRules', description='items'),
  }(name='PageBean', description='data'),
}

async function searchAlertRulesWithOptions(request: SearchAlertRulesRequest, runtime: Util.RuntimeOptions): SearchAlertRulesResponse {
  Util.validateModel(request);
  return doRequest('SearchAlertRules', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function searchAlertRules(request: SearchAlertRulesRequest): SearchAlertRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAlertRulesWithOptions(request, runtime);
}

model DeleteAlertRulesRequest = {
  alertIds: string(name='AlertIds', description='alertIds'),
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
  regionId: string(name='RegionId', description='regionId'),
}

model DeleteAlertRulesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  isSuccess: boolean(name='IsSuccess', description='data'),
}

async function deleteAlertRulesWithOptions(request: DeleteAlertRulesRequest, runtime: Util.RuntimeOptions): DeleteAlertRulesResponse {
  Util.validateModel(request);
  return doRequest('DeleteAlertRules', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function deleteAlertRules(request: DeleteAlertRulesRequest): DeleteAlertRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAlertRulesWithOptions(request, runtime);
}

model CreateRetcodeAppRequest = {
  retcodeAppName: string(name='RetcodeAppName', description='siteName'),
  retcodeAppType: string(name='RetcodeAppType', description='siteType'),
  regionId: string(name='RegionId', description='regionId'),
}

model CreateRetcodeAppResponse = {
  requestId: string(name='RequestId', description='requestId'),
  retcodeAppDataBean: {
    appId: long(name='AppId', description='id'),
    pid: string(name='Pid', description='pid'),
  }(name='RetcodeAppDataBean', description='data'),
}

async function createRetcodeAppWithOptions(request: CreateRetcodeAppRequest, runtime: Util.RuntimeOptions): CreateRetcodeAppResponse {
  Util.validateModel(request);
  return doRequest('CreateRetcodeApp', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function createRetcodeApp(request: CreateRetcodeAppRequest): CreateRetcodeAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRetcodeAppWithOptions(request, runtime);
}

model DeleteRetcodeAppRequest = {
  appId: string(name='AppId', description='appId'),
  regionId: string(name='RegionId', description='regionId'),
}

model DeleteRetcodeAppResponse = {
  requestId: string(name='RequestId', description='requestId'),
  data: string(name='Data', description='data'),
}

async function deleteRetcodeAppWithOptions(request: DeleteRetcodeAppRequest, runtime: Util.RuntimeOptions): DeleteRetcodeAppResponse {
  Util.validateModel(request);
  return doRequest('DeleteRetcodeApp', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function deleteRetcodeApp(request: DeleteRetcodeAppRequest): DeleteRetcodeAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRetcodeAppWithOptions(request, runtime);
}

model QueryDatasetRequest = {
  datasetId: long(name='DatasetId', description='datasetId'),
  intervalInSec: integer(name='IntervalInSec', description='intervalInSec'),
  dateStr?: string(name='DateStr', description='dateStr'),
  minTime: long(name='MinTime', description='minTime'),
  maxTime: long(name='MaxTime', description='maxTime'),
  isDrillDown?: boolean(name='IsDrillDown', description='isDrillDown'),
  orderByKey?: string(name='OrderByKey', description='orderByKey'),
  limit?: integer(name='Limit', description='limit'),
  reduceTail?: boolean(name='ReduceTail', description='reduceTail'),
  hungryMode?: boolean(name='HungryMode', description='hungryMode'),
  measures?: [ string ](name='Measures', description='measures'),
  dimensions?: [
    {
      key?: string(name='Key', description='key'),
      value?: string(name='Value', description='value'),
      type?: string(name='Type', description='type'),
    }
  ](name='Dimensions', description='Dimensions'),
  requiredDims?: [
    {
      key?: string(name='Key', description='key'),
      value?: string(name='Value', description='value'),
      type?: string(name='Type', description='type'),
    }
  ](name='RequiredDims', description='requiredDims'),
  optionalDims?: [
    {
      key?: string(name='Key', description='key'),
      value?: string(name='Value', description='value'),
      type?: string(name='Type', description='type'),
    }
  ](name='OptionalDims', description='optionalDims'),
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
}

model QueryDatasetResponse = {
  requestId: string(name='RequestId', description='requestId'),
  data: string(name='Data', description='data'),
}

async function queryDatasetWithOptions(request: QueryDatasetRequest, runtime: Util.RuntimeOptions): QueryDatasetResponse {
  Util.validateModel(request);
  return doRequest('QueryDataset', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function queryDataset(request: QueryDatasetRequest): QueryDatasetResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDatasetWithOptions(request, runtime);
}

model QueryMetricRequest = {
  intervalInSec?: integer(name='IntervalInSec', description='intervalInSec'),
  startTime: long(name='StartTime', description='startTime'),
  endTime: long(name='EndTime', description='endTime'),
  orderBy?: string(name='OrderBy', description='orderBy'),
  limit?: integer(name='Limit', description='limit'),
  filters?: [
    {
      key?: string(name='Key', description='key'),
      value?: string(name='Value', description='value'),
    }
  ](name='Filters', description='filters'),
  dimensions?: [ string ](name='Dimensions', description='dimensions'),
  metric: string(name='Metric', description='metric'),
  measures: [ string ](name='Measures', description='measures'),
  order?: string(name='Order', description='order'),
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
  consistencyDataKey?: string(name='ConsistencyDataKey', description='consistencyDataKey'),
  consistencyQueryStrategy?: string(name='ConsistencyQueryStrategy', description='consistencyQueryStrategy'),
}

model QueryMetricResponse = {
  requestId: string(name='RequestId', description='requestId'),
  data: string(name='Data', description='data'),
}

async function queryMetricWithOptions(request: QueryMetricRequest, runtime: Util.RuntimeOptions): QueryMetricResponse {
  Util.validateModel(request);
  return doRequest('QueryMetric', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function queryMetric(request: QueryMetricRequest): QueryMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMetricWithOptions(request, runtime);
}

model CreateAlertContactRequest = {
  contactName?: string(name='ContactName', description='name'),
  phoneNum?: string(name='PhoneNum', description='phone'),
  email?: string(name='Email', description='email'),
  dingRobotWebhookUrl?: string(name='DingRobotWebhookUrl', description='dingRobot'),
  systemNoc?: boolean(name='SystemNoc', description='systemNoc'),
  regionId: string(name='RegionId', description='regionId'),
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
}

model CreateAlertContactResponse = {
  requestId: string(name='RequestId', description='requestId'),
  contactId: string(name='ContactId', description='data'),
}

async function createAlertContactWithOptions(request: CreateAlertContactRequest, runtime: Util.RuntimeOptions): CreateAlertContactResponse {
  Util.validateModel(request);
  return doRequest('CreateAlertContact', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function createAlertContact(request: CreateAlertContactRequest): CreateAlertContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAlertContactWithOptions(request, runtime);
}

model CreateAlertContactGroupRequest = {
  contactGroupName: string(name='ContactGroupName', description='name'),
  contactIds?: string(name='ContactIds', description='ids'),
  regionId: string(name='RegionId', description='regionId'),
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
}

model CreateAlertContactGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  contactGroupId: string(name='ContactGroupId', description='data'),
}

async function createAlertContactGroupWithOptions(request: CreateAlertContactGroupRequest, runtime: Util.RuntimeOptions): CreateAlertContactGroupResponse {
  Util.validateModel(request);
  return doRequest('CreateAlertContactGroup', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function createAlertContactGroup(request: CreateAlertContactGroupRequest): CreateAlertContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAlertContactGroupWithOptions(request, runtime);
}

model SearchAlertContactRequest = {
  contactName?: string(name='ContactName', description='name'),
  phone?: string(name='Phone', description='phone'),
  email?: string(name='Email', description='email'),
  currentPage: string(name='CurrentPage', description='currentPage'),
  pageSize: string(name='PageSize', description='pageSize'),
  regionId: string(name='RegionId', description='regionId'),
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
}

model SearchAlertContactResponse = {
  requestId: string(name='RequestId', description='requestId'),
  pageBean: {
    totalCount: integer(name='TotalCount', description='total'),
    pageNumber: integer(name='PageNumber', description='page'),
    pageSize: integer(name='PageSize', description='pageSize'),
    contacts: [
      {
        contactId: long(name='ContactId', description='id'),
        contactName: string(name='ContactName', description='name'),
        phone: string(name='Phone', description='phone'),
        email: string(name='Email', description='email'),
        userId: string(name='UserId', description='ownerName'),
        dingRobot: string(name='DingRobot', description='dingRobot'),
        createTime: long(name='CreateTime', description='createTime'),
        updateTime: long(name='UpdateTime', description='updateTime'),
        systemNoc: boolean(name='SystemNoc', description='systemNoc'),
      }
    ](name='Contacts', description='items'),
  }(name='PageBean', description='data'),
}

async function searchAlertContactWithOptions(request: SearchAlertContactRequest, runtime: Util.RuntimeOptions): SearchAlertContactResponse {
  Util.validateModel(request);
  return doRequest('SearchAlertContact', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function searchAlertContact(request: SearchAlertContactRequest): SearchAlertContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAlertContactWithOptions(request, runtime);
}

model SearchAlertContactGroupRequest = {
  contactGroupName?: string(name='ContactGroupName', description='name'),
  regionId: string(name='RegionId', description='regionId'),
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
  contactName?: string(name='ContactName', description='contactName'),
  contactId?: long(name='ContactId', description='contactId'),
}

model SearchAlertContactGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  contactGroups: [
    {
      contactGroupId: long(name='ContactGroupId', description='id'),
      contactGroupName: string(name='ContactGroupName', description='name'),
      userId: string(name='UserId', description='ownerName'),
      createTime: long(name='CreateTime', description='createTime'),
      updateTime: long(name='UpdateTime', description='updateTime'),
    }
  ](name='ContactGroups', description='data'),
}

async function searchAlertContactGroupWithOptions(request: SearchAlertContactGroupRequest, runtime: Util.RuntimeOptions): SearchAlertContactGroupResponse {
  Util.validateModel(request);
  return doRequest('SearchAlertContactGroup', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function searchAlertContactGroup(request: SearchAlertContactGroupRequest): SearchAlertContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAlertContactGroupWithOptions(request, runtime);
}

model ImportAppAlertRulesRequest = {
  templateAlertId?: string(name='TemplateAlertId', description='templateAlertId'),
  pids: string(name='Pids', description='pids'),
  regionId: string(name='RegionId', description='regionId'),
  contactGroupIds?: string(name='ContactGroupIds', description='contactGroupIds'),
  isAutoStart?: boolean(name='IsAutoStart', description='isAutoStart'),
  templageAlertConfig?: string(name='TemplageAlertConfig', description='templageAlertConfig'),
  proxyUserId?: string(name='ProxyUserId', description='proxyUserId'),
}

model ImportAppAlertRulesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  data: string(name='Data', description='data'),
}

async function importAppAlertRulesWithOptions(request: ImportAppAlertRulesRequest, runtime: Util.RuntimeOptions): ImportAppAlertRulesResponse {
  Util.validateModel(request);
  return doRequest('ImportAppAlertRules', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function importAppAlertRules(request: ImportAppAlertRulesRequest): ImportAppAlertRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return importAppAlertRulesWithOptions(request, runtime);
}

model SearchRetcodeAppByPageRequest = {
  retcodeAppName?: string(name='RetcodeAppName', description='appName'),
  pageNumber?: integer(name='PageNumber', description='currentPage'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  regionId: string(name='RegionId', description='regionId'),
}

model SearchRetcodeAppByPageResponse = {
  requestId: string(name='RequestId', description='requestId'),
  pageBean: {
    totalCount: integer(name='TotalCount', description='total'),
    pageNumber: integer(name='PageNumber', description='page'),
    pageSize: integer(name='PageSize', description='pageSize'),
    retcodeApps: [
      {
        appId: long(name='AppId', description='id'),
        pid: string(name='Pid', description='pid'),
        appName: string(name='AppName', description='appName'),
        type: string(name='Type', description='type'),
        userId: string(name='UserId', description='userId'),
        regionId: string(name='RegionId', description='regionId'),
        createTime: long(name='CreateTime', description='createtime'),
        updateTime: long(name='UpdateTime', description='updatetime'),
      }
    ](name='RetcodeApps', description='items'),
  }(name='PageBean', description='data'),
}

async function searchRetcodeAppByPageWithOptions(request: SearchRetcodeAppByPageRequest, runtime: Util.RuntimeOptions): SearchRetcodeAppByPageResponse {
  Util.validateModel(request);
  return doRequest('SearchRetcodeAppByPage', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function searchRetcodeAppByPage(request: SearchRetcodeAppByPageRequest): SearchRetcodeAppByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchRetcodeAppByPageWithOptions(request, runtime);
}

model SearchTraceAppByNameRequest = {
  traceAppName?: string(name='TraceAppName', description='appName'),
  regionId: string(name='RegionId', description='regionId'),
}

model SearchTraceAppByNameResponse = {
  requestId: string(name='RequestId', description='requestId'),
  traceApps: [
    {
      appId: long(name='AppId', description='id'),
      pid: string(name='Pid', description='pid'),
      appName: string(name='AppName', description='appName'),
      type: string(name='Type', description='type'),
      userId: string(name='UserId', description='userId'),
      regionId: string(name='RegionId', description='regionId'),
      createTime: long(name='CreateTime', description='createtime'),
      updateTime: long(name='UpdateTime', description='updatetime'),
      show: boolean(name='Show', description='show'),
    }
  ](name='TraceApps', description='data'),
}

async function searchTraceAppByNameWithOptions(request: SearchTraceAppByNameRequest, runtime: Util.RuntimeOptions): SearchTraceAppByNameResponse {
  Util.validateModel(request);
  return doRequest('SearchTraceAppByName', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function searchTraceAppByName(request: SearchTraceAppByNameRequest): SearchTraceAppByNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTraceAppByNameWithOptions(request, runtime);
}

model SearchTraceAppByPageRequest = {
  traceAppName?: string(name='TraceAppName', description='appName'),
  pageNumber?: integer(name='PageNumber', description='currentPage'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  regionId: string(name='RegionId', description='regionId'),
}

model SearchTraceAppByPageResponse = {
  requestId: string(name='RequestId', description='requestId'),
  pageBean: {
    totalCount: integer(name='TotalCount', description='total'),
    pageNumber: integer(name='PageNumber', description='page'),
    pageSize: integer(name='PageSize', description='pageSize'),
    traceApps: [
      {
        appId: long(name='AppId', description='id'),
        pid: string(name='Pid', description='pid'),
        appName: string(name='AppName', description='appName'),
        type: string(name='Type', description='type'),
        userId: string(name='UserId', description='userId'),
        regionId: string(name='RegionId', description='regionId'),
        createTime: long(name='CreateTime', description='createtime'),
        updateTime: long(name='UpdateTime', description='updatetime'),
        show: boolean(name='Show', description='show'),
      }
    ](name='TraceApps', description='items'),
  }(name='PageBean', description='data'),
}

async function searchTraceAppByPageWithOptions(request: SearchTraceAppByPageRequest, runtime: Util.RuntimeOptions): SearchTraceAppByPageResponse {
  Util.validateModel(request);
  return doRequest('SearchTraceAppByPage', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function searchTraceAppByPage(request: SearchTraceAppByPageRequest): SearchTraceAppByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTraceAppByPageWithOptions(request, runtime);
}

model ListRetcodeAppsRequest = {
  securityToken?: string(name='SecurityToken', description='securityToken'),
  regionId: string(name='RegionId', description='regionId'),
}

model ListRetcodeAppsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  retcodeApps: [
    {
      appId: long(name='AppId', description='appId'),
      pid: string(name='Pid', description='pid'),
      appName: string(name='AppName', description='siteName'),
    }
  ](name='RetcodeApps', description='data'),
}

async function listRetcodeAppsWithOptions(request: ListRetcodeAppsRequest, runtime: Util.RuntimeOptions): ListRetcodeAppsResponse {
  Util.validateModel(request);
  return doRequest('ListRetcodeApps', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function listRetcodeApps(request: ListRetcodeAppsRequest): ListRetcodeAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRetcodeAppsWithOptions(request, runtime);
}

model ListTraceAppsRequest = {
  regionId: string(name='RegionId', description='regionId'),
}

model ListTraceAppsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
  traceApps: [
    {
      appId: long(name='AppId', description='id'),
      pid: string(name='Pid', description='pid'),
      appName: string(name='AppName', description='appName'),
      type: string(name='Type', description='type'),
      userId: string(name='UserId', description='userId'),
      createTime: long(name='CreateTime', description='createtime'),
      updateTime: long(name='UpdateTime', description='updatetime'),
      regionId: string(name='RegionId', description='regionId'),
      show: boolean(name='Show', description='show'),
    }
  ](name='TraceApps', description='data'),
}

async function listTraceAppsWithOptions(request: ListTraceAppsRequest, runtime: Util.RuntimeOptions): ListTraceAppsResponse {
  Util.validateModel(request);
  return doRequest('ListTraceApps', 'HTTPS', 'POST', '2019-08-08', 'AK', null, request, runtime);
}

async function listTraceApps(request: ListTraceAppsRequest): ListTraceAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTraceAppsWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
