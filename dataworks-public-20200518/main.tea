import Util;
import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'dataworks.ap-northeast-1.aliyuncs.com',
    ap-south-1 = 'dataworks.ap-south-1.aliyuncs.com',
    ap-southeast-1 = 'dataworks.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'dataworks.ap-southeast-2.aliyuncs.com',
    ap-southeast-3 = 'dataworks.ap-southeast-3.aliyuncs.com',
    ap-southeast-5 = 'dataworks.ap-southeast-5.aliyuncs.com',
    cn-beijing = 'dataworks.cn-beijing.aliyuncs.com',
    cn-chengdu = 'dataworks.cn-chengdu.aliyuncs.com',
    cn-hangzhou = 'dataworks.cn-hangzhou.aliyuncs.com',
    cn-hongkong = 'dataworks.cn-hongkong.aliyuncs.com',
    cn-huhehaote = 'dataworks.aliyuncs.com',
    cn-qingdao = 'dataworks.aliyuncs.com',
    cn-shanghai = 'dataworks.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'dataworks.cn-shenzhen.aliyuncs.com',
    cn-zhangjiakou = 'dataworks.aliyuncs.com',
    eu-central-1 = 'dataworks.eu-central-1.aliyuncs.com',
    eu-west-1 = 'dataworks.eu-west-1.aliyuncs.com',
    me-east-1 = 'dataworks.me-east-1.aliyuncs.com',
    us-east-1 = 'dataworks.us-east-1.aliyuncs.com',
    us-west-1 = 'dataworks.us-west-1.aliyuncs.com',
    cn-hangzhou-finance = 'dataworks.aliyuncs.com',
    cn-shenzhen-finance-1 = 'dataworks.aliyuncs.com',
    cn-shanghai-finance-1 = 'dataworks.aliyuncs.com',
    cn-north-2-gov-1 = 'dataworks.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('dataworks-public', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model CreateDagComplementRequest = {
  projectEnv: string(name='ProjectEnv', description='projectEnv'),
  startBizDate: string(name='StartBizDate', description='startBizDate'),
  name: string(name='Name', description='name'),
  rootNodeId: long(name='RootNodeId', description='rootNodeId'),
  includeNodeIds: string(name='IncludeNodeIds', description='includeNodeIds'),
  excludeNodeIds?: string(name='ExcludeNodeIds', description='excludeNodeIds'),
  bizBeginTime?: string(name='BizBeginTime', description='bizBeginTime'),
  bizEndTime?: string(name='BizEndTime', description='bizEndTime'),
  parallelism: boolean(name='Parallelism', description='parallelism'),
  endBizDate: string(name='EndBizDate', description='endBizDate'),
  nodeParams?: string(name='NodeParams', description='nodeParams'),
}

model CreateDagComplementResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  data: [ long ] (name='Data', description='data'),
}

async function createDagComplementWithOptions(request: CreateDagComplementRequest, runtime: Util.RuntimeOptions): CreateDagComplementResponse {
  Util.validateModel(request);
  return doRequest('CreateDagComplement', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createDagComplement(request: CreateDagComplementRequest): CreateDagComplementResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDagComplementWithOptions(request, runtime);
}

model CreateDagTestRequest = {
  projectEnv: string(name='ProjectEnv', description='projectEnv'),
  bizdate: string(name='Bizdate', description='bizdate'),
  name: string(name='Name', description='name'),
  nodeId: long(name='NodeId', description='nodeId'),
  nodeParams?: string(name='NodeParams', description='nodeParams'),
}

model CreateDagTestResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  data: long(name='Data', description='data'),
}

async function createDagTestWithOptions(request: CreateDagTestRequest, runtime: Util.RuntimeOptions): CreateDagTestResponse {
  Util.validateModel(request);
  return doRequest('CreateDagTest', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createDagTest(request: CreateDagTestRequest): CreateDagTestResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDagTestWithOptions(request, runtime);
}

model ListCalcEnginesRequest = {
  projectId: long(name='ProjectId', description='projectId'),
  name?: string(name='Name', description='name'),
  calcEngineType: string(name='CalcEngineType', description='type'),
  envType?: string(name='EnvType', description='envType'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  pageNumber?: integer(name='PageNumber', description='pageNum'),
}

model ListCalcEnginesResponse = {
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNumber'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: integer(name='TotalCount', description='totalCount'),
    calcEngines: [
      {
        calcEngineType: string(name='CalcEngineType', description='type'),
        gmtCreate: string(name='GmtCreate', description='gmtCreate'),
        dwRegion: string(name='DwRegion', description='dwRegion'),
        isDefault: boolean(name='IsDefault', description='isDefault'),
        bindingProjectId: integer(name='BindingProjectId', description='bindingProjectId'),
        envType: string(name='EnvType', description='envType'),
        tenantId: long(name='TenantId', description='tenantId'),
        name: string(name='Name', description='name'),
        bindingProjectName: string(name='BindingProjectName', description='bindingProjectName'),
        region: string(name='Region', description='region'),
        engineId: integer(name='EngineId', description='engineId'),
        engineInfo: map[string]any(name='EngineInfo', description='engineInfo'),
        taskAuthType: string(name='TaskAuthType', description='taskAuthType'),
      }
    ](name='CalcEngines', description='data'),
  }(name='Data', description='data'),
}

async function listCalcEnginesWithOptions(request: ListCalcEnginesRequest, runtime: Util.RuntimeOptions): ListCalcEnginesResponse {
  Util.validateModel(request);
  return doRequest('ListCalcEngines', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listCalcEngines(request: ListCalcEnginesRequest): ListCalcEnginesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCalcEnginesWithOptions(request, runtime);
}

model ListConnectionsRequest = {
  projectId: long(name='ProjectId', description='projectId'),
  name?: string(name='Name', description='name'),
  connectionType?: string(name='ConnectionType', description='type'),
  subType?: string(name='SubType', description='subType'),
  status?: string(name='Status', description='status'),
  envType?: integer(name='EnvType', description='envType'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  pageNumber?: integer(name='PageNumber', description='pageNum'),
}

model ListConnectionsResponse = {
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNumber'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: integer(name='TotalCount', description='totalCount'),
    connections: [
      {
        shared: boolean(name='Shared', description='shared'),
        gmtModified: string(name='GmtModified', description='gmtModified'),
        connectStatus: integer(name='ConnectStatus', description='connectStatus'),
        bindingCalcEngineId: integer(name='BindingCalcEngineId', description='bindingCalcEngineId'),
        description: string(name='Description', description='description'),
        connectionType: string(name='ConnectionType', description='type'),
        gmtCreate: string(name='GmtCreate', description='gmtCreate'),
        defaultEngine: boolean(name='DefaultEngine', description='defaultEngine'),
        operator: string(name='Operator', description='operator'),
        sequence: integer(name='Sequence', description='sequence'),
        envType: integer(name='EnvType', description='envType'),
        tenantId: long(name='TenantId', description='tenantId'),
        name: string(name='Name', description='name'),
        subType: string(name='SubType', description='subType'),
        id: integer(name='Id', description='id'),
        projectId: integer(name='ProjectId', description='projectId'),
        status: integer(name='Status', description='status'),
        content: string(name='Content', description='connection'),
      }
    ](name='Connections', description='data'),
  }(name='Data', description='data'),
}

async function listConnectionsWithOptions(request: ListConnectionsRequest, runtime: Util.RuntimeOptions): ListConnectionsResponse {
  Util.validateModel(request);
  return doRequest('ListConnections', 'HTTPS', 'GET', '2020-05-18', 'AK', request, null, runtime);
}

async function listConnections(request: ListConnectionsRequest): ListConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listConnectionsWithOptions(request, runtime);
}

model UpdateConnectionRequest = {
  description?: string(name='Description', description='description'),
  envType?: integer(name='EnvType', description='envType'),
  content?: string(name='Content', description='content'),
  status?: string(name='Status', description='status'),
  connectionId: long(name='ConnectionId', description='connectionId'),
}

model UpdateConnectionResponse = {
  success: boolean(name='Success', description='success'),
  httpStatusCode: string(name='HttpStatusCode', description='httpStatusCode'),
  data: boolean(name='Data', description='data'),
  requestId: string(name='RequestId', description='requestId'),
}

async function updateConnectionWithOptions(request: UpdateConnectionRequest, runtime: Util.RuntimeOptions): UpdateConnectionResponse {
  Util.validateModel(request);
  return doRequest('UpdateConnection', 'HTTPS', 'PUT', '2020-05-18', 'AK', null, request, runtime);
}

async function updateConnection(request: UpdateConnectionRequest): UpdateConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateConnectionWithOptions(request, runtime);
}

model DeleteConnectionRequest = {
  connectionId: long(name='ConnectionId', description='connectionId'),
}

model DeleteConnectionResponse = {
  success: boolean(name='Success', description='success'),
  httpStatusCode: string(name='HttpStatusCode', description='httpStatusCode'),
  data: boolean(name='Data', description='data'),
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteConnectionWithOptions(request: DeleteConnectionRequest, runtime: Util.RuntimeOptions): DeleteConnectionResponse {
  Util.validateModel(request);
  return doRequest('DeleteConnection', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteConnection(request: DeleteConnectionRequest): DeleteConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteConnectionWithOptions(request, runtime);
}

model GetProjectDetailRequest = {
  projectId: long(name='ProjectId', description='projectId'),
}

model GetProjectDetailResponse = {
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    gmtModified: string(name='GmtModified', description='gmtModified'),
    defaultDiResourceGroupIdentifier: string(name='DefaultDiResourceGroupIdentifier', description='defaultDiResourceGroupIdentifier'),
    isAllowDownload: integer(name='IsAllowDownload', description='isAllowDownload'),
    schedulerRetryInterval: integer(name='SchedulerRetryInterval', description='schedulerRetryInterval'),
    residentArea: string(name='ResidentArea', description='residentArea'),
    projectOwnerBaseId: string(name='ProjectOwnerBaseId', description='projectOwnerBaseId'),
    projectMode: integer(name='ProjectMode', description='projectMode'),
    gmtCreate: string(name='GmtCreate', description='gmtCreate'),
    protectedMode: integer(name='ProtectedMode', description='protectedMode'),
    tenantId: long(name='TenantId', description='tenantId'),
    projectDescription: string(name='ProjectDescription', description='projectDesc'),
    schedulerMaxRetryTimes: integer(name='SchedulerMaxRetryTimes', description='schedulerMaxRetryTimes'),
    projectName: string(name='ProjectName', description='projectName'),
    projectIdentifier: string(name='ProjectIdentifier', description='projectIdentifier'),
    projectId: integer(name='ProjectId', description='projectId'),
    status: integer(name='Status', description='status'),
    developmentType: integer(name='DevelopmentType', description='developmentType'),
    envTypes: [ string ](name='EnvTypes', description='envTypes'),
  }(name='Data', description='data'),
}

async function getProjectDetailWithOptions(request: GetProjectDetailRequest, runtime: Util.RuntimeOptions): GetProjectDetailResponse {
  Util.validateModel(request);
  return doRequest('GetProjectDetail', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getProjectDetail(request: GetProjectDetailRequest): GetProjectDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProjectDetailWithOptions(request, runtime);
}

model ListResourceGroupsRequest = {
  resourceGroupType: integer(name='ResourceGroupType', description='type'),
  keyword?: string(name='Keyword', description='keyword'),
}

model ListResourceGroupsResponse = {
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  data: [
    {
      identifier: string(name='Identifier', description='identifier'),
      cluster: string(name='Cluster', description='cluster'),
      bizExtKey: string(name='BizExtKey', description='bizExtKey'),
      enableKp: boolean(name='EnableKp', description='enableKp'),
      updateTime: string(name='UpdateTime', description='updateTime'),
      resourceGroupType: string(name='ResourceGroupType', description='type'),
      mode: string(name='Mode', description='mode'),
      sequence: integer(name='Sequence', description='sequence'),
      isDefault: boolean(name='IsDefault', description='isDefault'),
      createTime: string(name='CreateTime', description='createTime'),
      name: string(name='Name', description='name'),
      tenantId: long(name='TenantId', description='tenantId'),
      id: long(name='Id', description='id'),
      status: integer(name='Status', description='status'),
      specs: map[string]any(name='Specs', description='specs'),
    }
  ](name='Data', description='data'),
}

async function listResourceGroupsWithOptions(request: ListResourceGroupsRequest, runtime: Util.RuntimeOptions): ListResourceGroupsResponse {
  Util.validateModel(request);
  return doRequest('ListResourceGroups', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listResourceGroups(request: ListResourceGroupsRequest): ListResourceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceGroupsWithOptions(request, runtime);
}

model CreateConnectionRequest = {
  projectId: long(name='ProjectId', description='projectId'),
  name: string(name='Name', description='name'),
  description?: string(name='Description', description='description'),
  connectionType: string(name='ConnectionType', description='type'),
  subType?: string(name='SubType', description='subType'),
  envType: integer(name='EnvType', description='envType'),
  content: string(name='Content', description='content'),
}

model CreateConnectionResponse = {
  success: boolean(name='Success', description='success'),
  httpStatusCode: string(name='HttpStatusCode', description='httpStatusCode'),
  data: long(name='Data', description='data'),
  requestId: string(name='RequestId', description='requestId'),
}

async function createConnectionWithOptions(request: CreateConnectionRequest, runtime: Util.RuntimeOptions): CreateConnectionResponse {
  Util.validateModel(request);
  return doRequest('CreateConnection', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createConnection(request: CreateConnectionRequest): CreateConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createConnectionWithOptions(request, runtime);
}

model GetDataServiceApplicationRequest = {
  tenantId: long(name='TenantId', description='tenantId'),
  projectId: long(name='ProjectId', description='projectId'),
  applicationId: long(name='ApplicationId', description='appId'),
}

model GetDataServiceApplicationResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  data: {
    applicationCode: string(name='ApplicationCode', description='appCode'),
    applicationId: long(name='ApplicationId', description='appId'),
    applicationKey: string(name='ApplicationKey', description='appKey'),
    applicationName: string(name='ApplicationName', description='appName'),
    applicationSecret: string(name='ApplicationSecret', description='appSecret'),
    projectId: long(name='ProjectId', description='projectId'),
  }(name='Data', description='data'),
}

async function getDataServiceApplicationWithOptions(request: GetDataServiceApplicationRequest, runtime: Util.RuntimeOptions): GetDataServiceApplicationResponse {
  Util.validateModel(request);
  return doRequest('GetDataServiceApplication', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getDataServiceApplication(request: GetDataServiceApplicationRequest): GetDataServiceApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataServiceApplicationWithOptions(request, runtime);
}

model ListDataServiceApplicationsRequest = {
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  projectIdList: string(name='ProjectIdList', description='projectIdsStr'),
  tenantId: long(name='TenantId', description='tenantId'),
}

model ListDataServiceApplicationsResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNumber'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: integer(name='TotalCount', description='totalCount'),
    applications: [
      {
        applicationId: long(name='ApplicationId', description='appId'),
        applicationName: string(name='ApplicationName', description='appName'),
        projectId: long(name='ProjectId', description='projectId'),
      }
    ](name='Applications', description='data'),
  }(name='Data', description='data'),
}

async function listDataServiceApplicationsWithOptions(request: ListDataServiceApplicationsRequest, runtime: Util.RuntimeOptions): ListDataServiceApplicationsResponse {
  Util.validateModel(request);
  return doRequest('ListDataServiceApplications', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listDataServiceApplications(request: ListDataServiceApplicationsRequest): ListDataServiceApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServiceApplicationsWithOptions(request, runtime);
}

model GetNodeOnBaselineRequest = {
  baselineId: long(name='BaselineId', description='baselineId'),
}

model GetNodeOnBaselineResponse = {
  success: string(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: [
    {
      nodeId: long(name='NodeId', description='nodeId'),
      nodeName: string(name='NodeName', description='nodeName'),
      owner: string(name='Owner', description='owner'),
      projectId: long(name='ProjectId', description='projectId'),
    }
  ](name='Data', description='data'),
}

async function getNodeOnBaselineWithOptions(request: GetNodeOnBaselineRequest, runtime: Util.RuntimeOptions): GetNodeOnBaselineResponse {
  Util.validateModel(request);
  return doRequest('GetNodeOnBaseline', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getNodeOnBaseline(request: GetNodeOnBaselineRequest): GetNodeOnBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNodeOnBaselineWithOptions(request, runtime);
}

model ListBaselineConfigsRequest = {
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  owner?: string(name='Owner', description='owner'),
  projectId: long(name='ProjectId', description='projectId'),
  priority?: string(name='Priority', description='priority'),
  useflag?: boolean(name='Useflag', description='useflag'),
  baselineTypes?: string(name='BaselineTypes', description='baselineTypes'),
  searchText?: string(name='SearchText', description='searchText'),
}

model ListBaselineConfigsResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNumber'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: integer(name='TotalCount', description='totalCount'),
    baselines: [
      {
        baselineId: long(name='BaselineId', description='baselineId'),
        priority: integer(name='Priority', description='priority'),
        baselineName: string(name='BaselineName', description='baselineName'),
        owner: string(name='Owner', description='owner'),
        projectId: long(name='ProjectId', description='projectId'),
        useFlag: boolean(name='UseFlag', description='useFlag'),
        baselineType: string(name='BaselineType', description='baselineType'),
        expHour: integer(name='ExpHour', description='expHour'),
        expMinu: integer(name='ExpMinu', description='expMinu'),
        slaHour: integer(name='SlaHour', description='slaHour'),
        slaMinu: integer(name='SlaMinu', description='SlaMinu'),
        hourExpDetail: string(name='HourExpDetail', description='hourExpDetail'),
        hourSlaDetail: string(name='HourSlaDetail', description='hourSlaDetail'),
        isDefault: boolean(name='IsDefault', description='isDefault'),
      }
    ](name='Baselines', description='data'),
  }(name='Data', description='data'),
}

async function listBaselineConfigsWithOptions(request: ListBaselineConfigsRequest, runtime: Util.RuntimeOptions): ListBaselineConfigsResponse {
  Util.validateModel(request);
  return doRequest('ListBaselineConfigs', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listBaselineConfigs(request: ListBaselineConfigsRequest): ListBaselineConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBaselineConfigsWithOptions(request, runtime);
}

model GetMetaTableChangeLogRequest = {
  pageNumber?: integer(name='PageNumber', description='pageNum'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  tableGuid: string(name='TableGuid', description='tableGuid'),
  changeType?: string(name='ChangeType', description='changeType'),
  objectType?: string(name='ObjectType', description='objectType'),
  startDate?: string(name='StartDate', description='startDate'),
  endDate?: string(name='EndDate', description='endDate'),
}

model GetMetaTableChangeLogResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNum'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: long(name='TotalCount', description='totalNum'),
    dataEntityList: [
      {
        createTime: long(name='CreateTime', description='createTimestamp'),
        modifiedTime: long(name='ModifiedTime', description='modifiedTimestamp'),
        changeType: string(name='ChangeType', description='changeType'),
        operator: string(name='Operator', description='operator'),
        objectType: string(name='ObjectType', description='objectType'),
        changeContent: string(name='ChangeContent', description='changeContent'),
      }
    ](name='DataEntityList', description='data'),
  }(name='Data', description='data'),
}

async function getMetaTableChangeLogWithOptions(request: GetMetaTableChangeLogRequest, runtime: Util.RuntimeOptions): GetMetaTableChangeLogResponse {
  Util.validateModel(request);
  return doRequest('GetMetaTableChangeLog', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getMetaTableChangeLog(request: GetMetaTableChangeLogRequest): GetMetaTableChangeLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableChangeLogWithOptions(request, runtime);
}

model GetMetaTableOutputRequest = {
  pageNumber?: integer(name='PageNumber', description='pageNum'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  tableGuid: string(name='TableGuid', description='tableGuid'),
  startDate: string(name='StartDate', description='startDate'),
  endDate: string(name='EndDate', description='endDate'),
}

model GetMetaTableOutputResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNum'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: long(name='TotalCount', description='totalNum'),
    dataEntityList: [
      {
        tableGuid: string(name='TableGuid', description='tableGuid'),
        taskId: string(name='TaskId', description='taskId'),
        startTime: string(name='StartTime', description='startTime'),
        endTime: string(name='EndTime', description='endTime'),
        waitTime: string(name='WaitTime', description='waitTime'),
        projectId: long(name='ProjectId', description='projectId'),
        taskInstanceId: long(name='TaskInstanceId', description='taskInstId'),
      }
    ](name='DataEntityList', description='data'),
  }(name='Data', description='data'),
}

async function getMetaTableOutputWithOptions(request: GetMetaTableOutputRequest, runtime: Util.RuntimeOptions): GetMetaTableOutputResponse {
  Util.validateModel(request);
  return doRequest('GetMetaTableOutput', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getMetaTableOutput(request: GetMetaTableOutputRequest): GetMetaTableOutputResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableOutputWithOptions(request, runtime);
}

model GetMetaTablePartitionRequest = {
  pageNumber?: integer(name='PageNumber', description='pageNum'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  tableGuid: string(name='TableGuid', description='tableGuid'),
}

model GetMetaTablePartitionResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNum'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: long(name='TotalCount', description='totalNum'),
    dataEntityList: [
      {
        partitionGuid: string(name='PartitionGuid', description='partitionGuid'),
        partitionName: string(name='PartitionName', description='name'),
        createTime: long(name='CreateTime', description='createTimestamp'),
        dataSize: long(name='DataSize', description='dataSize'),
        recordCount: long(name='RecordCount', description='recordCount'),
        modifiedTime: long(name='ModifiedTime', description='modifiedTimestamp'),
        tableGuid: string(name='TableGuid', description='tableGuid'),
      }
    ](name='DataEntityList', description='data'),
  }(name='Data', description='data'),
}

async function getMetaTablePartitionWithOptions(request: GetMetaTablePartitionRequest, runtime: Util.RuntimeOptions): GetMetaTablePartitionResponse {
  Util.validateModel(request);
  return doRequest('GetMetaTablePartition', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getMetaTablePartition(request: GetMetaTablePartitionRequest): GetMetaTablePartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTablePartitionWithOptions(request, runtime);
}

model GetMetaTableFullInfoRequest = {
  tableGuid: string(name='TableGuid', description='tableGuid'),
  pageNum?: integer(name='PageNum', description='pageNum'),
  pageSize?: integer(name='PageSize', description='pageSize'),
}

model GetMetaTableFullInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: {
    tableName: string(name='TableName', description='tableName'),
    tableGuid: string(name='TableGuid', description='tableGuid'),
    ownerId: string(name='OwnerId', description='ownerId'),
    tenantId: long(name='TenantId', description='tenantId'),
    projectId: long(name='ProjectId', description='projectId'),
    createTime: long(name='CreateTime', description='createTime'),
    lastModifyTime: long(name='LastModifyTime', description='lastModifyTime'),
    lifeCycle: integer(name='LifeCycle', description='lifeCycle'),
    isVisible: integer(name='IsVisible', description='isVisible'),
    projectName: string(name='ProjectName', description='projectName'),
    dataSize: long(name='DataSize', description='dataSize'),
    envType: integer(name='EnvType', description='envType'),
    comment: string(name='Comment', description='comment'),
    totalColumnCount: long(name='TotalColumnCount', description='totalColumnCount'),
    lastDdlTime: long(name='LastDdlTime', description='lastDdlTime'),
    lastAccessTime: long(name='LastAccessTime', description='lastAccessTime'),
    columnList: [
      {
        columnGuid: string(name='ColumnGuid', description='uuid'),
        columnName: string(name='ColumnName', description='name'),
        columnType: string(name='ColumnType', description='type'),
        isPrimaryKey: boolean(name='IsPrimaryKey', description='isPk'),
        comment: string(name='Comment', description='comment'),
        isPartitionColumn: boolean(name='IsPartitionColumn', description='isPartitionColumn'),
        isForeignKey: boolean(name='IsForeignKey', description='isForeignKey'),
        caption: string(name='Caption', description='caption'),
      }
    ](name='ColumnList', description='columnList'),
  }(name='Data', description='data'),
}

async function getMetaTableFullInfoWithOptions(request: GetMetaTableFullInfoRequest, runtime: Util.RuntimeOptions): GetMetaTableFullInfoResponse {
  Util.validateModel(request);
  return doRequest('GetMetaTableFullInfo', 'HTTPS', 'GET', '2020-05-18', 'AK', request, null, runtime);
}

async function getMetaTableFullInfo(request: GetMetaTableFullInfoRequest): GetMetaTableFullInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableFullInfoWithOptions(request, runtime);
}

model GetFileVersionRequest = {
  fileId: long(name='FileId', description='FileId'),
  projectId?: long(name='ProjectId', description='projectId'),
  projectIdentifier?: string(name='ProjectIdentifier', description='ProjectIdentifier'),
  fileVersion: integer(name='FileVersion', description='FileVersion'),
}

model GetFileVersionResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  data: {
    fileVersion: integer(name='FileVersion', description='fileVersion'),
    fileContent: string(name='FileContent', description='fileContent'),
    filePropertyContent: string(name='FilePropertyContent', description='filePropertyContent'),
    nodeContent: string(name='NodeContent', description='nodeContent'),
    comment: string(name='Comment', description='comment'),
    nodeId: long(name='NodeId', description='cloudUuid'),
    isCurrentProd: boolean(name='IsCurrentProd', description='isCurrentProd'),
    changeType: string(name='ChangeType', description='changeType'),
    status: string(name='Status', description='status'),
    fileName: string(name='FileName', description='fileName'),
    commitUser: string(name='CommitUser', description='commitUser'),
    commitTime: long(name='CommitTime', description='commitTime'),
    useType: string(name='UseType', description='useType'),
  }(name='Data', description='data'),
}

async function getFileVersionWithOptions(request: GetFileVersionRequest, runtime: Util.RuntimeOptions): GetFileVersionResponse {
  Util.validateModel(request);
  return doRequest('GetFileVersion', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getFileVersion(request: GetFileVersionRequest): GetFileVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileVersionWithOptions(request, runtime);
}

model GetMetaTableBasicInfoRequest = {
  tableGuid: string(name='TableGuid', description='tableGuid'),
}

model GetMetaTableBasicInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: {
    tableName: string(name='TableName', description='name'),
    tableGuid: string(name='TableGuid', description='tableGuid'),
    ownerId: string(name='OwnerId', description='ownerId'),
    tenantId: long(name='TenantId', description='tenantId'),
    projectId: long(name='ProjectId', description='projectId'),
    createTime: long(name='CreateTime', description='createTime'),
    lastModifyTime: long(name='LastModifyTime', description='lastModifyTime'),
    lifeCycle: integer(name='LifeCycle', description='lifeCycle'),
    isVisible: integer(name='IsVisible', description='isVisible'),
    lastDdlTime: long(name='LastDdlTime', description='lastDdlTime'),
    lastAccessTime: long(name='LastAccessTime', description='lastAccessTime'),
    envType: integer(name='EnvType', description='envType'),
    dataSize: long(name='DataSize', description='dataSize'),
    comment: string(name='Comment', description='comment'),
    projectName: string(name='ProjectName', description='projectName'),
  }(name='Data', description='data'),
}

async function getMetaTableBasicInfoWithOptions(request: GetMetaTableBasicInfoRequest, runtime: Util.RuntimeOptions): GetMetaTableBasicInfoResponse {
  Util.validateModel(request);
  return doRequest('GetMetaTableBasicInfo', 'HTTPS', 'GET', '2020-05-18', 'AK', request, null, runtime);
}

async function getMetaTableBasicInfo(request: GetMetaTableBasicInfoRequest): GetMetaTableBasicInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableBasicInfoWithOptions(request, runtime);
}

model GetMetaTableColumnRequest = {
  tableGuid: string(name='TableGuid', description='tableGuid'),
  pageNum?: integer(name='PageNum', description='pageNum'),
  pageSize?: integer(name='PageSize', description='pageSize'),
}

model GetMetaTableColumnResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: {
    totalCount: long(name='TotalCount', description='totalNum'),
    pageNum: integer(name='PageNum', description='pageNum'),
    pageSize: integer(name='PageSize', description='pageSize'),
    columnList: [
      {
        columnName: string(name='ColumnName', description='name'),
        columnGuid: string(name='ColumnGuid', description='uuid'),
        comment: string(name='Comment', description='comment'),
        isPrimaryKey: boolean(name='IsPrimaryKey', description='isPk'),
        columnType: string(name='ColumnType', description='type'),
        isPartitionColumn: boolean(name='IsPartitionColumn', description='isPartitionColumn'),
        isForeignKey: boolean(name='IsForeignKey', description='isForeignKey'),
        caption: string(name='Caption', description='caption'),
      }
    ](name='ColumnList', description='data'),
  }(name='Data', description='data'),
}

async function getMetaTableColumnWithOptions(request: GetMetaTableColumnRequest, runtime: Util.RuntimeOptions): GetMetaTableColumnResponse {
  Util.validateModel(request);
  return doRequest('GetMetaTableColumn', 'HTTPS', 'GET', '2020-05-18', 'AK', request, null, runtime);
}

async function getMetaTableColumn(request: GetMetaTableColumnRequest): GetMetaTableColumnResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableColumnWithOptions(request, runtime);
}

model GetMetaDBInfoRequest = {
  appGuid: string(name='AppGuid', description='appGuid'),
}

model GetMetaDBInfoResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  data: {
    appGuid: string(name='AppGuid', description='appGuid'),
    tenantId: long(name='TenantId', description='tenantId'),
    endpoint: string(name='Endpoint', description='endpoint'),
    projectId: long(name='ProjectId', description='projectId'),
    envType: integer(name='EnvType', description='envType'),
    projectName: string(name='ProjectName', description='projectName'),
    projectNameCn: string(name='ProjectNameCn', description='projectNameCn'),
    createTime: long(name='CreateTime', description='createTimestamp'),
    modifyTime: long(name='ModifyTime', description='modifiedTimestamp'),
    ownerId: string(name='OwnerId', description='ownerId'),
    ownerName: string(name='OwnerName', description='ownerName'),
  }(name='Data', description='data'),
}

async function getMetaDBInfoWithOptions(request: GetMetaDBInfoRequest, runtime: Util.RuntimeOptions): GetMetaDBInfoResponse {
  Util.validateModel(request);
  return doRequest('GetMetaDBInfo', 'HTTPS', 'GET', '2020-05-18', 'AK', request, null, runtime);
}

async function getMetaDBInfo(request: GetMetaDBInfoRequest): GetMetaDBInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaDBInfoWithOptions(request, runtime);
}

model GetMetaCategoryRequest = {
  parentCategoryId?: long(name='ParentCategoryId', description='parentId'),
  pageNum?: integer(name='PageNum', description='pageNum'),
  pageSize?: integer(name='PageSize', description='pageSize'),
}

model GetMetaCategoryResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: {
    pageNum: integer(name='PageNum', description='pageNum'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: long(name='TotalCount', description='totalCount'),
    dataEntityList: [
      {
        categoryId: long(name='CategoryId', description='id'),
        name: string(name='Name', description='name'),
        createTime: long(name='CreateTime', description='createTimestamp'),
        modifiedTime: long(name='ModifiedTime', description='modifiedTimestamp'),
        comment: string(name='Comment', description='comment'),
        ownerId: string(name='OwnerId', description='ownerId'),
        lastOperatorId: string(name='LastOperatorId', description='lastOperatorId'),
        parentCategoryId: long(name='ParentCategoryId', description='pid'),
        depth: integer(name='Depth', description='depth'),
      }
    ](name='DataEntityList', description='data'),
  }(name='Data', description='data'),
}

async function getMetaCategoryWithOptions(request: GetMetaCategoryRequest, runtime: Util.RuntimeOptions): GetMetaCategoryResponse {
  Util.validateModel(request);
  return doRequest('GetMetaCategory', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getMetaCategory(request: GetMetaCategoryRequest): GetMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaCategoryWithOptions(request, runtime);
}

model ListAlertMessagesRequest = {
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  beginTime: string(name='BeginTime', description='beginTime'),
  endTime: string(name='EndTime', description='endTime'),
  remindId?: long(name='RemindId', description='remindId'),
  alertMethods?: string(name='AlertMethods', description='alertMethods'),
  alertUser?: string(name='AlertUser', description='alertUser'),
  alertRuleTypes?: string(name='AlertRuleTypes', description='alertRuleTypes'),
}

model ListAlertMessagesResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    pageNumber: string(name='PageNumber', description='pageNumber'),
    pageSize: string(name='PageSize', description='pageSize'),
    totalCount: string(name='TotalCount', description='totalCount'),
    alertMessages: [
      {
        alertId: long(name='AlertId', description='alertId'),
        alertTime: long(name='AlertTime', description='alertTime'),
        source: string(name='Source', description='source'),
        remindId: long(name='RemindId', description='remindId'),
        remindName: string(name='RemindName', description='remindName'),
        alertUser: string(name='AlertUser', description='alertUser'),
        alertMethod: string(name='AlertMethod', description='alertMethod'),
        alertMessageStatus: string(name='AlertMessageStatus', description='alertMessageStatus'),
        content: string(name='Content', description='content'),
        instances: [
          {
            nodeId: long(name='NodeId', description='nodeId'),
            nodeName: string(name='NodeName', description='nodeName'),
            projectId: long(name='ProjectId', description='projectId'),
            status: string(name='Status', description='status'),
            instanceId: long(name='InstanceId', description='instanceId'),
          }
        ](name='Instances', description='instances'),
        topics: [
          {
            nodeId: long(name='NodeId', description='nodeId'),
            instanceId: long(name='InstanceId', description='instanceId'),
            topicId: long(name='TopicId', description='topicId'),
            topicName: string(name='TopicName', description='topicName'),
            topicOwner: string(name='TopicOwner', description='topicOwner'),
            topicStatus: string(name='TopicStatus', description='topicStatus'),
          }
        ](name='Topics', description='topics'),
        nodes: [
          {
            nodeId: long(name='NodeId', description='nodeId'),
            nodeName: string(name='NodeName', description='nodeName'),
            owner: string(name='Owner', description='owner'),
            projectId: long(name='ProjectId', description='projectId'),
          }
        ](name='Nodes', description='nodes'),
        slaAlert: {
          baselineId: long(name='BaselineId', description='baselineId'),
          baselineName: string(name='BaselineName', description='baselineName'),
          baselineOwner: string(name='BaselineOwner', description='baselineOwner'),
          bizdate: long(name='Bizdate', description='bizdate'),
          inGroupId: integer(name='InGroupId', description='inGroupId'),
          projectId: long(name='ProjectId', description='projectId'),
          status: string(name='Status', description='status'),
        }(name='SlaAlert', description='slaAlert'),
      }
    ](name='AlertMessages', description='data'),
  }(name='Data', description='data'),
}

async function listAlertMessagesWithOptions(request: ListAlertMessagesRequest, runtime: Util.RuntimeOptions): ListAlertMessagesResponse {
  Util.validateModel(request);
  return doRequest('ListAlertMessages', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listAlertMessages(request: ListAlertMessagesRequest): ListAlertMessagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlertMessagesWithOptions(request, runtime);
}

model GetBaselineConfigRequest = {
  baselineId: long(name='BaselineId', description='baselineId'),
}

model GetBaselineConfigResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    baselineId: long(name='BaselineId', description='baselineId'),
    priority: integer(name='Priority', description='priority'),
    baselineName: string(name='BaselineName', description='baselineName'),
    owner: string(name='Owner', description='owner'),
    projectId: long(name='ProjectId', description='projectId'),
    useFlag: boolean(name='UseFlag', description='useFlag'),
    baselineType: string(name='BaselineType', description='baselineType'),
    expHour: integer(name='ExpHour', description='expHour'),
    expMinu: integer(name='ExpMinu', description='expMinu'),
    slaHour: integer(name='SlaHour', description='slaHour'),
    slaMinu: integer(name='SlaMinu', description='slaMinu'),
    hourExpDetail: string(name='HourExpDetail', description='hourExpDetail'),
    hourSlaDetail: string(name='HourSlaDetail', description='hourSlaDetail'),
    isDefault: boolean(name='IsDefault', description='isDefault'),
  }(name='Data', description='data'),
}

async function getBaselineConfigWithOptions(request: GetBaselineConfigRequest, runtime: Util.RuntimeOptions): GetBaselineConfigResponse {
  Util.validateModel(request);
  return doRequest('GetBaselineConfig', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getBaselineConfig(request: GetBaselineConfigRequest): GetBaselineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBaselineConfigWithOptions(request, runtime);
}

model SearchMetaTablesRequest = {
  pageNumber?: integer(name='PageNumber', description='pageNum'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  appGuid?: string(name='AppGuid', description='appGuid'),
  keyword: string(name='Keyword', description='keyword'),
  entityType?: integer(name='EntityType', description='entityType'),
}

model SearchMetaTablesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNum'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: long(name='TotalCount', description='totalNum'),
    dataEntityList: [
      {
        tableName: string(name='TableName', description='name'),
        tableGuid: string(name='TableGuid', description='tableGuid'),
        ownerId: string(name='OwnerId', description='ownerId'),
        tenantId: long(name='TenantId', description='tenantId'),
        envType: integer(name='EnvType', description='envType'),
        entityType: integer(name='EntityType', description='entityType'),
        projectId: long(name='ProjectId', description='projectId'),
        projectName: string(name='ProjectName', description='projectName'),
      }
    ](name='DataEntityList', description='data'),
  }(name='Data', description='data'),
}

async function searchMetaTablesWithOptions(request: SearchMetaTablesRequest, runtime: Util.RuntimeOptions): SearchMetaTablesResponse {
  Util.validateModel(request);
  return doRequest('SearchMetaTables', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function searchMetaTables(request: SearchMetaTablesRequest): SearchMetaTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchMetaTablesWithOptions(request, runtime);
}

model GetMetaTableListByCategoryRequest = {
  pageNumber?: integer(name='PageNumber', description='pageNum'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  categoryId: long(name='CategoryId', description='categoryId'),
}

model GetMetaTableListByCategoryResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNum'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: long(name='TotalCount', description='totalNum'),
    tableGuidList: [ string ](name='TableGuidList', description='data'),
  }(name='Data', description='data'),
}

async function getMetaTableListByCategoryWithOptions(request: GetMetaTableListByCategoryRequest, runtime: Util.RuntimeOptions): GetMetaTableListByCategoryResponse {
  Util.validateModel(request);
  return doRequest('GetMetaTableListByCategory', 'HTTPS', 'GET', '2020-05-18', 'AK', request, null, runtime);
}

async function getMetaTableListByCategory(request: GetMetaTableListByCategoryRequest): GetMetaTableListByCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableListByCategoryWithOptions(request, runtime);
}

model DeleteMetaCategoryRequest = {
  categoryId: long(name='CategoryId', description='categoryId'),
}

model DeleteMetaCategoryResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: boolean(name='Data', description='data'),
}

async function deleteMetaCategoryWithOptions(request: DeleteMetaCategoryRequest, runtime: Util.RuntimeOptions): DeleteMetaCategoryResponse {
  Util.validateModel(request);
  return doRequest('DeleteMetaCategory', 'HTTPS', 'GET', '2020-05-18', 'AK', request, null, runtime);
}

async function deleteMetaCategory(request: DeleteMetaCategoryRequest): DeleteMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetaCategoryWithOptions(request, runtime);
}

model UpdateMetaCategoryRequest = {
  name?: string(name='Name', description='name'),
  comment?: string(name='Comment', description='comment'),
  categoryId: long(name='CategoryId', description='categoryId'),
}

model UpdateMetaCategoryResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: boolean(name='Data', description='data'),
}

async function updateMetaCategoryWithOptions(request: UpdateMetaCategoryRequest, runtime: Util.RuntimeOptions): UpdateMetaCategoryResponse {
  Util.validateModel(request);
  return doRequest('UpdateMetaCategory', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateMetaCategory(request: UpdateMetaCategoryRequest): UpdateMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMetaCategoryWithOptions(request, runtime);
}

model ListTopicsRequest = {
  beginTime: string(name='BeginTime', description='beginTime'),
  endTime: string(name='EndTime', description='endTime'),
  topicTypes?: string(name='TopicTypes', description='topicTypes'),
  topicStatuses?: string(name='TopicStatuses', description='topicStatuses'),
  nodeId?: long(name='NodeId', description='nodeId'),
  instanceId?: long(name='InstanceId', description='instanceId'),
  owner?: string(name='Owner', description='owner'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
}

model ListTopicsResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNumber'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: integer(name='TotalCount', description='totalCount'),
    topics: [
      {
        topicId: long(name='TopicId', description='topicId'),
        topicName: string(name='TopicName', description='topicName'),
        topicStatus: string(name='TopicStatus', description='topicStatus'),
        topicType: string(name='TopicType', description='topicType'),
        addTime: long(name='AddTime', description='addTime'),
        happenTime: long(name='HappenTime', description='happenTime'),
        fixTime: long(name='FixTime', description='fixTime'),
        instanceId: long(name='InstanceId', description='instanceId'),
        nodeId: long(name='NodeId', description='nodeId'),
        nodeName: string(name='NodeName', description='nodeName'),
        nodeOwner: string(name='NodeOwner', description='nodeOwner'),
        projectId: long(name='ProjectId', description='projectId'),
      }
    ](name='Topics', description='data'),
  }(name='Data', description='data'),
}

async function listTopicsWithOptions(request: ListTopicsRequest, runtime: Util.RuntimeOptions): ListTopicsResponse {
  Util.validateModel(request);
  return doRequest('ListTopics', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listTopics(request: ListTopicsRequest): ListTopicsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTopicsWithOptions(request, runtime);
}

model ListFileVersionsRequest = {
  fileId: long(name='FileId', description='FileId'),
  projectId?: long(name='ProjectId', description='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier', description='ProjectIdentifier'),
  pageNumber?: integer(name='PageNumber', description='PageNum'),
  pageSize?: integer(name='PageSize', description='PageSize'),
}

model ListFileVersionsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNumber'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: integer(name='TotalCount', description='totalCount'),
    fileVersions: [
      {
        fileVersion: integer(name='FileVersion', description='fileVersion'),
        fileContent: string(name='FileContent', description='fileContent'),
        commitTime: long(name='CommitTime', description='commitTime'),
        commitUser: string(name='CommitUser', description='commitUser'),
        fileName: string(name='FileName', description='fileName'),
        status: string(name='Status', description='status'),
        changeType: string(name='ChangeType', description='changeType'),
        isCurrentProd: boolean(name='IsCurrentProd', description='isCurrentProd'),
        nodeId: long(name='NodeId', description='cloudUuid'),
        comment: string(name='Comment', description='comment'),
        nodeContent: string(name='NodeContent', description='nodeContent'),
        filePropertyContent: string(name='FilePropertyContent', description='filePropertyContent'),
        useType: string(name='UseType', description='useType'),
      }
    ](name='FileVersions', description='data'),
  }(name='Data', description='data'),
}

async function listFileVersionsWithOptions(request: ListFileVersionsRequest, runtime: Util.RuntimeOptions): ListFileVersionsResponse {
  Util.validateModel(request);
  return doRequest('ListFileVersions', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listFileVersions(request: ListFileVersionsRequest): ListFileVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFileVersionsWithOptions(request, runtime);
}

model CreateMetaCategoryRequest = {
  name: string(name='Name', description='name'),
  comment?: string(name='Comment', description='comment'),
  parentId?: long(name='ParentId', description='parentId'),
}

model CreateMetaCategoryResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: {
    categoryId: long(name='CategoryId', description='categoryId'),
  }(name='Data', description='data'),
}

async function createMetaCategoryWithOptions(request: CreateMetaCategoryRequest, runtime: Util.RuntimeOptions): CreateMetaCategoryResponse {
  Util.validateModel(request);
  return doRequest('CreateMetaCategory', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createMetaCategory(request: CreateMetaCategoryRequest): CreateMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMetaCategoryWithOptions(request, runtime);
}

model ListNodeIORequest = {
  nodeId: long(name='NodeId', description='nodeId'),
  projectEnv: string(name='ProjectEnv', description='projectEnv'),
  ioType: string(name='IoType', description='ioType'),
}

model ListNodeIOResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: [
    {
      tableName: string(name='TableName', description='tableName'),
      data: string(name='Data', description='data'),
    }
  ](name='Data', description='data'),
}

async function listNodeIOWithOptions(request: ListNodeIORequest, runtime: Util.RuntimeOptions): ListNodeIOResponse {
  Util.validateModel(request);
  return doRequest('ListNodeIO', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listNodeIO(request: ListNodeIORequest): ListNodeIOResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodeIOWithOptions(request, runtime);
}

model GetTopicInfluenceRequest = {
  topicId: long(name='TopicId', description='topicId'),
}

model GetTopicInfluenceResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    topicId: long(name='TopicId', description='topicId'),
    influences: [
      {
        baselineId: long(name='BaselineId', description='baselineId'),
        bizdate: long(name='Bizdate', description='bizdate'),
        inGroupId: integer(name='InGroupId', description='inGroupId'),
        baselineName: string(name='BaselineName', description='baselineName'),
        owner: string(name='Owner', description='owner'),
        status: string(name='Status', description='status'),
        projectId: long(name='ProjectId', description='projectId'),
        priority: integer(name='Priority', description='priority'),
        buffer: long(name='Buffer', description='buffer'),
      }
    ](name='Influences', description='influences'),
  }(name='Data', description='data'),
}

async function getTopicInfluenceWithOptions(request: GetTopicInfluenceRequest, runtime: Util.RuntimeOptions): GetTopicInfluenceResponse {
  Util.validateModel(request);
  return doRequest('GetTopicInfluence', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getTopicInfluence(request: GetTopicInfluenceRequest): GetTopicInfluenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTopicInfluenceWithOptions(request, runtime);
}

model GetTopicRequest = {
  topicId: long(name='TopicId', description='topicId'),
}

model GetTopicResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    topicId: long(name='TopicId', description='topicId'),
    topicName: string(name='TopicName', description='topicName'),
    topicStatus: string(name='TopicStatus', description='topicStatus'),
    topicType: string(name='TopicType', description='topicType'),
    addTime: long(name='AddTime', description='addTime'),
    alertTime: long(name='AlertTime', description='alertTime'),
    assigner: string(name='Assigner', description='assigner'),
    baselineId: long(name='BaselineId', description='baselineId'),
    baselineName: string(name='BaselineName', description='baselineNam'),
    baselineInGroupId: integer(name='BaselineInGroupId', description='baselineInGroupId'),
    baselineStatus: string(name='BaselineStatus', description='baselineStatus'),
    baselineBuffer: long(name='BaselineBuffer', description='baselineBuffer'),
    buffer: long(name='Buffer', description='buffer'),
    dealTime: long(name='DealTime', description='dealTime'),
    dealUser: string(name='DealUser', description='dealUser'),
    fixTime: long(name='FixTime', description='fixTime'),
    happenTime: long(name='HappenTime', description='happenTime'),
    instanceId: long(name='InstanceId', description='instanceId'),
    nextAlertTime: long(name='NextAlertTime', description='nextAlertTime'),
    nodeId: long(name='NodeId', description='nodeId'),
    nodeName: string(name='NodeName', description='nodeName'),
    owner: string(name='Owner', description='owner'),
    projectId: long(name='ProjectId', description='projectId'),
  }(name='Data', description='data'),
}

async function getTopicWithOptions(request: GetTopicRequest, runtime: Util.RuntimeOptions): GetTopicResponse {
  Util.validateModel(request);
  return doRequest('GetTopic', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getTopic(request: GetTopicRequest): GetTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTopicWithOptions(request, runtime);
}

model DeleteFromMetaCategoryRequest = {
  categoryId: long(name='CategoryId', description='categoryId'),
  tableGuid: string(name='TableGuid', description='tableGuid'),
}

model DeleteFromMetaCategoryResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: boolean(name='Data', description='data'),
}

async function deleteFromMetaCategoryWithOptions(request: DeleteFromMetaCategoryRequest, runtime: Util.RuntimeOptions): DeleteFromMetaCategoryResponse {
  Util.validateModel(request);
  return doRequest('DeleteFromMetaCategory', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteFromMetaCategory(request: DeleteFromMetaCategoryRequest): DeleteFromMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFromMetaCategoryWithOptions(request, runtime);
}

model GetNodeRequest = {
  nodeId: long(name='NodeId', description='nodeId'),
  projectEnv: string(name='ProjectEnv', description='projectEnv'),
}

model GetNodeResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    nodeId: long(name='NodeId', description='nodeId'),
    ownerId: string(name='OwnerId', description='ownerId'),
    description: string(name='Description', description='description'),
    resGroupName: string(name='ResGroupName', description='resGroupName'),
    nodeName: string(name='NodeName', description='nodeName'),
    cronExpress: string(name='CronExpress', description='cronExpress'),
    repeatability: string(name='Repeatability', description='repeatability'),
    programType: string(name='ProgramType', description='programType'),
    projectId: long(name='ProjectId', description='projectId'),
    schedulerType: string(name='SchedulerType', description='schedulerType'),
    paramValues: string(name='ParamValues', description='paramValues'),
  }(name='Data', description='data'),
}

async function getNodeWithOptions(request: GetNodeRequest, runtime: Util.RuntimeOptions): GetNodeResponse {
  Util.validateModel(request);
  return doRequest('GetNode', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getNode(request: GetNodeRequest): GetNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNodeWithOptions(request, runtime);
}

model ListNodesRequest = {
  owner?: string(name='Owner', description='owner'),
  bizName?: string(name='BizName', description='bizName'),
  programType?: string(name='ProgramType', description='programType'),
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  projectId: long(name='ProjectId', description='projectId'),
  projectEnv: string(name='ProjectEnv', description='projectEnv'),
  nodeName?: string(name='NodeName', description='nodeName'),
}

model ListNodesResponse = {
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNumber'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: integer(name='TotalCount', description='totalCount'),
    nodes: [
      {
        nodeId: long(name='NodeId', description='nodeId'),
        nodeName: string(name='NodeName', description='nodeName'),
        cronExpress: string(name='CronExpress', description='cronExpress'),
        schedulerType: string(name='SchedulerType', description='schedulerType'),
        programType: string(name='ProgramType', description='programType'),
        ownerId: string(name='OwnerId', description='ownerId'),
        projectId: long(name='ProjectId', description='projectId'),
        repeatability: boolean(name='Repeatability', description='repeatability'),
        paramValues: string(name='ParamValues', description='paramValues'),
        description: string(name='Description', description='description'),
        resGroupName: string(name='ResGroupName', description='resGroupName'),
      }
    ](name='Nodes', description='data'),
  }(name='Data', description='data'),
}

async function listNodesWithOptions(request: ListNodesRequest, runtime: Util.RuntimeOptions): ListNodesResponse {
  Util.validateModel(request);
  return doRequest('ListNodes', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listNodes(request: ListNodesRequest): ListNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodesWithOptions(request, runtime);
}

model GetNodeCodeRequest = {
  nodeId: long(name='NodeId', description='nodeId'),
  projectEnv: string(name='ProjectEnv', description='projectEnv'),
}

model GetNodeCodeResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: string(name='Data', description='data'),
}

async function getNodeCodeWithOptions(request: GetNodeCodeRequest, runtime: Util.RuntimeOptions): GetNodeCodeResponse {
  Util.validateModel(request);
  return doRequest('GetNodeCode', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getNodeCode(request: GetNodeCodeRequest): GetNodeCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNodeCodeWithOptions(request, runtime);
}

model EstablishRelationTableToBusinessRequest = {
  projectId?: long(name='ProjectId', description='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier', description='ProjectIdentifier'),
  businessId: string(name='BusinessId', description='BizId'),
  tableGuid: string(name='TableGuid', description='TableGuid'),
  folderId?: string(name='FolderId', description='FolderId'),
}

model EstablishRelationTableToBusinessResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function establishRelationTableToBusinessWithOptions(request: EstablishRelationTableToBusinessRequest, runtime: Util.RuntimeOptions): EstablishRelationTableToBusinessResponse {
  Util.validateModel(request);
  return doRequest('EstablishRelationTableToBusiness', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function establishRelationTableToBusiness(request: EstablishRelationTableToBusinessRequest): EstablishRelationTableToBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return establishRelationTableToBusinessWithOptions(request, runtime);
}

model UpdateDataServiceApiRequest = {
  tenantId: long(name='TenantId', description='tenantId'),
  projectId: long(name='ProjectId', description='projectId'),
  apiId: long(name='ApiId', description='apiId'),
  requestMethod: integer(name='RequestMethod', description='apiHttpMethod'),
  responseContentType: integer(name='ResponseContentType', description='apiResultType'),
  timeout: integer(name='Timeout', description='apiTimeout'),
  visibleRange: integer(name='VisibleRange', description='securityLevel'),
  protocols: string(name='Protocols', description='apiProtocolsStr'),
  wizardDetails?: string(name='WizardDetails', description='wizardDetailsStr'),
  scriptDetails?: string(name='ScriptDetails', description='scriptDetailsStr'),
  registrationDetails?: string(name='RegistrationDetails', description='registrationDetailsStr'),
  apiPath: string(name='ApiPath', description='apiPath'),
  apiDescription: string(name='ApiDescription', description='apiDesc'),
}

model UpdateDataServiceApiResponse = {
  data: boolean(name='Data', description='data'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
}

async function updateDataServiceApiWithOptions(request: UpdateDataServiceApiRequest, runtime: Util.RuntimeOptions): UpdateDataServiceApiResponse {
  Util.validateModel(request);
  return doRequest('UpdateDataServiceApi', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateDataServiceApi(request: UpdateDataServiceApiRequest): UpdateDataServiceApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDataServiceApiWithOptions(request, runtime);
}

model UpdateUdfFileRequest = {
  fileFolderPath?: string(name='FileFolderPath', description='FileFolderPath'),
  projectId?: long(name='ProjectId', description='ProjectId'),
  functionType: string(name='FunctionType', description='FunctionType'),
  className: string(name='ClassName', description='ClassName'),
  resources: string(name='Resources', description='Resources'),
  udfDescription?: string(name='UdfDescription', description='UdfDescription'),
  cmdDescription?: string(name='CmdDescription', description='CmdDescription'),
  parameterDescription?: string(name='ParameterDescription', description='ParameterDescription'),
  returnValue?: string(name='ReturnValue', description='ReturnValue'),
  example?: string(name='Example', description='Example'),
  projectIdentifier?: string(name='ProjectIdentifier', description='ProjectIdentifier'),
  fileId: string(name='FileId', description='FileId'),
}

model UpdateUdfFileResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function updateUdfFileWithOptions(request: UpdateUdfFileRequest, runtime: Util.RuntimeOptions): UpdateUdfFileResponse {
  Util.validateModel(request);
  return doRequest('UpdateUdfFile', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateUdfFile(request: UpdateUdfFileRequest): UpdateUdfFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUdfFileWithOptions(request, runtime);
}

model CreateUdfFileRequest = {
  fileFolderPath?: string(name='FileFolderPath', description='FileFolderPath'),
  projectId?: long(name='ProjectId', description='ProjectId'),
  fileName: string(name='FileName', description='FileName'),
  functionType: string(name='FunctionType', description='FunctionType'),
  className: string(name='ClassName', description='ClassName'),
  resources: string(name='Resources', description='Resources'),
  udfDescription?: string(name='UdfDescription', description='UdfDescription'),
  cmdDescription?: string(name='CmdDescription', description='CmdDescription'),
  parameterDescription?: string(name='ParameterDescription', description='ParameterDescription'),
  returnValue?: string(name='ReturnValue', description='ReturnValue'),
  example?: string(name='Example', description='Example'),
  projectIdentifier?: string(name='ProjectIdentifier', description='ProjectIdentifier'),
}

model CreateUdfFileResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  data: long(name='Data', description='data'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function createUdfFileWithOptions(request: CreateUdfFileRequest, runtime: Util.RuntimeOptions): CreateUdfFileResponse {
  Util.validateModel(request);
  return doRequest('CreateUdfFile', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createUdfFile(request: CreateUdfFileRequest): CreateUdfFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUdfFileWithOptions(request, runtime);
}

model ListFilesRequest = {
  fileFolderPath?: string(name='FileFolderPath', description='FileFolderPath'),
  projectId?: long(name='ProjectId', description='ProjectId'),
  keyword?: string(name='Keyword', description='Keyword'),
  projectIdentifier?: string(name='ProjectIdentifier', description='ProjectIdentifier'),
  pageNumber?: integer(name='PageNumber', description='PageNum'),
  pageSize?: integer(name='PageSize', description='PageSize'),
  useType?: string(name='UseType', description='UseType'),
  fileTypes?: string(name='FileTypes', description='FileTypes'),
  owner?: string(name='Owner', description='Owner'),
}

model ListFilesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNum'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: integer(name='TotalCount', description='totalCount'),
    files: [
      {
        connectionName: string(name='ConnectionName', description='connName'),
        parentId: long(name='ParentId', description='parentId'),
        isMaxCompute: boolean(name='IsMaxCompute', description='isOdps'),
        createTime: long(name='CreateTime', description='createTime'),
        createUser: string(name='CreateUser', description='createUser'),
        bizId: long(name='BizId', description='bizId'),
        fileFolderId: string(name='FileFolderId', description='fileFolderId'),
        fileName: string(name='FileName', description='fileName'),
        fileType: integer(name='FileType', description='fileType'),
        useType: string(name='UseType', description='useType'),
        fileDescription: string(name='FileDescription', description='fileDesc'),
        content: string(name='Content', description='content'),
        nodeId: long(name='NodeId', description='cloudUuid'),
        currentVersion: integer(name='CurrentVersion', description='currentVersion'),
        owner: string(name='Owner', description='owner'),
        lastEditUser: string(name='LastEditUser', description='lastEditUser'),
        lastEditTime: long(name='LastEditTime', description='lastEditTime'),
        commitStatus: integer(name='CommitStatus', description='commitStatus'),
      }
    ](name='Files', description='data'),
  }(name='Data', description='data'),
}

async function listFilesWithOptions(request: ListFilesRequest, runtime: Util.RuntimeOptions): ListFilesResponse {
  Util.validateModel(request);
  return doRequest('ListFiles', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listFiles(request: ListFilesRequest): ListFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFilesWithOptions(request, runtime);
}

model ListDataServiceAuthorizedApisRequest = {
  projectId: long(name='ProjectId', description='projectId'),
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  tenantId: long(name='TenantId', description='tenantId'),
  apiNameKeyword?: string(name='ApiNameKeyword', description='apiNameKeyword'),
}

model ListDataServiceAuthorizedApisResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNumber'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: integer(name='TotalCount', description='totalCount'),
    apiAuthorizedList: [
      {
        apiId: long(name='ApiId', description='apiId'),
        apiName: string(name='ApiName', description='apiName'),
        apiPath: string(name='ApiPath', description='apiPath'),
        apiStatus: integer(name='ApiStatus', description='apiStatus'),
        createdTime: string(name='CreatedTime', description='gmtCreate'),
        creatorId: string(name='CreatorId', description='creator'),
        grantCreatedTime: string(name='GrantCreatedTime', description='grantBeginTime'),
        grantEndTime: string(name='GrantEndTime', description='grantEndTime'),
        grantOperatorId: string(name='GrantOperatorId', description='grantOperator'),
        groupId: string(name='GroupId', description='groupId'),
        modifiedTime: string(name='ModifiedTime', description='gmtModified'),
        projectId: long(name='ProjectId', description='projectId'),
        tenantId: long(name='TenantId', description='tenantId'),
      }
    ](name='ApiAuthorizedList', description='data'),
  }(name='Data', description='data'),
}

async function listDataServiceAuthorizedApisWithOptions(request: ListDataServiceAuthorizedApisRequest, runtime: Util.RuntimeOptions): ListDataServiceAuthorizedApisResponse {
  Util.validateModel(request);
  return doRequest('ListDataServiceAuthorizedApis', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listDataServiceAuthorizedApis(request: ListDataServiceAuthorizedApisRequest): ListDataServiceAuthorizedApisResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServiceAuthorizedApisWithOptions(request, runtime);
}

model UpdateFileRequest = {
  fileFolderPath?: string(name='FileFolderPath', description='FileFolderPath'),
  projectId?: long(name='ProjectId', description='ProjectId'),
  fileName?: string(name='FileName', description='FileName'),
  fileDescription?: string(name='FileDescription', description='FileDescription'),
  content?: string(name='Content', description='Content'),
  autoRerunTimes?: integer(name='AutoRerunTimes', description='AutoRerunTimes'),
  autoRerunIntervalMillis?: integer(name='AutoRerunIntervalMillis', description='AutoRerunIntervalMillis'),
  rerunMode?: string(name='RerunMode', description='RerunMode'),
  stop?: boolean(name='Stop', description='Stop'),
  paraValue?: string(name='ParaValue', description='ParaValue'),
  startEffectDate?: long(name='StartEffectDate', description='StartEffectDate'),
  endEffectDate?: long(name='EndEffectDate', description='EndEffectDate'),
  cronExpress?: string(name='CronExpress', description='CronExpress'),
  cycleType?: string(name='CycleType', description='CycleType'),
  dependentType?: string(name='DependentType', description='DependentType'),
  dependentNodeIdList?: string(name='DependentNodeIdList', description='DependentNodeIdList'),
  inputList?: string(name='InputList', description='InputList'),
  projectIdentifier?: string(name='ProjectIdentifier', description='ProjectIdentifier'),
  fileId: long(name='FileId', description='FileId'),
  outputList?: string(name='OutputList', description='OutputList'),
}

model UpdateFileResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function updateFileWithOptions(request: UpdateFileRequest, runtime: Util.RuntimeOptions): UpdateFileResponse {
  Util.validateModel(request);
  return doRequest('UpdateFile', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateFile(request: UpdateFileRequest): UpdateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFileWithOptions(request, runtime);
}

model DeleteFolderRequest = {
  projectId?: long(name='ProjectId', description='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier', description='ProjectIdentifier'),
  folderId: string(name='FolderId', description='FolderId'),
}

model DeleteFolderResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function deleteFolderWithOptions(request: DeleteFolderRequest, runtime: Util.RuntimeOptions): DeleteFolderResponse {
  Util.validateModel(request);
  return doRequest('DeleteFolder', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteFolder(request: DeleteFolderRequest): DeleteFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFolderWithOptions(request, runtime);
}

model ListFoldersRequest = {
  projectId?: long(name='ProjectId', description='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier', description='ProjectIdentifier'),
  parentFolderPath: string(name='ParentFolderPath', description='ParentFolderPath'),
  pageNumber: integer(name='PageNumber', description='PageNum'),
  pageSize: integer(name='PageSize', description='PageSize'),
}

model ListFoldersResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNumber'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: integer(name='TotalCount', description='totalCount'),
    folders: [
      {
        folderId: string(name='FolderId', description='folderId'),
        folderPath: string(name='FolderPath', description='absolutePath'),
      }
    ](name='Folders', description='data'),
  }(name='Data', description='data'),
}

async function listFoldersWithOptions(request: ListFoldersRequest, runtime: Util.RuntimeOptions): ListFoldersResponse {
  Util.validateModel(request);
  return doRequest('ListFolders', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listFolders(request: ListFoldersRequest): ListFoldersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFoldersWithOptions(request, runtime);
}

model CheckMetaPartitionRequest = {
  tableGuid: string(name='TableGuid', description='tableGuid'),
  partition: string(name='Partition', description='partition'),
}

model CheckMetaPartitionResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: boolean(name='Data', description='data'),
}

async function checkMetaPartitionWithOptions(request: CheckMetaPartitionRequest, runtime: Util.RuntimeOptions): CheckMetaPartitionResponse {
  Util.validateModel(request);
  return doRequest('CheckMetaPartition', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function checkMetaPartition(request: CheckMetaPartitionRequest): CheckMetaPartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkMetaPartitionWithOptions(request, runtime);
}

model UpdateFolderRequest = {
  projectId?: long(name='ProjectId', description='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier', description='ProjectIdentifier'),
  folderId: string(name='FolderId', description='FolderId'),
  folderName: string(name='FolderName', description='FolderName'),
}

model UpdateFolderResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function updateFolderWithOptions(request: UpdateFolderRequest, runtime: Util.RuntimeOptions): UpdateFolderResponse {
  Util.validateModel(request);
  return doRequest('UpdateFolder', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateFolder(request: UpdateFolderRequest): UpdateFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFolderWithOptions(request, runtime);
}

model DeleteRemindRequest = {
  remindId: long(name='RemindId', description='remindId'),
}

model DeleteRemindResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: boolean(name='Data', description='data'),
}

async function deleteRemindWithOptions(request: DeleteRemindRequest, runtime: Util.RuntimeOptions): DeleteRemindResponse {
  Util.validateModel(request);
  return doRequest('DeleteRemind', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteRemind(request: DeleteRemindRequest): DeleteRemindResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRemindWithOptions(request, runtime);
}

model AddToMetaCategoryRequest = {
  categoryId: long(name='CategoryId', description='categoryId'),
  tableGuid: string(name='TableGuid', description='tableGuid'),
}

model AddToMetaCategoryResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: boolean(name='Data', description='data'),
}

async function addToMetaCategoryWithOptions(request: AddToMetaCategoryRequest, runtime: Util.RuntimeOptions): AddToMetaCategoryResponse {
  Util.validateModel(request);
  return doRequest('AddToMetaCategory', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function addToMetaCategory(request: AddToMetaCategoryRequest): AddToMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addToMetaCategoryWithOptions(request, runtime);
}

model ListInstancesRequest = {
  projectEnv: string(name='ProjectEnv', description='projectEnv'),
  nodeId?: long(name='NodeId', description='nodeId'),
  nodeName?: string(name='NodeName', description='nodeName'),
  owner?: string(name='Owner', description='owner'),
  projectId: long(name='ProjectId', description='projectId'),
  bizName?: string(name='BizName', description='bizName'),
  programType?: string(name='ProgramType', description='programType'),
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  pageSize?: integer(name='PageSize', description='pageSize'),
}

model ListInstancesResponse = {
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNumber'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: integer(name='TotalCount', description='totalCount'),
    instances: [
      {
        nodeId: integer(name='NodeId', description='nodeId'),
        instanceId: long(name='InstanceId', description='instanceId'),
        dagId: integer(name='DagId', description='dagId'),
        dagType: string(name='DagType', description='dagType'),
        status: string(name='Status', description='status'),
        bizdate: long(name='Bizdate', description='bizdate'),
        cycTime: long(name='CycTime', description='cycTime'),
        createTime: long(name='CreateTime', description='createTime'),
        modifyTime: long(name='ModifyTime', description='modifyTime'),
        nodeName: string(name='NodeName', description='nodeName'),
        beginWaitTimeTime: long(name='BeginWaitTimeTime', description='beginWaitTimeTime'),
        beginWaitResTime: long(name='BeginWaitResTime', description='beginWaitResTime'),
        beginRunningTime: long(name='BeginRunningTime', description='beginRunningTime'),
        paramValues: string(name='ParamValues', description='paramValues'),
        finishTime: long(name='FinishTime', description='finishTime'),
      }
    ](name='Instances', description='data'),
  }(name='Data', description='data'),
}

async function listInstancesWithOptions(request: ListInstancesRequest, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  return doRequest('ListInstances', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstancesWithOptions(request, runtime);
}

model SetSuccessInstanceRequest = {
  instanceId: long(name='InstanceId', description='instanceId'),
  projectEnv: string(name='ProjectEnv', description='projectEnv'),
}

model SetSuccessInstanceResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  data: boolean(name='Data', description='data'),
}

async function setSuccessInstanceWithOptions(request: SetSuccessInstanceRequest, runtime: Util.RuntimeOptions): SetSuccessInstanceResponse {
  Util.validateModel(request);
  return doRequest('SetSuccessInstance', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function setSuccessInstance(request: SetSuccessInstanceRequest): SetSuccessInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return setSuccessInstanceWithOptions(request, runtime);
}

model CreateFileRequest = {
  fileFolderPath?: string(name='FileFolderPath', description='fileFolderPath'),
  projectId?: long(name='ProjectId', description='projectId'),
  fileName: string(name='FileName', description='fileName'),
  fileDescription?: string(name='FileDescription', description='fileDescription'),
  fileType: integer(name='FileType', description='fileType'),
  owner?: string(name='Owner', description='owner'),
  content?: string(name='Content', description='content'),
  autoRerunTimes?: integer(name='AutoRerunTimes', description='autoRerunTimes'),
  autoRerunIntervalMillis?: integer(name='AutoRerunIntervalMillis', description='autoRerunIntervalMillis'),
  rerunMode?: string(name='RerunMode', description='rerunMode'),
  stop?: boolean(name='Stop', description='stop'),
  paraValue?: string(name='ParaValue', description='paraValue'),
  startEffectDate?: long(name='StartEffectDate', description='startEffectDate'),
  endEffectDate?: long(name='EndEffectDate', description='endEffectDate'),
  cronExpress?: string(name='CronExpress', description='cronExpress'),
  cycleType?: string(name='CycleType', description='cycleType'),
  dependentType?: string(name='DependentType', description='dependentType'),
  dependentNodeIdList?: string(name='DependentNodeIdList', description='dependentCloudUuidList'),
  inputList: string(name='InputList', description='inputList'),
  projectIdentifier?: string(name='ProjectIdentifier', description='projectIdentifier'),
}

model CreateFileResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  data: long(name='Data', description='data'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function createFileWithOptions(request: CreateFileRequest, runtime: Util.RuntimeOptions): CreateFileResponse {
  Util.validateModel(request);
  return doRequest('CreateFile', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createFile(request: CreateFileRequest): CreateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFileWithOptions(request, runtime);
}

model StopInstanceRequest = {
  instanceId: long(name='InstanceId', description='instanceId'),
  projectEnv: string(name='ProjectEnv', description='projectEnv'),
}

model StopInstanceResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  data: boolean(name='Data', description='data'),
}

async function stopInstanceWithOptions(request: StopInstanceRequest, runtime: Util.RuntimeOptions): StopInstanceResponse {
  Util.validateModel(request);
  return doRequest('StopInstance', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function stopInstance(request: StopInstanceRequest): StopInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopInstanceWithOptions(request, runtime);
}

model ResumeInstanceRequest = {
  instanceId: long(name='InstanceId', description='instanceId'),
  projectEnv: string(name='ProjectEnv', description='projectEnv'),
}

model ResumeInstanceResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  data: boolean(name='Data', description='data'),
}

async function resumeInstanceWithOptions(request: ResumeInstanceRequest, runtime: Util.RuntimeOptions): ResumeInstanceResponse {
  Util.validateModel(request);
  return doRequest('ResumeInstance', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function resumeInstance(request: ResumeInstanceRequest): ResumeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumeInstanceWithOptions(request, runtime);
}

model SuspendInstanceRequest = {
  instanceId: long(name='InstanceId', description='instanceId'),
  projectEnv: string(name='ProjectEnv', description='projectEnv'),
}

model SuspendInstanceResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  data: boolean(name='Data', description='data'),
}

async function suspendInstanceWithOptions(request: SuspendInstanceRequest, runtime: Util.RuntimeOptions): SuspendInstanceResponse {
  Util.validateModel(request);
  return doRequest('SuspendInstance', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function suspendInstance(request: SuspendInstanceRequest): SuspendInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return suspendInstanceWithOptions(request, runtime);
}

model RestartInstanceRequest = {
  instanceId: long(name='InstanceId', description='instanceId'),
  projectEnv: string(name='ProjectEnv', description='projectEnv'),
}

model RestartInstanceResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  data: boolean(name='Data', description='data'),
}

async function restartInstanceWithOptions(request: RestartInstanceRequest, runtime: Util.RuntimeOptions): RestartInstanceResponse {
  Util.validateModel(request);
  return doRequest('RestartInstance', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function restartInstance(request: RestartInstanceRequest): RestartInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartInstanceWithOptions(request, runtime);
}

model ListDataServiceApiAuthoritiesRequest = {
  projectId: long(name='ProjectId', description='projectId'),
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  tenantId: long(name='TenantId', description='tenantId'),
  apiNameKeyword?: string(name='ApiNameKeyword', description='apiNameKeyword'),
}

model ListDataServiceApiAuthoritiesResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNumber'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: integer(name='TotalCount', description='totalCount'),
    apiAuthorizationList: [
      {
        apiId: long(name='ApiId', description='apiId'),
        apiName: string(name='ApiName', description='apiName'),
        apiPath: string(name='ApiPath', description='apiPath'),
        apiStatus: integer(name='ApiStatus', description='apiStatus'),
        createdTime: string(name='CreatedTime', description='gmtCreate'),
        creatorId: string(name='CreatorId', description='creator'),
        groupId: string(name='GroupId', description='groupId'),
        modifiedTime: string(name='ModifiedTime', description='gmtModified'),
        projectId: long(name='ProjectId', description='projectId'),
        tenantId: long(name='TenantId', description='tenantId'),
        authorizationRecords: [
          {
            createdTime: string(name='CreatedTime', description='createTime'),
            creatorId: string(name='CreatorId', description='creator'),
            endTime: string(name='EndTime', description='endTime'),
            projectId: long(name='ProjectId', description='projectId'),
          }
        ](name='AuthorizationRecords', description='authorizationDetails'),
      }
    ](name='ApiAuthorizationList', description='data'),
  }(name='Data', description='data'),
}

async function listDataServiceApiAuthoritiesWithOptions(request: ListDataServiceApiAuthoritiesRequest, runtime: Util.RuntimeOptions): ListDataServiceApiAuthoritiesResponse {
  Util.validateModel(request);
  return doRequest('ListDataServiceApiAuthorities', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listDataServiceApiAuthorities(request: ListDataServiceApiAuthoritiesRequest): ListDataServiceApiAuthoritiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServiceApiAuthoritiesWithOptions(request, runtime);
}

model ListDataServicePublishedApisRequest = {
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  projectId: long(name='ProjectId', description='projectId'),
  tenantId: long(name='TenantId', description='tenantId'),
  apiNameKeyword?: string(name='ApiNameKeyword', description='apiNameKeyword'),
  apiPathKeyword?: string(name='ApiPathKeyword', description='apiPathKeyword'),
  creatorId?: string(name='CreatorId', description='creator'),
}

model ListDataServicePublishedApisResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNumber'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: integer(name='TotalCount', description='totalCount'),
    apis: [
      {
        apiId: long(name='ApiId', description='apiId'),
        apiMode: integer(name='ApiMode', description='apiMode'),
        apiName: string(name='ApiName', description='apiName'),
        apiPath: string(name='ApiPath', description='apiPath'),
        createdTime: string(name='CreatedTime', description='gmtCreate'),
        creatorId: string(name='CreatorId', description='creator'),
        description: string(name='Description', description='apiDesc'),
        groupId: string(name='GroupId', description='groupId'),
        modifiedTime: string(name='ModifiedTime', description='gmtModified'),
        operatorId: string(name='OperatorId', description='operator'),
        projectId: long(name='ProjectId', description='projectId'),
        requestMethod: integer(name='RequestMethod', description='apiHttpMethod'),
        responseContentType: integer(name='ResponseContentType', description='apiResultType'),
        status: integer(name='Status', description='apiStatus'),
        tenantId: long(name='TenantId', description='tenantId'),
        timeout: integer(name='Timeout', description='apiTimeout'),
        visibleRange: integer(name='VisibleRange', description='securityLevel'),
        registrationDetails: {
          failedResultSample: string(name='FailedResultSample', description='failResultSample'),
          serviceContentType: integer(name='ServiceContentType', description='contentType'),
          serviceHost: string(name='ServiceHost', description='host'),
          servicePath: string(name='ServicePath', description='path'),
          serviceRequestBodyDescription: string(name='ServiceRequestBodyDescription', description='bodyDescription'),
          successfulResultSample: string(name='SuccessfulResultSample', description='successResultSample'),
          registrationErrorCodes: [
            {
              errorCode: string(name='ErrorCode', description='errorCode'),
              errorMessage: string(name='ErrorMessage', description='errorMsg'),
              errorSolution: string(name='ErrorSolution', description='errorSolution'),
            }
          ](name='RegistrationErrorCodes', description='apiErrorCodes'),
          registrationRequestParameters: [
            {
              defaultValue: string(name='DefaultValue', description='defaultValue'),
              exampleValue: string(name='ExampleValue', description='exampleValue'),
              isRequiredParameter: boolean(name='IsRequiredParameter', description='required'),
              parameterDataType: integer(name='ParameterDataType', description='paramType'),
              parameterDescription: string(name='ParameterDescription', description='paramDesc'),
              parameterName: string(name='ParameterName', description='paramName'),
              parameterOperator: integer(name='ParameterOperator', description='paramOperator'),
              parameterPosition: integer(name='ParameterPosition', description='paramPosition'),
            }
          ](name='RegistrationRequestParameters', description='requestParams'),
        }(name='RegistrationDetails', description='registeredApiDetails'),
        scriptDetails: {
          failedResultSample: string(name='FailedResultSample', description='failResultSample'),
          isPagedResponse: boolean(name='IsPagedResponse', description='responsePaged'),
          script: string(name='Script', description='apiSql'),
          successfulResultSample: string(name='SuccessfulResultSample', description='successResultSample'),
          scriptErrorCodes: [
            {
              errorCode: string(name='ErrorCode', description='errorCode'),
              errorMessage: string(name='ErrorMessage', description='errorMsg'),
              errorSolution: string(name='ErrorSolution', description='errorSolution'),
            }
          ](name='ScriptErrorCodes', description='apiErrorCodes'),
          scriptRequestParameters: [
            {
              defaultValue: string(name='DefaultValue', description='defaultValue'),
              exampleValue: string(name='ExampleValue', description='exampleValue'),
              isRequiredParameter: boolean(name='IsRequiredParameter', description='required'),
              parameterDataType: integer(name='ParameterDataType', description='paramType'),
              parameterDescription: string(name='ParameterDescription', description='paramDesc'),
              parameterName: string(name='ParameterName', description='paramName'),
              parameterOperator: integer(name='ParameterOperator', description='paramOperator'),
              parameterPosition: integer(name='ParameterPosition', description='paramPosition'),
            }
          ](name='ScriptRequestParameters', description='requestParams'),
          scriptResponseParameters: [
            {
              exampleValue: string(name='ExampleValue', description='exampleValue'),
              parameterDataType: integer(name='ParameterDataType', description='paramType'),
              parameterDescription: string(name='ParameterDescription', description='paramDesc'),
              parameterName: string(name='ParameterName', description='paramName'),
            }
          ](name='ScriptResponseParameters', description='responseParams'),
          scriptConnection: {
            connectionId: long(name='ConnectionId', description='connectionId'),
            tableName: string(name='TableName', description='tableName'),
          }(name='ScriptConnection', description='connection'),
        }(name='ScriptDetails', description='scriptApiDetails'),
        wizardDetails: {
          failedResultSample: string(name='FailedResultSample', description='failResultSample'),
          isPagedResponse: boolean(name='IsPagedResponse', description='responsePaged'),
          successfulResultSample: string(name='SuccessfulResultSample', description='successResultSample'),
          wizardErrorCodes: [
            {
              errorCode: string(name='ErrorCode', description='errorCode'),
              errorMessage: string(name='ErrorMessage', description='errorMsg'),
              errorSolution: string(name='ErrorSolution', description='errorSolution'),
            }
          ](name='WizardErrorCodes', description='apiErrorCodes'),
          wizardRequestParameters: [
            {
              defaultValue: string(name='DefaultValue', description='defaultValue'),
              exampleValue: string(name='ExampleValue', description='exampleValue'),
              isRequiredParameter: boolean(name='IsRequiredParameter', description='required'),
              parameterDataType: integer(name='ParameterDataType', description='paramType'),
              parameterDescription: string(name='ParameterDescription', description='paramDesc'),
              parameterName: string(name='ParameterName', description='paramName'),
              parameterOperator: integer(name='ParameterOperator', description='paramOperator'),
              parameterPosition: integer(name='ParameterPosition', description='paramPosition'),
            }
          ](name='WizardRequestParameters', description='requestParams'),
          wizardResponseParameters: [
            {
              exampleValue: string(name='ExampleValue', description='exampleValue'),
              parameterDataType: integer(name='ParameterDataType', description='paramType'),
              parameterDescription: string(name='ParameterDescription', description='paramDesc'),
              parameterName: string(name='ParameterName', description='paramName'),
            }
          ](name='WizardResponseParameters', description='responseParams'),
          wizardConnection: {
            connectionId: long(name='ConnectionId', description='connectionId'),
            tableName: string(name='TableName', description='tableName'),
          }(name='WizardConnection', description='connection'),
        }(name='WizardDetails', description='wizardApiDetails'),
        protocols: [ integer ](name='Protocols', description='apiProtocolList'),
      }
    ](name='Apis', description='data'),
  }(name='Data', description='data'),
}

async function listDataServicePublishedApisWithOptions(request: ListDataServicePublishedApisRequest, runtime: Util.RuntimeOptions): ListDataServicePublishedApisResponse {
  Util.validateModel(request);
  return doRequest('ListDataServicePublishedApis', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listDataServicePublishedApis(request: ListDataServicePublishedApisRequest): ListDataServicePublishedApisResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServicePublishedApisWithOptions(request, runtime);
}

model GetInstanceLogRequest = {
  instanceId: long(name='InstanceId', description='instanceId'),
  projectEnv: string(name='ProjectEnv', description='projectEnv'),
}

model GetInstanceLogResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  data: string(name='Data', description='data'),
}

async function getInstanceLogWithOptions(request: GetInstanceLogRequest, runtime: Util.RuntimeOptions): GetInstanceLogResponse {
  Util.validateModel(request);
  return doRequest('GetInstanceLog', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getInstanceLog(request: GetInstanceLogRequest): GetInstanceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceLogWithOptions(request, runtime);
}

model CreateFolderRequest = {
  projectId?: long(name='ProjectId', description='projectId'),
  projectIdentifier?: string(name='ProjectIdentifier', description='projectIdentifier'),
  folderPath: string(name='FolderPath', description='folderPath'),
}

model CreateFolderResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  data: string(name='Data', description='data'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function createFolderWithOptions(request: CreateFolderRequest, runtime: Util.RuntimeOptions): CreateFolderResponse {
  Util.validateModel(request);
  return doRequest('CreateFolder', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createFolder(request: CreateFolderRequest): CreateFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFolderWithOptions(request, runtime);
}

model GetBusinessRequest = {
  projectId?: long(name='ProjectId', description='projectId'),
  projectIdentifier?: string(name='ProjectIdentifier', description='projectIdentifier'),
  businessId: long(name='BusinessId', description='bizId'),
}

model GetBusinessResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  data: {
    businessId: long(name='BusinessId', description='bizId'),
    businessName: string(name='BusinessName', description='bizName'),
    projectId: string(name='ProjectId', description='appId'),
    owner: string(name='Owner', description='owner'),
    description: string(name='Description', description='description'),
    useType: string(name='UseType', description='useType'),
  }(name='Data', description='data'),
}

async function getBusinessWithOptions(request: GetBusinessRequest, runtime: Util.RuntimeOptions): GetBusinessResponse {
  Util.validateModel(request);
  return doRequest('GetBusiness', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getBusiness(request: GetBusinessRequest): GetBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBusinessWithOptions(request, runtime);
}

model GetInstanceRequest = {
  instanceId: long(name='InstanceId', description='instanceId'),
  projectEnv: string(name='ProjectEnv', description='projectEnv'),
}

model GetInstanceResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  data: {
    nodeId: long(name='NodeId', description='nodeId'),
    instanceId: long(name='InstanceId', description='instanceId'),
    dagId: long(name='DagId', description='dagId'),
    dagType: string(name='DagType', description='dagType'),
    status: string(name='Status', description='status'),
    bizdate: long(name='Bizdate', description='bizdate'),
    paramValues: string(name='ParamValues', description='paramValues'),
    cycTime: long(name='CycTime', description='cycTime'),
    finishTime: long(name='FinishTime', description='finishTime'),
    beginWaitTimeTime: long(name='BeginWaitTimeTime', description='beginWaitTimeTime'),
    beginWaitResTime: long(name='BeginWaitResTime', description='beginWaitResTime'),
    beginRunningTime: long(name='BeginRunningTime', description='beginRunningTime'),
    createTime: long(name='CreateTime', description='createTime'),
    modifyTime: long(name='ModifyTime', description='modifyTime'),
    nodeName: string(name='NodeName', description='nodeName'),
  }(name='Data', description='data'),
}

async function getInstanceWithOptions(request: GetInstanceRequest, runtime: Util.RuntimeOptions): GetInstanceResponse {
  Util.validateModel(request);
  return doRequest('GetInstance', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getInstance(request: GetInstanceRequest): GetInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceWithOptions(request, runtime);
}

model GetFileRequest = {
  projectId?: long(name='ProjectId', description='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier', description='ProjectIdentifier'),
  fileId?: long(name='FileId', description='FileId'),
}

model GetFileResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  data: {
    file: {
      connectionName: string(name='ConnectionName', description='connName'),
      parentId: long(name='ParentId', description='parentId'),
      isMaxCompute: boolean(name='IsMaxCompute', description='isOdps'),
      createTime: long(name='CreateTime', description='createTime'),
      createUser: string(name='CreateUser', description='createUser'),
      bizId: long(name='BizId', description='bizId'),
      fileFolderId: string(name='FileFolderId', description='fileFolderId'),
      fileName: string(name='FileName', description='fileName'),
      fileType: integer(name='FileType', description='fileType'),
      useType: string(name='UseType', description='useType'),
      fileDescription: string(name='FileDescription', description='fileDesc'),
      content: string(name='Content', description='content'),
      nodeId: long(name='NodeId', description='cloudUuid'),
      currentVersion: integer(name='CurrentVersion', description='currentVersion'),
      owner: string(name='Owner', description='owner'),
      lastEditUser: string(name='LastEditUser', description='lastEditUser'),
      lastEditTime: long(name='LastEditTime', description='lastEditTime'),
      commitStatus: integer(name='CommitStatus', description='commitStatus'),
    }(name='File', description='file'),
    nodeConfiguration: {
      autoRerunTimes: integer(name='AutoRerunTimes', description='taskRerunTime'),
      autoRerunIntervalMillis: integer(name='AutoRerunIntervalMillis', description='taskRerunIntervalMillis'),
      rerunMode: string(name='RerunMode', description='reRunAble'),
      stop: boolean(name='Stop', description='isStop'),
      paraValue: string(name='ParaValue', description='paraValue'),
      startEffectDate: long(name='StartEffectDate', description='startEffectDate'),
      endEffectDate: long(name='EndEffectDate', description='endEffectDate'),
      cronExpress: string(name='CronExpress', description='cronExpress'),
      cycleType: string(name='CycleType', description='cycleType'),
      dependentType: string(name='DependentType', description='dependentType'),
      dependentNodeIdList: string(name='DependentNodeIdList', description='dependentDataNode'),
      inputList: [
        {
          input: string(name='Input', description='str'),
        }
      ](name='InputList', description='inputList'),
      outputList: [
        {
          output: string(name='Output', description='str'),
          refTableName: string(name='RefTableName', description='refTableName'),
        }
      ](name='OutputList', description='outputList'),
    }(name='NodeConfiguration', description='nodeCfg'),
  }(name='Data', description='data'),
}

async function getFileWithOptions(request: GetFileRequest, runtime: Util.RuntimeOptions): GetFileResponse {
  Util.validateModel(request);
  return doRequest('GetFile', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getFile(request: GetFileRequest): GetFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileWithOptions(request, runtime);
}

model ListBusinessRequest = {
  projectId?: long(name='ProjectId', description='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier', description='ProjectIdentifier'),
  pageNumber: integer(name='PageNumber', description='PageNum'),
  pageSize: integer(name='PageSize', description='PageSize'),
  keyword?: string(name='Keyword', description='Keyword'),
}

model ListBusinessResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNumer'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: integer(name='TotalCount', description='totalCount'),
    business: [
      {
        businessId: long(name='BusinessId', description='bizId'),
        businessName: string(name='BusinessName', description='bizName'),
        projectId: long(name='ProjectId', description='appId'),
        owner: string(name='Owner', description='owner'),
        description: string(name='Description', description='description'),
        useType: string(name='UseType', description='useType'),
      }
    ](name='Business', description='data'),
  }(name='Data', description='data'),
}

async function listBusinessWithOptions(request: ListBusinessRequest, runtime: Util.RuntimeOptions): ListBusinessResponse {
  Util.validateModel(request);
  return doRequest('ListBusiness', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listBusiness(request: ListBusinessRequest): ListBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBusinessWithOptions(request, runtime);
}

model GetMetaDBTableListRequest = {
  pageNumber?: integer(name='PageNumber', description='pageNum'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  appGuid: string(name='AppGuid', description='appGuid'),
}

model GetMetaDBTableListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNum'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: long(name='TotalCount', description='totalCount'),
    tableEntityList: [
      {
        tableName: string(name='TableName', description='tableName'),
        tableGuid: string(name='TableGuid', description='tableGuid'),
      }
    ](name='TableEntityList', description='data'),
  }(name='Data', description='data'),
}

async function getMetaDBTableListWithOptions(request: GetMetaDBTableListRequest, runtime: Util.RuntimeOptions): GetMetaDBTableListResponse {
  Util.validateModel(request);
  return doRequest('GetMetaDBTableList', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getMetaDBTableList(request: GetMetaDBTableListRequest): GetMetaDBTableListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaDBTableListWithOptions(request, runtime);
}

model CheckMetaTableRequest = {
  tableGuid: string(name='TableGuid', description='tableGuid'),
}

model CheckMetaTableResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: boolean(name='Data', description='data'),
}

async function checkMetaTableWithOptions(request: CheckMetaTableRequest, runtime: Util.RuntimeOptions): CheckMetaTableResponse {
  Util.validateModel(request);
  return doRequest('CheckMetaTable', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function checkMetaTable(request: CheckMetaTableRequest): CheckMetaTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkMetaTableWithOptions(request, runtime);
}

model GetFolderRequest = {
  projectId?: long(name='ProjectId', description='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier', description='ProjectIdentifier'),
  folderId?: string(name='FolderId', description='folderId'),
  folderPath?: string(name='FolderPath', description='folderPath'),
}

model GetFolderResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  data: {
    folderId: string(name='FolderId', description='folderId'),
    folderPath: string(name='FolderPath', description='absolutePath'),
  }(name='Data', description='data'),
}

async function getFolderWithOptions(request: GetFolderRequest, runtime: Util.RuntimeOptions): GetFolderResponse {
  Util.validateModel(request);
  return doRequest('GetFolder', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getFolder(request: GetFolderRequest): GetFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFolderWithOptions(request, runtime);
}

model DeployFileRequest = {
  projectId?: long(name='ProjectId', description='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier', description='ProjectIdentifier'),
  fileId?: long(name='FileId', description='FileId'),
  comment?: string(name='Comment', description='Comment'),
  nodeId?: long(name='NodeId', description='NodeId'),
}

model DeployFileResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  data: long(name='Data', description='data'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function deployFileWithOptions(request: DeployFileRequest, runtime: Util.RuntimeOptions): DeployFileResponse {
  Util.validateModel(request);
  return doRequest('DeployFile', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deployFile(request: DeployFileRequest): DeployFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deployFileWithOptions(request, runtime);
}

model DeleteBusinessRequest = {
  projectId?: long(name='ProjectId', description='projectId'),
  projectIdentifier?: string(name='ProjectIdentifier', description='projectIdentifier'),
  businessId: long(name='BusinessId', description='bizId'),
}

model DeleteBusinessResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function deleteBusinessWithOptions(request: DeleteBusinessRequest, runtime: Util.RuntimeOptions): DeleteBusinessResponse {
  Util.validateModel(request);
  return doRequest('DeleteBusiness', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteBusiness(request: DeleteBusinessRequest): DeleteBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBusinessWithOptions(request, runtime);
}

model DeleteFileRequest = {
  projectId?: long(name='ProjectId', description='projectId'),
  projectIdentifier?: string(name='ProjectIdentifier', description='ProjectIdentifier'),
  fileId: long(name='FileId', description='FileId'),
}

model DeleteFileResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function deleteFileWithOptions(request: DeleteFileRequest, runtime: Util.RuntimeOptions): DeleteFileResponse {
  Util.validateModel(request);
  return doRequest('DeleteFile', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteFile(request: DeleteFileRequest): DeleteFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFileWithOptions(request, runtime);
}

model ListQualityRulesRequest = {
  projectName: string(name='ProjectName', description='projectName'),
  entityId: long(name='EntityId', description='entityId'),
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
}

model ListQualityRulesResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  success: boolean(name='Success', description='success'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    totalCount: long(name='TotalCount', description='totalCount'),
    pageNumber: integer(name='PageNumber', description='pageNumber'),
    pageSize: integer(name='PageSize', description='pageSize'),
    rules: [
      {
        projectName: string(name='ProjectName', description='projectName'),
        tableName: string(name='TableName', description='tableName'),
        id: integer(name='Id', description='id'),
        entityId: integer(name='EntityId', description='entityId'),
        property: string(name='Property', description='property'),
        methodId: integer(name='MethodId', description='methodId'),
        methodName: string(name='MethodName', description='methodName'),
        onDuty: string(name='OnDuty', description='onDuty'),
        ruleType: integer(name='RuleType', description='ruleType'),
        blockType: integer(name='BlockType', description='blockType'),
        templateId: integer(name='TemplateId', description='templateId'),
        templateName: string(name='TemplateName', description='templateName'),
        ruleCheckerRelationId: integer(name='RuleCheckerRelationId', description='ruleCheckerRelationId'),
        checkerId: integer(name='CheckerId', description='checkerId'),
        fixCheck: boolean(name='FixCheck', description='fixCheck'),
        trend: string(name='Trend', description='trend'),
        warningThreshold: string(name='WarningThreshold', description='warningThreshold'),
        criticalThreshold: string(name='CriticalThreshold', description='criticalThreshold'),
        historyWarningThreshold: string(name='HistoryWarningThreshold', description='historyWarningThreshold'),
        historyCriticalThreshold: string(name='HistoryCriticalThreshold', description='historyCriticalThreshold'),
        propertyKey: string(name='PropertyKey', description='propertyKey'),
        matchExpression: string(name='MatchExpression', description='matchExpression'),
        comment: string(name='Comment', description='comment'),
        expectValue: string(name='ExpectValue', description='expectValue'),
      }
    ](name='Rules', description='rules'),
  }(name='Data', description='data'),
}

async function listQualityRulesWithOptions(request: ListQualityRulesRequest, runtime: Util.RuntimeOptions): ListQualityRulesResponse {
  Util.validateModel(request);
  return doRequest('ListQualityRules', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listQualityRules(request: ListQualityRulesRequest): ListQualityRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQualityRulesWithOptions(request, runtime);
}

model CreateRemindRequest = {
  remindName: string(name='RemindName', description='remindName'),
  dndEnd?: string(name='DndEnd', description='dndEnd'),
  remindUnit: string(name='RemindUnit', description='remindUnit'),
  nodeIds?: string(name='NodeIds', description='nodeIds'),
  baselineIds?: string(name='BaselineIds', description='baselineIds'),
  projectId?: long(name='ProjectId', description='projectId'),
  bizProcessIds?: string(name='BizProcessIds', description='bizProcessIds'),
  remindType: string(name='RemindType', description='remindType'),
  maxAlertTimes?: integer(name='MaxAlertTimes', description='maxAlertTimes'),
  alertInterval?: integer(name='AlertInterval', description='alertInterval'),
  detail?: string(name='Detail', description='detail'),
  alertUnit: string(name='AlertUnit', description='alertUnit'),
  alertMethods?: string(name='AlertMethods', description='AlertMethods'),
  alertTargets?: string(name='AlertTargets', description='alertTargets'),
  robotUrls?: string(name='RobotUrls', description='robotUrls'),
}

model CreateRemindResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: long(name='Data', description='data'),
}

async function createRemindWithOptions(request: CreateRemindRequest, runtime: Util.RuntimeOptions): CreateRemindResponse {
  Util.validateModel(request);
  return doRequest('CreateRemind', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createRemind(request: CreateRemindRequest): CreateRemindResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRemindWithOptions(request, runtime);
}

model GetQualityRuleRequest = {
  ruleId: long(name='RuleId', description='ruleId'),
  projectName: string(name='ProjectName', description='projectName'),
}

model GetQualityRuleResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    id: long(name='Id', description='id'),
    entityId: long(name='EntityId', description='entityId'),
    property: string(name='Property', description='property'),
    methodId: integer(name='MethodId', description='methodId'),
    methodName: string(name='MethodName', description='methodName'),
    whereCondition: string(name='WhereCondition', description='whereCondition'),
    onDuty: string(name='OnDuty', description='onDuty'),
    ruleType: integer(name='RuleType', description='ruleType'),
    blockType: integer(name='BlockType', description='blockType'),
    templateId: integer(name='TemplateId', description='templateId'),
    templateName: string(name='TemplateName', description='templateName'),
    comment: string(name='Comment', description='comment'),
    ruleName: string(name='RuleName', description='ruleName'),
    predictType: integer(name='PredictType', description='predictType'),
    warningThreshold: string(name='WarningThreshold', description='warningThreshold'),
    criticalThreshold: string(name='CriticalThreshold', description='criticalThreshold'),
    operator: string(name='Operator', description='operator'),
    expectValue: string(name='ExpectValue', description='expectValue'),
    trend: string(name='Trend', description='trend'),
    checkerName: string(name='CheckerName', description='checkerName'),
    checker: integer(name='Checker', description='checker'),
    fixCheck: boolean(name='FixCheck', description='fixCheck'),
  }(name='Data', description='data'),
}

async function getQualityRuleWithOptions(request: GetQualityRuleRequest, runtime: Util.RuntimeOptions): GetQualityRuleResponse {
  Util.validateModel(request);
  return doRequest('GetQualityRule', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getQualityRule(request: GetQualityRuleRequest): GetQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQualityRuleWithOptions(request, runtime);
}

model GetDeploymentRequest = {
  projectId?: long(name='ProjectId', description='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier', description='ProjectIdentifier'),
  deploymentId: long(name='DeploymentId', description='DeploymentId'),
}

model GetDeploymentResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  data: {
    deployment: {
      name: string(name='Name', description='name'),
      creatorId: string(name='CreatorId', description='creatorId'),
      handlerId: string(name='HandlerId', description='handlerId'),
      createTime: long(name='CreateTime', description='createTime'),
      executeTime: long(name='ExecuteTime', description='executeTime'),
      status: integer(name='Status', description='status'),
      fromEnvironment: integer(name='FromEnvironment', description='fromEnv'),
      toEnvironment: integer(name='ToEnvironment', description='toEnv'),
      errorMessage: string(name='ErrorMessage', description='errMsg'),
    }(name='Deployment', description='deployment'),
  }(name='Data', description='data'),
}

async function getDeploymentWithOptions(request: GetDeploymentRequest, runtime: Util.RuntimeOptions): GetDeploymentResponse {
  Util.validateModel(request);
  return doRequest('GetDeployment', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getDeployment(request: GetDeploymentRequest): GetDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeploymentWithOptions(request, runtime);
}

model UpdateRemindRequest = {
  remindId: long(name='RemindId', description='remindId'),
  remindName?: string(name='RemindName', description='remindName'),
  dndEnd?: string(name='DndEnd', description='dndEnd'),
  remindUnit?: string(name='RemindUnit', description='remindUnit'),
  nodeIds?: string(name='NodeIds', description='nodeIds'),
  baselineIds?: string(name='BaselineIds', description='baselineIds'),
  projectId?: long(name='ProjectId', description='projectId'),
  bizProcessIds?: string(name='BizProcessIds', description='bizProcessIds'),
  remindType?: string(name='RemindType', description='remindType'),
  maxAlertTimes?: integer(name='MaxAlertTimes', description='maxAlertTimes'),
  alertInterval?: integer(name='AlertInterval', description='alertInterval'),
  detail?: string(name='Detail', description='detail'),
  alertUnit?: string(name='AlertUnit', description='alertUnit'),
  alertMethods?: string(name='AlertMethods', description='alertMethods'),
  alertTargets?: string(name='AlertTargets', description='alertTargets'),
  useFlag?: boolean(name='UseFlag', description='useFlag'),
  robotUrls?: string(name='RobotUrls', description='robotUrls'),
}

model UpdateRemindResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: boolean(name='Data', description='data'),
}

async function updateRemindWithOptions(request: UpdateRemindRequest, runtime: Util.RuntimeOptions): UpdateRemindResponse {
  Util.validateModel(request);
  return doRequest('UpdateRemind', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateRemind(request: UpdateRemindRequest): UpdateRemindResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRemindWithOptions(request, runtime);
}

model GetMetaColumnLineageRequest = {
  columnGuid: string(name='ColumnGuid', description='columnGuid'),
  direction: string(name='Direction', description='direction'),
  pageNum?: integer(name='PageNum', description='pageNum'),
  pageSize?: integer(name='PageSize', description='pageSize'),
}

model GetMetaColumnLineageResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: {
    totalCount: long(name='TotalCount', description='totalCount'),
    pageNum: integer(name='PageNum', description='pageNum'),
    pageSize: integer(name='PageSize', description='pageSize'),
    dataEntityList: [
      {
        columnName: string(name='ColumnName', description='columnName'),
        columnGuid: string(name='ColumnGuid', description='columnGuid'),
      }
    ](name='DataEntityList', description='data'),
  }(name='Data', description='data'),
}

async function getMetaColumnLineageWithOptions(request: GetMetaColumnLineageRequest, runtime: Util.RuntimeOptions): GetMetaColumnLineageResponse {
  Util.validateModel(request);
  return doRequest('GetMetaColumnLineage', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getMetaColumnLineage(request: GetMetaColumnLineageRequest): GetMetaColumnLineageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaColumnLineageWithOptions(request, runtime);
}

model UpdateBusinessRequest = {
  projectId?: long(name='ProjectId', description='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier', description='ProjectIdentifier'),
  businessName?: string(name='BusinessName', description='BizName'),
  description?: string(name='Description', description='Description'),
  owner?: string(name='Owner', description='Owner'),
  businessId: long(name='BusinessId', description='BizId'),
}

model UpdateBusinessResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function updateBusinessWithOptions(request: UpdateBusinessRequest, runtime: Util.RuntimeOptions): UpdateBusinessResponse {
  Util.validateModel(request);
  return doRequest('UpdateBusiness', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateBusiness(request: UpdateBusinessRequest): UpdateBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateBusinessWithOptions(request, runtime);
}

model UpdateQualityRuleRequest = {
  blockType?: integer(name='BlockType', description='blockType'),
  entityId?: long(name='EntityId', description='entityId'),
  comment?: string(name='Comment', description='comment'),
  checker?: integer(name='Checker', description='checker'),
  expectValue?: string(name='ExpectValue', description='expectValue'),
  id: long(name='Id', description='id'),
  trend?: string(name='Trend', description='trend'),
  methodName?: string(name='MethodName', description='methodName'),
  operator?: string(name='Operator', description='operator'),
  projectName: string(name='ProjectName', description='projectName'),
  property?: string(name='Property', description='property'),
  propertyType?: string(name='PropertyType', description='propertyType'),
  ruleType?: integer(name='RuleType', description='ruleType'),
  whereCondition?: string(name='WhereCondition', description='whereCondition'),
  criticalThreshold?: string(name='CriticalThreshold', description='criticalThreshold'),
  warningThreshold?: string(name='WarningThreshold', description='warningThreshold'),
  templateId?: integer(name='TemplateId', description='templateId'),
  ruleName?: string(name='RuleName', description='ruleName'),
  predictType?: integer(name='PredictType', description='predictType'),
}

model UpdateQualityRuleResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  data: boolean(name='Data', description='data'),
  success: boolean(name='Success', description='success'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
}

async function updateQualityRuleWithOptions(request: UpdateQualityRuleRequest, runtime: Util.RuntimeOptions): UpdateQualityRuleResponse {
  Util.validateModel(request);
  return doRequest('UpdateQualityRule', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateQualityRule(request: UpdateQualityRuleRequest): UpdateQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateQualityRuleWithOptions(request, runtime);
}

model DeleteQualityRuleRequest = {
  projectName: string(name='ProjectName', description='projectName'),
  ruleId: long(name='RuleId', description='ruleId'),
}

model DeleteQualityRuleResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  data: boolean(name='Data', description='data'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  success: boolean(name='Success', description='success'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteQualityRuleWithOptions(request: DeleteQualityRuleRequest, runtime: Util.RuntimeOptions): DeleteQualityRuleResponse {
  Util.validateModel(request);
  return doRequest('DeleteQualityRule', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteQualityRule(request: DeleteQualityRuleRequest): DeleteQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQualityRuleWithOptions(request, runtime);
}

model SubmitFileRequest = {
  projectId?: long(name='ProjectId', description='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier', description='ProjectIdentifier'),
  fileId: long(name='FileId', description='FileId'),
  comment?: string(name='Comment', description='Comment'),
}

model SubmitFileResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  data: long(name='Data', description='data'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
}

async function submitFileWithOptions(request: SubmitFileRequest, runtime: Util.RuntimeOptions): SubmitFileResponse {
  Util.validateModel(request);
  return doRequest('SubmitFile', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function submitFile(request: SubmitFileRequest): SubmitFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFileWithOptions(request, runtime);
}

model GetDataServiceApiRequest = {
  tenantId: long(name='TenantId', description='tenantId'),
  projectId: long(name='ProjectId', description='projectId'),
  apiId: long(name='ApiId', description='apiId'),
}

model GetDataServiceApiResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  data: {
    apiId: long(name='ApiId', description='apiId'),
    apiMode: integer(name='ApiMode', description='apiMode'),
    apiName: string(name='ApiName', description='apiName'),
    apiPath: string(name='ApiPath', description='apiPath'),
    createdTime: string(name='CreatedTime', description='gmtCreate'),
    creatorId: string(name='CreatorId', description='creator'),
    description: string(name='Description', description='apiDesc'),
    groupId: string(name='GroupId', description='groupId'),
    modifiedTime: string(name='ModifiedTime', description='gmtModified'),
    operatorId: string(name='OperatorId', description='operator'),
    projectId: long(name='ProjectId', description='projectId'),
    requestMethod: integer(name='RequestMethod', description='apiHttpMethod'),
    responseContentType: integer(name='ResponseContentType', description='apiResultType'),
    status: integer(name='Status', description='apiStatus'),
    tenantId: long(name='TenantId', description='tenantId'),
    timeout: integer(name='Timeout', description='apiTimeout'),
    visibleRange: integer(name='VisibleRange', description='securityLevel'),
    registrationDetails: {
      failedResultSample: string(name='FailedResultSample', description='failResultSample'),
      serviceContentType: integer(name='ServiceContentType', description='contentType'),
      serviceHost: string(name='ServiceHost', description='host'),
      servicePath: string(name='ServicePath', description='path'),
      serviceRequestBodyDescription: string(name='ServiceRequestBodyDescription', description='bodyDescription'),
      successfulResultSample: string(name='SuccessfulResultSample', description='successResultSample'),
      registrationErrorCodes: [
        {
          errorCode: string(name='ErrorCode', description='errorCode'),
          errorMessage: string(name='ErrorMessage', description='errorMsg'),
          errorSolution: string(name='ErrorSolution', description='errorSolution'),
        }
      ](name='RegistrationErrorCodes', description='apiErrorCodes'),
      registrationRequestParameters: [
        {
          columnName: string(name='ColumnName', description='columnName'),
          defaultValue: string(name='DefaultValue', description='defaultValue'),
          exampleValue: string(name='ExampleValue', description='exampleValue'),
          isRequiredParameter: boolean(name='IsRequiredParameter', description='required'),
          parameterDataType: integer(name='ParameterDataType', description='paramType'),
          parameterDescription: string(name='ParameterDescription', description='paramDesc'),
          parameterName: string(name='ParameterName', description='paramName'),
          parameterOperator: integer(name='ParameterOperator', description='paramOperator'),
          parameterPosition: integer(name='ParameterPosition', description='paramPosition'),
        }
      ](name='RegistrationRequestParameters', description='requestParams'),
    }(name='RegistrationDetails', description='registeredApiDetails'),
    scriptDetails: {
      isPagedResponse: boolean(name='IsPagedResponse', description='responsePaged'),
      script: string(name='Script', description='apiSql'),
      scriptRequestParameters: [
        {
          columnName: string(name='ColumnName', description='columnName'),
          defaultValue: string(name='DefaultValue', description='defaultValue'),
          exampleValue: string(name='ExampleValue', description='exampleValue'),
          isRequiredParameter: boolean(name='IsRequiredParameter', description='required'),
          parameterDataType: integer(name='ParameterDataType', description='paramType'),
          parameterDescription: string(name='ParameterDescription', description='paramDesc'),
          parameterName: string(name='ParameterName', description='paramName'),
          parameterOperator: integer(name='ParameterOperator', description='paramOperator'),
          parameterPosition: integer(name='ParameterPosition', description='paramPosition'),
        }
      ](name='ScriptRequestParameters', description='requestParams'),
      scriptResponseParameters: [
        {
          columnName: string(name='ColumnName', description='columnName'),
          exampleValue: string(name='ExampleValue', description='exampleValue'),
          parameterDataType: integer(name='ParameterDataType', description='paramType'),
          parameterDescription: string(name='ParameterDescription', description='paramDesc'),
          parameterName: string(name='ParameterName', description='paramName'),
        }
      ](name='ScriptResponseParameters', description='responseParams'),
      scriptConnection: {
        connectionId: long(name='ConnectionId', description='connectionId'),
        tableName: string(name='TableName', description='tableName'),
      }(name='ScriptConnection', description='connection'),
    }(name='ScriptDetails', description='scriptApiDetails'),
    wizardDetails: {
      isPagedResponse: boolean(name='IsPagedResponse', description='responsePaged'),
      wizardRequestParameters: [
        {
          columnName: string(name='ColumnName', description='columnName'),
          defaultValue: string(name='DefaultValue', description='defaultValue'),
          exampleValue: string(name='ExampleValue', description='exampleValue'),
          isRequiredParameter: boolean(name='IsRequiredParameter', description='required'),
          parameterDataType: integer(name='ParameterDataType', description='paramType'),
          parameterDescription: string(name='ParameterDescription', description='paramDesc'),
          parameterName: string(name='ParameterName', description='paramName'),
          parameterOperator: integer(name='ParameterOperator', description='paramOperator'),
          parameterPosition: integer(name='ParameterPosition', description='paramPosition'),
        }
      ](name='WizardRequestParameters', description='requestParams'),
      wizardResponseParameters: [
        {
          columnName: string(name='ColumnName', description='columnName'),
          exampleValue: string(name='ExampleValue', description='exampleValue'),
          parameterDataType: integer(name='ParameterDataType', description='paramType'),
          parameterDescription: string(name='ParameterDescription', description='paramDesc'),
          parameterName: string(name='ParameterName', description='paramName'),
        }
      ](name='WizardResponseParameters', description='responseParams'),
      wizardConnection: {
        connectionId: long(name='ConnectionId', description='connectionId'),
        tableName: string(name='TableName', description='tableName'),
      }(name='WizardConnection', description='connection'),
    }(name='WizardDetails', description='wizardApiDetails'),
    protocols: [ integer ](name='Protocols', description='apiProtocolList'),
  }(name='Data', description='data'),
}

async function getDataServiceApiWithOptions(request: GetDataServiceApiRequest, runtime: Util.RuntimeOptions): GetDataServiceApiResponse {
  Util.validateModel(request);
  return doRequest('GetDataServiceApi', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getDataServiceApi(request: GetDataServiceApiRequest): GetDataServiceApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataServiceApiWithOptions(request, runtime);
}

model ListDataServiceApisRequest = {
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  projectId: long(name='ProjectId', description='projectId'),
  tenantId: long(name='TenantId', description='tenantId'),
  apiNameKeyword?: string(name='ApiNameKeyword', description='apiNameKeyword'),
  apiPathKeyword?: string(name='ApiPathKeyword', description='apiPathKeyword'),
  creatorId?: string(name='CreatorId', description='creator'),
}

model ListDataServiceApisResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNumber'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: integer(name='TotalCount', description='totalCount'),
    apis: [
      {
        apiId: long(name='ApiId', description='apiId'),
        apiMode: integer(name='ApiMode', description='apiMode'),
        apiName: string(name='ApiName', description='apiName'),
        apiPath: string(name='ApiPath', description='apiPath'),
        createdTime: string(name='CreatedTime', description='gmtCreate'),
        creatorId: string(name='CreatorId', description='creator'),
        description: string(name='Description', description='apiDesc'),
        groupId: string(name='GroupId', description='groupId'),
        modifiedTime: string(name='ModifiedTime', description='gmtModified'),
        operatorId: string(name='OperatorId', description='operator'),
        projectId: long(name='ProjectId', description='projectId'),
        requestMethod: integer(name='RequestMethod', description='apiHttpMethod'),
        responseContentType: integer(name='ResponseContentType', description='apiResultType'),
        status: integer(name='Status', description='apiStatus'),
        tenantId: long(name='TenantId', description='tenantId'),
        timeout: integer(name='Timeout', description='apiTimeout'),
        visibleRange: integer(name='VisibleRange', description='securityLevel'),
        registrationDetails: {
          failedResultSample: string(name='FailedResultSample', description='failResultSample'),
          serviceContentType: integer(name='ServiceContentType', description='contentType'),
          serviceHost: string(name='ServiceHost', description='host'),
          servicePath: string(name='ServicePath', description='path'),
          serviceRequestBodyDescription: string(name='ServiceRequestBodyDescription', description='bodyDescription'),
          successfulResultSample: string(name='SuccessfulResultSample', description='successResultSample'),
          registrationErrorCodes: [
            {
              errorCode: string(name='ErrorCode', description='errorCode'),
              errorMessage: string(name='ErrorMessage', description='errorMsg'),
              errorSolution: string(name='ErrorSolution', description='errorSolution'),
            }
          ](name='RegistrationErrorCodes', description='apiErrorCodes'),
          registrationRequestParameters: [
            {
              columnName: string(name='ColumnName', description='columnName'),
              defaultValue: string(name='DefaultValue', description='defaultValue'),
              exampleValue: string(name='ExampleValue', description='exampleValue'),
              isRequiredParameter: boolean(name='IsRequiredParameter', description='required'),
              parameterDataType: integer(name='ParameterDataType', description='paramType'),
              parameterDescription: string(name='ParameterDescription', description='paramDesc'),
              parameterName: string(name='ParameterName', description='paramName'),
              parameterOperator: integer(name='ParameterOperator', description='paramOperator'),
              parameterPosition: integer(name='ParameterPosition', description='paramPosition'),
            }
          ](name='RegistrationRequestParameters', description='requestParams'),
        }(name='RegistrationDetails', description='registeredApiDetails'),
        scriptDetails: {
          isPagedResponse: boolean(name='IsPagedResponse', description='responsePaged'),
          script: string(name='Script', description='apiSql'),
          scriptRequestParameters: [
            {
              columnName: string(name='ColumnName', description='columnName'),
              defaultValue: string(name='DefaultValue', description='defaultValue'),
              exampleValue: string(name='ExampleValue', description='exampleValue'),
              isRequiredParameter: boolean(name='IsRequiredParameter', description='required'),
              parameterDataType: integer(name='ParameterDataType', description='paramType'),
              parameterDescription: string(name='ParameterDescription', description='paramDesc'),
              parameterName: string(name='ParameterName', description='paramName'),
              parameterOperator: integer(name='ParameterOperator', description='paramOperator'),
              parameterPosition: integer(name='ParameterPosition', description='paramPosition'),
            }
          ](name='ScriptRequestParameters', description='requestParams'),
          scriptResponseParameters: [
            {
              columnName: string(name='ColumnName', description='columnName'),
              exampleValue: string(name='ExampleValue', description='exampleValue'),
              parameterDataType: integer(name='ParameterDataType', description='paramType'),
              parameterDescription: string(name='ParameterDescription', description='paramDesc'),
              parameterName: string(name='ParameterName', description='paramName'),
            }
          ](name='ScriptResponseParameters', description='responseParams'),
          scriptConnection: {
            connectionId: long(name='ConnectionId', description='connectionId'),
            tableName: string(name='TableName', description='tableName'),
          }(name='ScriptConnection', description='connection'),
        }(name='ScriptDetails', description='scriptApiDetails'),
        wizardDetails: {
          isPagedResponse: boolean(name='IsPagedResponse', description='responsePaged'),
          wizardRequestParameters: [
            {
              columnName: string(name='ColumnName', description='columnName'),
              defaultValue: string(name='DefaultValue', description='defaultValue'),
              exampleValue: string(name='ExampleValue', description='exampleValue'),
              isRequiredParameter: boolean(name='IsRequiredParameter', description='required'),
              parameterDataType: integer(name='ParameterDataType', description='paramType'),
              parameterDescription: string(name='ParameterDescription', description='paramDesc'),
              parameterName: string(name='ParameterName', description='paramName'),
              parameterOperator: integer(name='ParameterOperator', description='paramOperator'),
              parameterPosition: integer(name='ParameterPosition', description='paramPosition'),
            }
          ](name='WizardRequestParameters', description='requestParams'),
          wizardResponseParameters: [
            {
              columnName: string(name='ColumnName', description='columnName'),
              exampleValue: string(name='ExampleValue', description='exampleValue'),
              parameterDataType: integer(name='ParameterDataType', description='paramType'),
              parameterDescription: string(name='ParameterDescription', description='paramDesc'),
              parameterName: string(name='ParameterName', description='paramName'),
            }
          ](name='WizardResponseParameters', description='responseParams'),
          wizardConnection: {
            connectionId: long(name='ConnectionId', description='connectionId'),
            tableName: string(name='TableName', description='tableName'),
          }(name='WizardConnection', description='connection'),
        }(name='WizardDetails', description='wizardApiDetails'),
        protocols: [ integer ](name='Protocols', description='apiProtocolList'),
      }
    ](name='Apis', description='data'),
  }(name='Data', description='data'),
}

async function listDataServiceApisWithOptions(request: ListDataServiceApisRequest, runtime: Util.RuntimeOptions): ListDataServiceApisResponse {
  Util.validateModel(request);
  return doRequest('ListDataServiceApis', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listDataServiceApis(request: ListDataServiceApisRequest): ListDataServiceApisResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServiceApisWithOptions(request, runtime);
}

model GetDataServicePublishedApiRequest = {
  projectId: long(name='ProjectId', description='projectId'),
  tenantId: long(name='TenantId', description='tenantId'),
  apiId: long(name='ApiId', description='apiId'),
}

model GetDataServicePublishedApiResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  data: {
    apiId: long(name='ApiId', description='apiId'),
    apiMode: integer(name='ApiMode', description='apiMode'),
    apiName: string(name='ApiName', description='apiName'),
    apiPath: string(name='ApiPath', description='apiPath'),
    createdTime: string(name='CreatedTime', description='gmtCreate'),
    creatorId: string(name='CreatorId', description='creator'),
    description: string(name='Description', description='apiDesc'),
    groupId: string(name='GroupId', description='groupId'),
    modifiedTime: string(name='ModifiedTime', description='gmtModified'),
    operatorId: string(name='OperatorId', description='operator'),
    projectId: long(name='ProjectId', description='projectId'),
    requestMethod: integer(name='RequestMethod', description='apiHttpMethod'),
    responseContentType: integer(name='ResponseContentType', description='apiResultType'),
    status: integer(name='Status', description='apiStatus'),
    tenantId: long(name='TenantId', description='tenantId'),
    timeout: integer(name='Timeout', description='apiTimeout'),
    visibleRange: integer(name='VisibleRange', description='securityLevel'),
    registrationDetails: {
      failedResultSample: string(name='FailedResultSample', description='failResultSample'),
      serviceContentType: integer(name='ServiceContentType', description='contentType'),
      serviceHost: string(name='ServiceHost', description='host'),
      servicePath: string(name='ServicePath', description='path'),
      serviceRequestBodyDescription: string(name='ServiceRequestBodyDescription', description='bodyDescription'),
      successfulResultSample: string(name='SuccessfulResultSample', description='successResultSample'),
      registrationErrorCodes: [
        {
          errorCode: string(name='ErrorCode', description='errorCode'),
          errorMessage: string(name='ErrorMessage', description='errorMsg'),
          errorSolution: string(name='ErrorSolution', description='errorSolution'),
        }
      ](name='RegistrationErrorCodes', description='apiErrorCodes'),
      registrationRequestParameters: [
        {
          defaultValue: string(name='DefaultValue', description='defaultValue'),
          exampleValue: string(name='ExampleValue', description='exampleValue'),
          isRequiredParameter: boolean(name='IsRequiredParameter', description='required'),
          parameterDataType: integer(name='ParameterDataType', description='paramType'),
          parameterDescription: string(name='ParameterDescription', description='paramDesc'),
          parameterName: string(name='ParameterName', description='paramName'),
          parameterOperator: integer(name='ParameterOperator', description='paramOperator'),
          parameterPosition: integer(name='ParameterPosition', description='paramPosition'),
        }
      ](name='RegistrationRequestParameters', description='requestParams'),
    }(name='RegistrationDetails', description='registeredApiDetails'),
    scriptDetails: {
      failedResultSample: string(name='FailedResultSample', description='failResultSample'),
      isPagedResponse: boolean(name='IsPagedResponse', description='responsePaged'),
      script: string(name='Script', description='apiSql'),
      successfulResultSample: string(name='SuccessfulResultSample', description='successResultSample'),
      scriptErrorCodes: [
        {
          errorCode: string(name='ErrorCode', description='errorCode'),
          errorMessage: string(name='ErrorMessage', description='errorMsg'),
          errorSolution: string(name='ErrorSolution', description='errorSolution'),
        }
      ](name='ScriptErrorCodes', description='apiErrorCodes'),
      scriptRequestParameters: [
        {
          defaultValue: string(name='DefaultValue', description='defaultValue'),
          exampleValue: string(name='ExampleValue', description='exampleValue'),
          isRequiredParameter: boolean(name='IsRequiredParameter', description='required'),
          parameterDataType: integer(name='ParameterDataType', description='paramType'),
          parameterDescription: string(name='ParameterDescription', description='paramDesc'),
          parameterName: string(name='ParameterName', description='paramName'),
          parameterOperator: integer(name='ParameterOperator', description='paramOperator'),
          parameterPosition: integer(name='ParameterPosition', description='paramPosition'),
        }
      ](name='ScriptRequestParameters', description='requestParams'),
      scriptResponseParameters: [
        {
          exampleValue: string(name='ExampleValue', description='exampleValue'),
          parameterDataType: integer(name='ParameterDataType', description='paramType'),
          parameterDescription: string(name='ParameterDescription', description='paramDesc'),
          parameterName: string(name='ParameterName', description='paramName'),
        }
      ](name='ScriptResponseParameters', description='responseParams'),
      scriptConnection: {
        connectionId: long(name='ConnectionId', description='connectionId'),
        tableName: string(name='TableName', description='tableName'),
      }(name='ScriptConnection', description='connection'),
    }(name='ScriptDetails', description='scriptApiDetails'),
    wizardDetails: {
      failedResultSample: string(name='FailedResultSample', description='failResultSample'),
      isPagedResponse: boolean(name='IsPagedResponse', description='responsePaged'),
      successfulResultSample: string(name='SuccessfulResultSample', description='successResultSample'),
      wizardErrorCodes: [
        {
          errorCode: string(name='ErrorCode', description='errorCode'),
          errorMessage: string(name='ErrorMessage', description='errorMsg'),
          errorSolution: string(name='ErrorSolution', description='errorSolution'),
        }
      ](name='WizardErrorCodes', description='apiErrorCodes'),
      wizardRequestParameters: [
        {
          defaultValue: string(name='DefaultValue', description='defaultValue'),
          exampleValue: string(name='ExampleValue', description='exampleValue'),
          isRequiredParameter: boolean(name='IsRequiredParameter', description='required'),
          parameterDataType: integer(name='ParameterDataType', description='paramType'),
          parameterDescription: string(name='ParameterDescription', description='paramDesc'),
          parameterName: string(name='ParameterName', description='paramName'),
          parameterOperator: integer(name='ParameterOperator', description='paramOperator'),
          parameterPosition: integer(name='ParameterPosition', description='paramPosition'),
        }
      ](name='WizardRequestParameters', description='requestParams'),
      wizardResponseParameters: [
        {
          exampleValue: string(name='ExampleValue', description='exampleValue'),
          parameterDataType: integer(name='ParameterDataType', description='paramType'),
          parameterDescription: string(name='ParameterDescription', description='paramDesc'),
          parameterName: string(name='ParameterName', description='paramName'),
        }
      ](name='WizardResponseParameters', description='responseParams'),
      wizardConnection: {
        connectionId: long(name='ConnectionId', description='connectionId'),
        tableName: string(name='TableName', description='tableName'),
      }(name='WizardConnection', description='connection'),
    }(name='WizardDetails', description='wizardApiDetails'),
    protocols: [ integer ](name='Protocols', description='apiProtocolList'),
  }(name='Data', description='data'),
}

async function getDataServicePublishedApiWithOptions(request: GetDataServicePublishedApiRequest, runtime: Util.RuntimeOptions): GetDataServicePublishedApiResponse {
  Util.validateModel(request);
  return doRequest('GetDataServicePublishedApi', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getDataServicePublishedApi(request: GetDataServicePublishedApiRequest): GetDataServicePublishedApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataServicePublishedApiWithOptions(request, runtime);
}

model GetBaselineKeyPathRequest = {
  baselineId: long(name='BaselineId', description='baselineId'),
  bizdate: string(name='Bizdate', description='bizdate'),
  inGroupId: integer(name='InGroupId', description='inGroupId'),
}

model GetBaselineKeyPathResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: [
    {
      instanceId: long(name='InstanceId', description='instanceId'),
      projectId: long(name='ProjectId', description='projectId'),
      nodeId: long(name='NodeId', description='nodeId'),
      nodeName: string(name='NodeName', description='nodeName'),
      bizdate: long(name='Bizdate', description='bizdate'),
      inGroupId: integer(name='InGroupId', description='inGroupId'),
      owner: string(name='Owner', description='owner'),
      prgType: integer(name='PrgType', description='prgType'),
      runs: [
        {
          absTime: long(name='AbsTime', description='absTime'),
          beginCast: long(name='BeginCast', description='beginCast'),
          beginRunningTime: long(name='BeginRunningTime', description='beginRunningTim'),
          beginWaitResTime: long(name='BeginWaitResTime', description='beginWaitResTime'),
          beginWaitTimeTime: long(name='BeginWaitTimeTime', description='beginWaitTimeTime'),
          bizdate: long(name='Bizdate', description='bizdate'),
          cycTime: long(name='CycTime', description='cycTime'),
          endCast: long(name='EndCast', description='endCast'),
          finishTime: long(name='FinishTime', description='finishTime'),
          inGroupId: integer(name='InGroupId', description='inGroupId'),
          instanceId: long(name='InstanceId', description='instanceId'),
          nodeId: long(name='NodeId', description='nodeId'),
          nodeName: string(name='NodeName', description='nodeName'),
          owner: string(name='Owner', description='owner'),
          projectId: long(name='ProjectId', description='projectId'),
          status: string(name='Status', description='status'),
        }
      ](name='Runs', description='runs'),
      topics: [
        {
          instanceId: long(name='InstanceId', description='instanceId'),
          topicId: long(name='TopicId', description='topicId'),
          topicName: long(name='TopicName', description='topicName'),
          addTime: long(name='AddTime', description='addTime'),
        }
      ](name='Topics', description='topics'),
    }
  ](name='Data', description='data'),
}

async function getBaselineKeyPathWithOptions(request: GetBaselineKeyPathRequest, runtime: Util.RuntimeOptions): GetBaselineKeyPathResponse {
  Util.validateModel(request);
  return doRequest('GetBaselineKeyPath', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getBaselineKeyPath(request: GetBaselineKeyPathRequest): GetBaselineKeyPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBaselineKeyPathWithOptions(request, runtime);
}

model GetRemindRequest = {
  remindId: long(name='RemindId', description='remindId'),
}

model GetRemindResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    remindId: long(name='RemindId', description='remindId'),
    remindName: string(name='RemindName', description='remindName'),
    dndStart: string(name='DndStart', description='dndStart'),
    dndEnd: string(name='DndEnd', description='dndEnd'),
    remindUnit: string(name='RemindUnit', description='remindUnit'),
    remindType: string(name='RemindType', description='remindType'),
    alertUnit: string(name='AlertUnit', description='alertUnit'),
    useflag: boolean(name='Useflag', description='useflag'),
    founder: string(name='Founder', description='founder'),
    alertInterval: integer(name='AlertInterval', description='alertInterval'),
    detail: string(name='Detail', description='detail'),
    maxAlertTimes: integer(name='MaxAlertTimes', description='maxAlertTimes'),
    robots: [
      {
        webUrl: string(name='WebUrl', description='webUrl'),
        atAll: boolean(name='AtAll', description='atAll'),
      }
    ](name='Robots', description='robots'),
    nodes: [
      {
        nodeId: long(name='NodeId', description='nodeId'),
        nodeName: string(name='NodeName', description='nodeName'),
        owner: string(name='Owner', description='owner'),
        projectId: long(name='ProjectId', description='projectId'),
      }
    ](name='Nodes', description='nodes'),
    baselines: [
      {
        baselineId: long(name='BaselineId', description='baselineId'),
        baselineName: string(name='BaselineName', description='baselineName'),
      }
    ](name='Baselines', description='baselines'),
    projects: [
      {
        projectId: long(name='ProjectId', description='projectId'),
      }
    ](name='Projects', description='projects'),
    bizProcesses: [
      {
        bizId: long(name='BizId', description='bizId'),
        bizProcessName: string(name='BizProcessName', description='bizProcessName'),
      }
    ](name='BizProcesses', description='bizProcesses'),
    alertMethods: [ string ](name='AlertMethods', description='alertMethods'),
    alertTargets: [ string ](name='AlertTargets', description='alertTargets'),
  }(name='Data', description='data'),
}

async function getRemindWithOptions(request: GetRemindRequest, runtime: Util.RuntimeOptions): GetRemindResponse {
  Util.validateModel(request);
  return doRequest('GetRemind', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getRemind(request: GetRemindRequest): GetRemindResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRemindWithOptions(request, runtime);
}

model GetMetaTableIntroWikiRequest = {
  tableGuid: string(name='TableGuid', description='tableGuid'),
  wikiVersion?: long(name='WikiVersion', description='wikiVersion'),
}

model GetMetaTableIntroWikiResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: {
    createTime: long(name='CreateTime', description='createTimestamp'),
    modifiedTime: long(name='ModifiedTime', description='modifiedTimestamp'),
    creator: string(name='Creator', description='creator'),
    version: long(name='Version', description='version'),
    creatorName: string(name='CreatorName', description='creatorName'),
    content: string(name='Content', description='content'),
  }(name='Data', description='data'),
}

async function getMetaTableIntroWikiWithOptions(request: GetMetaTableIntroWikiRequest, runtime: Util.RuntimeOptions): GetMetaTableIntroWikiResponse {
  Util.validateModel(request);
  return doRequest('GetMetaTableIntroWiki', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getMetaTableIntroWiki(request: GetMetaTableIntroWikiRequest): GetMetaTableIntroWikiResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableIntroWikiWithOptions(request, runtime);
}

model GetBaselineStatusRequest = {
  baselineId: long(name='BaselineId', description='baselineId'),
  bizdate: string(name='Bizdate', description='bizdate'),
  inGroupId: integer(name='InGroupId', description='inGroupId'),
}

model GetBaselineStatusResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    baselineName: string(name='BaselineName', description='baselineName'),
    baselineId: long(name='BaselineId', description='baselineId'),
    bizdate: long(name='Bizdate', description='bizdate'),
    owner: string(name='Owner', description='owner'),
    expTime: long(name='ExpTime', description='expTime'),
    finishTime: long(name='FinishTime', description='finishTime'),
    endCast: long(name='EndCast', description='endCast'),
    slaTime: long(name='SlaTime', description='slaTime'),
    priority: integer(name='Priority', description='priority'),
    projectId: long(name='ProjectId', description='projectId'),
    buffer: float(name='Buffer', description='buffer'),
    status: string(name='Status', description='status'),
    finishStatus: string(name='FinishStatus', description='finishStatus'),
    inGroupId: integer(name='InGroupId', description='inGroupId'),
    lastInstance: {
      instanceId: long(name='InstanceId', description='instanceId'),
      status: string(name='Status', description='status'),
      projectId: long(name='ProjectId', description='projectId'),
      owner: string(name='Owner', description='owner'),
      nodeId: long(name='NodeId', description='nodeId'),
      finishTime: long(name='FinishTime', description='finishTime'),
      endCast: long(name='EndCast', description='endCast'),
      nodeName: string(name='NodeName', description='nodeName'),
    }(name='LastInstance', description='lastInstance'),
    blockInstance: {
      instanceId: long(name='InstanceId', description='instanceId'),
      status: string(name='Status', description='status'),
      projectId: long(name='ProjectId', description='projectId'),
      owner: string(name='Owner', description='owner'),
      nodeId: long(name='NodeId', description='nodeId'),
      finishTime: long(name='FinishTime', description='finishTime'),
      endCast: long(name='EndCast', description='endCast'),
      nodeName: string(name='NodeName', description='nodeName'),
    }(name='BlockInstance', description='blockInstance'),
  }(name='Data', description='data'),
}

async function getBaselineStatusWithOptions(request: GetBaselineStatusRequest, runtime: Util.RuntimeOptions): GetBaselineStatusResponse {
  Util.validateModel(request);
  return doRequest('GetBaselineStatus', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getBaselineStatus(request: GetBaselineStatusRequest): GetBaselineStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBaselineStatusWithOptions(request, runtime);
}

model DeleteDataServiceApiRequest = {
  tenantId: long(name='TenantId', description='tenantId'),
  projectId: long(name='ProjectId', description='projectId'),
  apiId: long(name='ApiId', description='apiId'),
}

model DeleteDataServiceApiResponse = {
  data: boolean(name='Data', description='data'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
}

async function deleteDataServiceApiWithOptions(request: DeleteDataServiceApiRequest, runtime: Util.RuntimeOptions): DeleteDataServiceApiResponse {
  Util.validateModel(request);
  return doRequest('DeleteDataServiceApi', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteDataServiceApi(request: DeleteDataServiceApiRequest): DeleteDataServiceApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDataServiceApiWithOptions(request, runtime);
}

model PublishDataServiceApiRequest = {
  tenantId: long(name='TenantId', description='tenantId'),
  projectId: long(name='ProjectId', description='projectId'),
  apiId: long(name='ApiId', description='apiId'),
}

model PublishDataServiceApiResponse = {
  data: boolean(name='Data', description='data'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
}

async function publishDataServiceApiWithOptions(request: PublishDataServiceApiRequest, runtime: Util.RuntimeOptions): PublishDataServiceApiResponse {
  Util.validateModel(request);
  return doRequest('PublishDataServiceApi', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function publishDataServiceApi(request: PublishDataServiceApiRequest): PublishDataServiceApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishDataServiceApiWithOptions(request, runtime);
}

model GetMetaTableLineageRequest = {
  tableGuid: string(name='TableGuid', description='tableGuid'),
  direction: string(name='Direction', description='direction'),
  nextPrimaryKey?: string(name='NextPrimaryKey', description='nextPrimaryKey'),
  pageSize?: integer(name='PageSize', description='pageSize'),
}

model GetMetaTableLineageResponse = {
  requestId: string(name='RequestId', description='requestId'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  data: {
    hasNext: boolean(name='HasNext', description='hasNext'),
    nextPrimaryKey: string(name='NextPrimaryKey', description='nextPrimaryKey'),
    dataEntityList: [
      {
        tableName: string(name='TableName', description='tableName'),
        tableGuid: string(name='TableGuid', description='tableGuid'),
      }
    ](name='DataEntityList', description='recordList'),
  }(name='Data', description='data'),
}

async function getMetaTableLineageWithOptions(request: GetMetaTableLineageRequest, runtime: Util.RuntimeOptions): GetMetaTableLineageResponse {
  Util.validateModel(request);
  return doRequest('GetMetaTableLineage', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getMetaTableLineage(request: GetMetaTableLineageRequest): GetMetaTableLineageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableLineageWithOptions(request, runtime);
}

model ListBaselineStatusesRequest = {
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  bizdate: string(name='Bizdate', description='bizdate'),
  priority?: string(name='Priority', description='priority'),
  searchText?: string(name='SearchText', description='searchText'),
  owner?: string(name='Owner', description='owner'),
  topicId?: long(name='TopicId', description='topicId'),
  finishStatus?: string(name='FinishStatus', description='finishStatus'),
  status?: string(name='Status', description='status'),
  baselineTypes?: string(name='BaselineTypes', description='baselineTypes'),
}

model ListBaselineStatusesResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNumber'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: integer(name='TotalCount', description='totalCount'),
    baselineStatuses: [
      {
        baselineName: string(name='BaselineName', description='baselineName'),
        baselineId: long(name='BaselineId', description='baselineId'),
        bizdate: long(name='Bizdate', description='bizdate'),
        owner: string(name='Owner', description='owner'),
        expTime: long(name='ExpTime', description='expTime'),
        finishTime: long(name='FinishTime', description='finishTime'),
        endCast: long(name='EndCast', description='endCast'),
        slaTime: long(name='SlaTime', description='slaTime'),
        priority: integer(name='Priority', description='priority'),
        projectId: long(name='ProjectId', description='projectId'),
        buffer: long(name='Buffer', description='buffer'),
        status: string(name='Status', description='status'),
        finishStatus: string(name='FinishStatus', description='finishStatus'),
        inGroupId: integer(name='InGroupId', description='InGroupId'),
      }
    ](name='BaselineStatuses', description='data'),
  }(name='Data', description='data'),
}

async function listBaselineStatusesWithOptions(request: ListBaselineStatusesRequest, runtime: Util.RuntimeOptions): ListBaselineStatusesResponse {
  Util.validateModel(request);
  return doRequest('ListBaselineStatuses', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listBaselineStatuses(request: ListBaselineStatusesRequest): ListBaselineStatusesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBaselineStatusesWithOptions(request, runtime);
}

model ListRemindsRequest = {
  pageNumber: integer(name='PageNumber', description='pageNumber'),
  pageSize: integer(name='PageSize', description='pageSize'),
  founder?: string(name='Founder', description='founder'),
  nodeId?: long(name='NodeId', description='nodeId'),
  remindTypes?: string(name='RemindTypes', description='remindTypes'),
  alertTarget?: string(name='AlertTarget', description='alertTarget'),
  searchText?: string(name='SearchText', description='searchText'),
}

model ListRemindsResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: {
    pageNumber: integer(name='PageNumber', description='pageNumber'),
    pageSize: integer(name='PageSize', description='pageSize'),
    totalCount: integer(name='TotalCount', description='totalCount'),
    reminds: [
      {
        remindId: long(name='RemindId', description='remindId'),
        remindName: string(name='RemindName', description='remindName'),
        dndStart: string(name='DndStart', description='dndStart'),
        dndEnd: string(name='DndEnd', description='dndEnd'),
        remindUnit: string(name='RemindUnit', description='remindUnit'),
        remindType: string(name='RemindType', description='remindType'),
        alertUnit: string(name='AlertUnit', description='alertUnit'),
        useflag: boolean(name='Useflag', description='useflag'),
        founder: string(name='Founder', description='founder'),
        nodeIds: [ long ](name='NodeIds', description='nodeIds'),
        baselineIds: [ long ](name='BaselineIds', description='baselineIds'),
        projectIds: [ long ](name='ProjectIds', description='projectIds'),
        bizProcessIds: [ long ](name='BizProcessIds', description='bizProcessIds'),
        alertMethods: [ string ](name='AlertMethods', description='alertMethods'),
        alertTargets: [ string ](name='AlertTargets', description='alertTargets'),
      }
    ](name='Reminds', description='data'),
  }(name='Data', description='data'),
}

async function listRemindsWithOptions(request: ListRemindsRequest, runtime: Util.RuntimeOptions): ListRemindsResponse {
  Util.validateModel(request);
  return doRequest('ListReminds', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listReminds(request: ListRemindsRequest): ListRemindsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRemindsWithOptions(request, runtime);
}

model DeleteQualityEntityRequest = {
  entityId: long(name='EntityId', description='entityId'),
  projectName: string(name='ProjectName', description='projectName'),
  envType: string(name='EnvType', description='envType'),
}

model DeleteQualityEntityResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  data: boolean(name='Data', description='data'),
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteQualityEntityWithOptions(request: DeleteQualityEntityRequest, runtime: Util.RuntimeOptions): DeleteQualityEntityResponse {
  Util.validateModel(request);
  return doRequest('DeleteQualityEntity', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteQualityEntity(request: DeleteQualityEntityRequest): DeleteQualityEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQualityEntityWithOptions(request, runtime);
}

model CreateQualityFollowerRequest = {
  projectName: string(name='ProjectName', description='projectName'),
  follower: string(name='Follower', description='follower'),
  alarmMode: integer(name='AlarmMode', description='alarmMode'),
  entityId: long(name='EntityId', description='entityId'),
}

model CreateQualityFollowerResponse = {
  errorCode: string(name='ErrorCode', description='returnCode'),
  data: integer(name='Data', description='data'),
  success: boolean(name='Success', description='success'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
}

async function createQualityFollowerWithOptions(request: CreateQualityFollowerRequest, runtime: Util.RuntimeOptions): CreateQualityFollowerResponse {
  Util.validateModel(request);
  return doRequest('CreateQualityFollower', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createQualityFollower(request: CreateQualityFollowerRequest): CreateQualityFollowerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQualityFollowerWithOptions(request, runtime);
}

model CreateDataServiceApiRequest = {
  tenantId: long(name='TenantId', description='tenantId'),
  projectId: long(name='ProjectId', description='projectId'),
  apiName: string(name='ApiName', description='apiName'),
  groupId: string(name='GroupId', description='groupId'),
  apiMode: integer(name='ApiMode', description='apiMode'),
  requestMethod: integer(name='RequestMethod', description='apiHttpMethod'),
  responseContentType: integer(name='ResponseContentType', description='apiResultType'),
  timeout: integer(name='Timeout', description='apiTimeout'),
  visibleRange: integer(name='VisibleRange', description='securityLevel'),
  protocols: string(name='Protocols', description='apiProtocolsStr'),
  wizardDetails?: string(name='WizardDetails', description='wizardDetailsStr'),
  scriptDetails?: string(name='ScriptDetails', description='scriptDetailsStr'),
  registrationDetails?: string(name='RegistrationDetails', description='registrationDetailsStr'),
  apiPath: string(name='ApiPath', description='apiPath'),
  apiDescription: string(name='ApiDescription', description='apiDesc'),
}

model CreateDataServiceApiResponse = {
  data: long(name='Data', description='data'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
}

async function createDataServiceApiWithOptions(request: CreateDataServiceApiRequest, runtime: Util.RuntimeOptions): CreateDataServiceApiResponse {
  Util.validateModel(request);
  return doRequest('CreateDataServiceApi', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createDataServiceApi(request: CreateDataServiceApiRequest): CreateDataServiceApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataServiceApiWithOptions(request, runtime);
}

model AbolishDataServiceApiRequest = {
  tenantId: long(name='TenantId', description='tenantId'),
  projectId: long(name='ProjectId', description='projectId'),
  apiId: long(name='ApiId', description='apiId'),
}

model AbolishDataServiceApiResponse = {
  data: boolean(name='Data', description='data'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
}

async function abolishDataServiceApiWithOptions(request: AbolishDataServiceApiRequest, runtime: Util.RuntimeOptions): AbolishDataServiceApiResponse {
  Util.validateModel(request);
  return doRequest('AbolishDataServiceApi', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function abolishDataServiceApi(request: AbolishDataServiceApiRequest): AbolishDataServiceApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return abolishDataServiceApiWithOptions(request, runtime);
}

model GetQualityEntityRequest = {
  projectName: string(name='ProjectName', description='projectName'),
  tableName: string(name='TableName', description='tableName'),
  envType: string(name='EnvType', description='envType'),
  matchExpression?: string(name='MatchExpression', description='matchExpression'),
}

model GetQualityEntityResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: [
    {
      id: long(name='Id', description='id'),
      projectName: string(name='ProjectName', description='projectName'),
      tableName: string(name='TableName', description='tableName'),
      envType: string(name='EnvType', description='envType'),
      matchExpression: string(name='MatchExpression', description='matchExpression'),
      entityLevel: integer(name='EntityLevel', description='entityLevel'),
      onDuty: string(name='OnDuty', description='onDuty'),
      modifyUser: string(name='ModifyUser', description='modifyUser'),
      createTime: long(name='CreateTime', description='createTime'),
      modifyTime: long(name='ModifyTime', description='modifyTime'),
      sql: integer(name='Sql', description='sql'),
      task: integer(name='Task', description='task'),
      followers: string(name='Followers', description='followers'),
      hasRelativeNode: boolean(name='HasRelativeNode', description='hasRelativeNode'),
      relativeNode: string(name='RelativeNode', description='relativeNode'),
    }
  ](name='Data', description='data'),
}

async function getQualityEntityWithOptions(request: GetQualityEntityRequest, runtime: Util.RuntimeOptions): GetQualityEntityResponse {
  Util.validateModel(request);
  return doRequest('GetQualityEntity', 'HTTP', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getQualityEntity(request: GetQualityEntityRequest): GetQualityEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQualityEntityWithOptions(request, runtime);
}

model GetQualityFollowerRequest = {
  projectName: string(name='ProjectName', description='projectName'),
  entityId: long(name='EntityId', description='entityId'),
}

model GetQualityFollowerResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  success: boolean(name='Success', description='success'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
  data: [
    {
      projectName: string(name='ProjectName', description='projectName'),
      tableName: string(name='TableName', description='tableName'),
      id: long(name='Id', description='id'),
      entityId: string(name='EntityId', description='entityId'),
      follower: string(name='Follower', description='follower'),
      alarmMode: integer(name='AlarmMode', description='alarmMode'),
    }
  ](name='Data', description='data'),
}

async function getQualityFollowerWithOptions(request: GetQualityFollowerRequest, runtime: Util.RuntimeOptions): GetQualityFollowerResponse {
  Util.validateModel(request);
  return doRequest('GetQualityFollower', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getQualityFollower(request: GetQualityFollowerRequest): GetQualityFollowerResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQualityFollowerWithOptions(request, runtime);
}

model DeleteQualityFollowerRequest = {
  projectName: string(name='ProjectName', description='projectName'),
  followerId: long(name='FollowerId', description='followerId'),
}

model DeleteQualityFollowerResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  data: boolean(name='Data', description='data'),
  success: boolean(name='Success', description='success'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteQualityFollowerWithOptions(request: DeleteQualityFollowerRequest, runtime: Util.RuntimeOptions): DeleteQualityFollowerResponse {
  Util.validateModel(request);
  return doRequest('DeleteQualityFollower', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteQualityFollower(request: DeleteQualityFollowerRequest): DeleteQualityFollowerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQualityFollowerWithOptions(request, runtime);
}

model CreateQualityEntityRequest = {
  projectName: string(name='ProjectName', description='projectName'),
  tableName: string(name='TableName', description='tableName'),
  envType: string(name='EnvType', description='envType'),
  matchExpression: string(name='MatchExpression', description='matchExpression'),
  entityLevel: integer(name='EntityLevel', description='entityLevel'),
}

model CreateQualityEntityResponse = {
  success: boolean(name='Success', description='success'),
  data: integer(name='Data', description='data'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
}

async function createQualityEntityWithOptions(request: CreateQualityEntityRequest, runtime: Util.RuntimeOptions): CreateQualityEntityResponse {
  Util.validateModel(request);
  return doRequest('CreateQualityEntity', 'HTTP', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createQualityEntity(request: CreateQualityEntityRequest): CreateQualityEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQualityEntityWithOptions(request, runtime);
}

model CreateQualityRuleRequest = {
  blockType: integer(name='BlockType', description='blockType'),
  entityId: long(name='EntityId', description='entityId'),
  comment?: string(name='Comment', description='comment'),
  checker?: integer(name='Checker', description='checker'),
  expectValue?: string(name='ExpectValue', description='expectValue'),
  trend?: string(name='Trend', description='trend'),
  methodName?: string(name='MethodName', description='methodName'),
  operator?: string(name='Operator', description='operator'),
  projectName: string(name='ProjectName', description='projectName'),
  property?: string(name='Property', description='property'),
  propertyType?: string(name='PropertyType', description='propertyType'),
  ruleType: integer(name='RuleType', description='ruleType'),
  whereCondition?: string(name='WhereCondition', description='whereCondition'),
  criticalThreshold?: string(name='CriticalThreshold', description='criticalThreshold'),
  warningThreshold?: string(name='WarningThreshold', description='warningThreshold'),
  templateId?: integer(name='TemplateId', description='templateId'),
  ruleName: string(name='RuleName', description='ruleName'),
  predictType: integer(name='PredictType', description='predictType'),
}

model CreateQualityRuleResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  data: string(name='Data', description='data'),
  success: boolean(name='Success', description='success'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
}

async function createQualityRuleWithOptions(request: CreateQualityRuleRequest, runtime: Util.RuntimeOptions): CreateQualityRuleResponse {
  Util.validateModel(request);
  return doRequest('CreateQualityRule', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createQualityRule(request: CreateQualityRuleRequest): CreateQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQualityRuleWithOptions(request, runtime);
}

model UpdateQualityFollowerRequest = {
  projectName: string(name='ProjectName', description='projectName'),
  followerId: long(name='FollowerId', description='followerId'),
  follower: string(name='Follower', description='follower'),
  alarmMode: integer(name='AlarmMode', description='alarmMode'),
}

model UpdateQualityFollowerResponse = {
  errorCode: string(name='ErrorCode', description='errorCode'),
  data: boolean(name='Data', description='data'),
  success: boolean(name='Success', description='success'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  requestId: string(name='RequestId', description='requestId'),
}

async function updateQualityFollowerWithOptions(request: UpdateQualityFollowerRequest, runtime: Util.RuntimeOptions): UpdateQualityFollowerResponse {
  Util.validateModel(request);
  return doRequest('UpdateQualityFollower', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateQualityFollower(request: UpdateQualityFollowerRequest): UpdateQualityFollowerResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateQualityFollowerWithOptions(request, runtime);
}

model CreateQualityRelativeNodeRequest = {
  envType: string(name='EnvType', description='envType'),
  matchExpression: string(name='MatchExpression', description='matchExpression'),
  nodeId: long(name='NodeId', description='nodeId'),
  projectId: long(name='ProjectId', description='projectId'),
  targetNodeProjectName: string(name='TargetNodeProjectName', description='targetNodeProjectName'),
  projectName: string(name='ProjectName', description='projectName'),
  tableName: string(name='TableName', description='tableName'),
  targetNodeProjectId: long(name='TargetNodeProjectId', description='targetNodeProjectId'),
}

model CreateQualityRelativeNodeResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  data: boolean(name='Data', description='data'),
  requestId: string(name='RequestId', description='requestId'),
}

async function createQualityRelativeNodeWithOptions(request: CreateQualityRelativeNodeRequest, runtime: Util.RuntimeOptions): CreateQualityRelativeNodeResponse {
  Util.validateModel(request);
  return doRequest('CreateQualityRelativeNode', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createQualityRelativeNode(request: CreateQualityRelativeNodeRequest): CreateQualityRelativeNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQualityRelativeNodeWithOptions(request, runtime);
}

model DeleteQualityRelativeNodeRequest = {
  envType: string(name='EnvType', description='envType'),
  matchExpression: string(name='MatchExpression', description='matchExpression'),
  nodeId: long(name='NodeId', description='nodeId'),
  projectId: long(name='ProjectId', description='projectId'),
  targetNodeProjectName: string(name='TargetNodeProjectName', description='targetNodeProjectName'),
  projectName: string(name='ProjectName', description='projectName'),
  tableName: string(name='TableName', description='tableName'),
  targetNodeProjectId: long(name='TargetNodeProjectId', description='targetNodeProjectId'),
}

model DeleteQualityRelativeNodeResponse = {
  success: boolean(name='Success', description='success'),
  errorCode: string(name='ErrorCode', description='errorCode'),
  errorMessage: string(name='ErrorMessage', description='errorMessage'),
  httpStatusCode: integer(name='HttpStatusCode', description='httpStatusCode'),
  data: boolean(name='Data', description='data'),
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteQualityRelativeNodeWithOptions(request: DeleteQualityRelativeNodeRequest, runtime: Util.RuntimeOptions): DeleteQualityRelativeNodeResponse {
  Util.validateModel(request);
  return doRequest('DeleteQualityRelativeNode', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteQualityRelativeNode(request: DeleteQualityRelativeNodeRequest): DeleteQualityRelativeNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQualityRelativeNodeWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
