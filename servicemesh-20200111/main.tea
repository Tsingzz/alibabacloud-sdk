import Util;
import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('servicemesh', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model RemoveClusterFromServiceMeshRequest = {
  serviceMeshId: string(name='ServiceMeshId', description='ServiceMeshId'),
  clusterId: string(name='ClusterId', description='cluster_id'),
}

model RemoveClusterFromServiceMeshResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  code: string(name='Code', description='code'),
  success: string(name='Success', description='success'),
  message: [ string ] (name='Message', description='message'),
}

async function removeClusterFromServiceMeshWithOptions(request: RemoveClusterFromServiceMeshRequest, runtime: Util.RuntimeOptions): RemoveClusterFromServiceMeshResponse {
  Util.validateModel(request);
  return doRequest('RemoveClusterFromServiceMesh', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function removeClusterFromServiceMesh(request: RemoveClusterFromServiceMeshRequest): RemoveClusterFromServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeClusterFromServiceMeshWithOptions(request, runtime);
}

model AddClusterIntoServiceMeshRequest = {
  serviceMeshId: string(name='ServiceMeshId', description='ServiceMeshId'),
  clusterId: string(name='ClusterId', description='cluster_id'),
}

model AddClusterIntoServiceMeshResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  code: string(name='Code', description='code'),
  success: string(name='Success', description='success'),
  message: [ string ] (name='Message', description='message'),
}

async function addClusterIntoServiceMeshWithOptions(request: AddClusterIntoServiceMeshRequest, runtime: Util.RuntimeOptions): AddClusterIntoServiceMeshResponse {
  Util.validateModel(request);
  return doRequest('AddClusterIntoServiceMesh', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function addClusterIntoServiceMesh(request: AddClusterIntoServiceMeshRequest): AddClusterIntoServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return addClusterIntoServiceMeshWithOptions(request, runtime);
}

model UpdateIstioInjectionConfigRequest = {
  serviceMeshId: string(name='ServiceMeshId', description='ServiceMeshId'),
  namespace: string(name='Namespace', description='namespace'),
  enableIstioInjection: boolean(name='EnableIstioInjection', description='enableIstioInjection'),
}

model UpdateIstioInjectionConfigResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function updateIstioInjectionConfigWithOptions(request: UpdateIstioInjectionConfigRequest, runtime: Util.RuntimeOptions): UpdateIstioInjectionConfigResponse {
  Util.validateModel(request);
  return doRequest('UpdateIstioInjectionConfig', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function updateIstioInjectionConfig(request: UpdateIstioInjectionConfigRequest): UpdateIstioInjectionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIstioInjectionConfigWithOptions(request, runtime);
}

model DescribeGuestClusterAccessLogDashboardsRequest = {
  k8sClusterId: string(name='K8sClusterId', description='k8sClusterId'),
}

model DescribeGuestClusterAccessLogDashboardsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  k8sClusterId: string(name='K8sClusterId', description='k8sClusterId'),
  dashboards: [
    {
      title: string(name='Title', description='title'),
      url: string(name='Url', description='url'),
    }
  ](name='Dashboards', description='dashboards'),
}

async function describeGuestClusterAccessLogDashboardsWithOptions(request: DescribeGuestClusterAccessLogDashboardsRequest, runtime: Util.RuntimeOptions): DescribeGuestClusterAccessLogDashboardsResponse {
  Util.validateModel(request);
  return doRequest('DescribeGuestClusterAccessLogDashboards', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function describeGuestClusterAccessLogDashboards(request: DescribeGuestClusterAccessLogDashboardsRequest): DescribeGuestClusterAccessLogDashboardsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGuestClusterAccessLogDashboardsWithOptions(request, runtime);
}

model DescribeReusableSlbRequest = {
  k8sClusterId: string(name='K8sClusterId', description='k8sClusterId'),
  networkType: string(name='NetworkType', description='networkType'),
}

model DescribeReusableSlbResponse = {
  requestId: string(name='RequestId', description='requestId'),
  reusableSlbList: [
    {
      loadBalancerId: string(name='LoadBalancerId', description='id'),
      loadBalancerName: string(name='LoadBalancerName', description='name'),
    }
  ](name='ReusableSlbList', description='reusableSlbList'),
}

async function describeReusableSlbWithOptions(request: DescribeReusableSlbRequest, runtime: Util.RuntimeOptions): DescribeReusableSlbResponse {
  Util.validateModel(request);
  return doRequest('DescribeReusableSlb', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function describeReusableSlb(request: DescribeReusableSlbRequest): DescribeReusableSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeReusableSlbWithOptions(request, runtime);
}

model DescribeClusterPrometheusRequest = {
  serviceMeshId?: string(name='ServiceMeshId', description='ServiceMeshId'),
  k8sClusterId?: string(name='K8sClusterId', description='k8sClusterId'),
  k8sClusterRegionId?: string(name='K8sClusterRegionId', description='k8sClusterRegionId'),
}

model DescribeClusterPrometheusResponse = {
  requestId: string(name='RequestId', description='requestId'),
  prometheus: string(name='Prometheus', description='prometheus'),
}

async function describeClusterPrometheusWithOptions(request: DescribeClusterPrometheusRequest, runtime: Util.RuntimeOptions): DescribeClusterPrometheusResponse {
  Util.validateModel(request);
  return doRequest('DescribeClusterPrometheus', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function describeClusterPrometheus(request: DescribeClusterPrometheusRequest): DescribeClusterPrometheusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterPrometheusWithOptions(request, runtime);
}

model DescribeClusterGrafanaRequest = {
  serviceMeshId?: string(name='ServiceMeshId', description='ServiceMeshId'),
  k8sClusterId?: string(name='K8sClusterId', description='k8sClusterId'),
}

model DescribeClusterGrafanaResponse = {
  requestId: string(name='RequestId', description='requestId'),
  dashboards: [
    {
      url: string(name='Url', description='url'),
      title: string(name='Title', description='title'),
    }
  ](name='Dashboards', description='dashboards'),
}

async function describeClusterGrafanaWithOptions(request: DescribeClusterGrafanaRequest, runtime: Util.RuntimeOptions): DescribeClusterGrafanaResponse {
  Util.validateModel(request);
  return doRequest('DescribeClusterGrafana', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function describeClusterGrafana(request: DescribeClusterGrafanaRequest): DescribeClusterGrafanaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterGrafanaWithOptions(request, runtime);
}

model DescribeRelatedResourcesReuseRequest = {
  serviceMeshId: string(name='ServiceMeshId', description='ServiceMeshId'),
}

model DescribeRelatedResourcesReuseResponse = {
  requestId: string(name='RequestId', description='requestId'),
  reuseInfo: [ map[string]any ] (name='ReuseInfo', description='reuseInfo'),
}

async function describeRelatedResourcesReuseWithOptions(request: DescribeRelatedResourcesReuseRequest, runtime: Util.RuntimeOptions): DescribeRelatedResourcesReuseResponse {
  Util.validateModel(request);
  return doRequest('DescribeRelatedResourcesReuse', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function describeRelatedResourcesReuse(request: DescribeRelatedResourcesReuseRequest): DescribeRelatedResourcesReuseResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRelatedResourcesReuseWithOptions(request, runtime);
}

model DescribeRegionsRequest = {
  acceptLanguage?: string(name='AcceptLanguage', description='acceptLanguage'),
}

model DescribeRegionsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  businessLocations: string(name='BusinessLocations', description='BusinessLocations'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  return doRequest('DescribeRegions', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeCensRequest = {
  serviceMeshId?: string(name='ServiceMeshId', description='ServiceMeshId'),
}

model DescribeCensResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  clusters: string(name='Clusters', description='clusters'),
}

async function describeCensWithOptions(request: DescribeCensRequest, runtime: Util.RuntimeOptions): DescribeCensResponse {
  Util.validateModel(request);
  return doRequest('DescribeCens', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function describeCens(request: DescribeCensRequest): DescribeCensResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCensWithOptions(request, runtime);
}

model DescribeClustersInServiceMeshRequest = {
  serviceMeshId?: string(name='ServiceMeshId', description='ServiceMeshId'),
}

model DescribeClustersInServiceMeshResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  clusters: [
    {
      clusterId: string(name='ClusterId', description='cluster_id'),
      clusterType: string(name='ClusterType', description='cluster_type'),
      creationTime: string(name='CreationTime', description='created'),
      errorMessage: string(name='ErrorMessage', description='errMsg'),
      name: string(name='Name', description='name'),
      regionId: string(name='RegionId', description='region_id'),
      state: string(name='State', description='state'),
      updateTime: string(name='UpdateTime', description='updated'),
      version: string(name='Version', description='current_version'),
      vpcId: string(name='VpcId', description='vpc_id'),
      sgId: string(name='SgId', description='security_group_id'),
      clusterDomain: string(name='ClusterDomain', description='cluster_domain'),
    }
  ](name='Clusters', description='clusters'),
}

async function describeClustersInServiceMeshWithOptions(request: DescribeClustersInServiceMeshRequest, runtime: Util.RuntimeOptions): DescribeClustersInServiceMeshResponse {
  Util.validateModel(request);
  return doRequest('DescribeClustersInServiceMesh', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function describeClustersInServiceMesh(request: DescribeClustersInServiceMeshRequest): DescribeClustersInServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClustersInServiceMeshWithOptions(request, runtime);
}

model DescribeIngressGatewaysRequest = {
  serviceMeshId?: string(name='ServiceMeshId', description='ServiceMeshId'),
}

model DescribeIngressGatewaysResponse = {
  requestId: string(name='RequestId', description='requestId'),
  ingressGateways: [ map[string]any ] (name='IngressGateways', description='ingressgateways'),
}

async function describeIngressGatewaysWithOptions(request: DescribeIngressGatewaysRequest, runtime: Util.RuntimeOptions): DescribeIngressGatewaysResponse {
  Util.validateModel(request);
  return doRequest('DescribeIngressGateways', 'HTTPS', 'GET', '2020-01-11', 'AK', null, request, runtime);
}

async function describeIngressGateways(request: DescribeIngressGatewaysRequest): DescribeIngressGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIngressGatewaysWithOptions(request, runtime);
}

model DescribeUpgradeVersionRequest = {
  serviceMeshId?: string(name='ServiceMeshId', description='ServiceMeshId'),
}

model DescribeUpgradeVersionResponse = {
  requestId: string(name='RequestId', description='requestId'),
  version: {
    istioVersion: string(name='IstioVersion', description='istio_version'),
    istioOperatorVersion: string(name='IstioOperatorVersion', description='istio_operator_version'),
    kubernetesVersion: string(name='KubernetesVersion', description='kubernetes_version'),
  }(name='Version', description='data'),
}

async function describeUpgradeVersionWithOptions(request: DescribeUpgradeVersionRequest, runtime: Util.RuntimeOptions): DescribeUpgradeVersionResponse {
  Util.validateModel(request);
  return doRequest('DescribeUpgradeVersion', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function describeUpgradeVersion(request: DescribeUpgradeVersionRequest): DescribeUpgradeVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUpgradeVersionWithOptions(request, runtime);
}

model UpdateMeshFeatureRequest = {
  serviceMeshId: string(name='ServiceMeshId', description='ServiceMeshId'),
  tracing?: boolean(name='Tracing', description='tracing'),
  traceSampling?: float(name='TraceSampling', description='traceSampling'),
  localityLoadBalancing?: boolean(name='LocalityLoadBalancing', description='enableLocalityLB'),
  telemetry?: boolean(name='Telemetry', description='telemetryV2'),
  openAgentPolicy?: boolean(name='OpenAgentPolicy', description='opaEnabled'),
  OPALogLevel?: string(name='OPALogLevel', description='opaLogLevel'),
  OPARequestCPU?: string(name='OPARequestCPU', description='opaRequestCPU'),
  OPARequestMemory?: string(name='OPARequestMemory', description='opaRequestMemory'),
  OPALimitCPU?: string(name='OPALimitCPU', description='opaLimitCPU'),
  OPALimitMemory?: string(name='OPALimitMemory', description='opaLimitMemory'),
  enableAudit?: boolean(name='EnableAudit', description='enableAudit'),
  auditProject?: string(name='AuditProject', description='auditProject'),
  clusterDomain?: string(name='ClusterDomain', description='clusterDomain'),
}

model UpdateMeshFeatureResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function updateMeshFeatureWithOptions(request: UpdateMeshFeatureRequest, runtime: Util.RuntimeOptions): UpdateMeshFeatureResponse {
  Util.validateModel(request);
  return doRequest('UpdateMeshFeature', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function updateMeshFeature(request: UpdateMeshFeatureRequest): UpdateMeshFeatureResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMeshFeatureWithOptions(request, runtime);
}

model UpgradeMeshVersionRequest = {
  serviceMeshId?: string(name='ServiceMeshId', description='ServiceMeshId'),
}

model UpgradeMeshVersionResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function upgradeMeshVersionWithOptions(request: UpgradeMeshVersionRequest, runtime: Util.RuntimeOptions): UpgradeMeshVersionResponse {
  Util.validateModel(request);
  return doRequest('UpgradeMeshVersion', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function upgradeMeshVersion(request: UpgradeMeshVersionRequest): UpgradeMeshVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeMeshVersionWithOptions(request, runtime);
}

model DescribeServiceMeshesRequest = {
}

model DescribeServiceMeshesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  serviceMeshes: [
    {
      endpoints: {
        intranetApiServerEndpoint: string(name='IntranetApiServerEndpoint', description='intranet_api_server_endpoint'),
        intranetPilotEndpoint: string(name='IntranetPilotEndpoint', description='intranet_pilot_endpoint'),
        publicApiServerEndpoint: string(name='PublicApiServerEndpoint', description='public_api_server_endpoint'),
        publicPilotEndpoint: string(name='PublicPilotEndpoint', description='public_pilot_endpoint'),
        reverseTunnelEndpoint: string(name='ReverseTunnelEndpoint', description='reverse_tunnel_endpoint'),
      }(name='Endpoints', description='endpoints'),
      serviceMeshInfo: {
        creationTime: string(name='CreationTime', description='created'),
        errorMessage: string(name='ErrorMessage', description='errMsg'),
        name: string(name='Name', description='name'),
        regionId: string(name='RegionId', description='region_id'),
        serviceMeshId: string(name='ServiceMeshId', description='cluster_id'),
        state: string(name='State', description='state'),
        updateTime: string(name='UpdateTime', description='updated'),
        version: string(name='Version', description='current_version'),
      }(name='ServiceMeshInfo', description='cluster_info'),
      spec: {
        loadBalancer: {
          apiServerLoadbalancerId: string(name='ApiServerLoadbalancerId', description='api_server_load_balancer_id'),
          apiServerPublicEip: string(name='ApiServerPublicEip', description='api_server_public_eip'),
          pilotPublicEip: string(name='PilotPublicEip', description='pilot_public_eip'),
          pilotPublicLoadbalancerId: string(name='PilotPublicLoadbalancerId', description='pilot_load_balancer_id'),
        }(name='LoadBalancer', description='load_balancer'),
        meshConfig: {
          mtls: boolean(name='Mtls', description='mtls'),
          outboundTrafficPolicy: string(name='OutboundTrafficPolicy', description='outbound_traffic_policy'),
          strictMtls: boolean(name='StrictMtls', description='mtls_strict'),
          tracing: boolean(name='Tracing', description='tracing'),
          telemetry: boolean(name='Telemetry', description='telemetry_v2'),
        }(name='MeshConfig', description='mesh_config'),
        network: {
          securityGroupId: string(name='SecurityGroupId', description='security_group_id'),
          vpcId: string(name='VpcId', description='vpc_id'),
          VSwitches: [ string ](name='VSwitches', description='vswitch_ids'),
        }(name='Network', description='network'),
      }(name='Spec', description='spec'),
      clusters: [ string ](name='Clusters', description='guest_clusters'),
    }
  ](name='ServiceMeshes', description='service_meshes'),
}

async function describeServiceMeshesWithOptions(request: DescribeServiceMeshesRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshesResponse {
  Util.validateModel(request);
  return doRequest('DescribeServiceMeshes', 'HTTPS', 'GET', '2020-01-11', 'AK', null, request, runtime);
}

async function describeServiceMeshes(request: DescribeServiceMeshesRequest): DescribeServiceMeshesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshesWithOptions(request, runtime);
}

model DescribeServiceMeshDetailRequest = {
  serviceMeshId: string(name='ServiceMeshId', description='ServiceMeshId'),
}

model DescribeServiceMeshDetailResponse = {
  requestId: string(name='RequestId', description='requestId'),
  serviceMesh: {
    endpoints: {
      intranetApiServerEndpoint: string(name='IntranetApiServerEndpoint', description='intranet_api_server_endpoint'),
      intranetPilotEndpoint: string(name='IntranetPilotEndpoint', description='intranet_pilot_endpoint'),
      publicApiServerEndpoint: string(name='PublicApiServerEndpoint', description='public_api_server_endpoint'),
      publicPilotEndpoint: string(name='PublicPilotEndpoint', description='public_pilot_endpoint'),
    }(name='Endpoints', description='endpoints'),
    serviceMeshInfo: {
      creationTime: string(name='CreationTime', description='created'),
      errorMessage: string(name='ErrorMessage', description='errMsg'),
      name: string(name='Name', description='name'),
      regionId: string(name='RegionId', description='region_id'),
      serviceMeshId: string(name='ServiceMeshId', description='cluster_id'),
      state: string(name='State', description='state'),
      updateTime: string(name='UpdateTime', description='updated'),
      version: string(name='Version', description='current_version'),
    }(name='ServiceMeshInfo', description='cluster_info'),
    spec: {
      loadBalancer: {
        apiServerLoadbalancerId: string(name='ApiServerLoadbalancerId', description='api_server_load_balancer_id'),
        apiServerPublicEip: string(name='ApiServerPublicEip', description='api_server_public_eip'),
        pilotPublicEip: string(name='PilotPublicEip', description='pilot_public_eip'),
        pilotPublicLoadbalancerId: string(name='PilotPublicLoadbalancerId', description='pilot_load_balancer_id'),
      }(name='LoadBalancer', description='load_balancer'),
      meshConfig: {
        enableLocalityLB: boolean(name='EnableLocalityLB', description='enable_localitylb'),
        telemetry: boolean(name='Telemetry', description='telemetry_v2'),
        tracing: boolean(name='Tracing', description='tracing'),
        pilot: {
          traceSampling: float(name='TraceSampling', description='traceSampling'),
        }(name='Pilot', description='pilot'),
        OPA: {
          enabled: boolean(name='Enabled', description='enabled'),
          logLevel: string(name='LogLevel', description='logLevel'),
          requestCPU: string(name='RequestCPU', description='requestCPU'),
          requestMemory: string(name='RequestMemory', description='requestMemory'),
          limitCPU: string(name='LimitCPU', description='limitCPU'),
          limitMemory: string(name='LimitMemory', description='limitMemory'),
        }(name='OPA', description='opa'),
        audit: {
          enabled: boolean(name='Enabled', description='enabled'),
          project: string(name='Project', description='project'),
        }(name='Audit', description='audit'),
      }(name='MeshConfig', description='mesh_config'),
      network: {
        securityGroupId: string(name='SecurityGroupId', description='security_group_id'),
        vpcId: string(name='VpcId', description='vpc_id'),
        VSwitches: [ string ](name='VSwitches', description='vswitch_ids'),
      }(name='Network', description='network'),
    }(name='Spec', description='spec'),
    clusters: [ string ](name='Clusters', description='guest_clusters'),
  }(name='ServiceMesh', description='data'),
}

async function describeServiceMeshDetailWithOptions(request: DescribeServiceMeshDetailRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshDetailResponse {
  Util.validateModel(request);
  return doRequest('DescribeServiceMeshDetail', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function describeServiceMeshDetail(request: DescribeServiceMeshDetailRequest): DescribeServiceMeshDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshDetailWithOptions(request, runtime);
}

model DescribeServiceMeshKubeconfigRequest = {
  serviceMeshId: string(name='ServiceMeshId', description='ServiceMeshId'),
  privateIpAddress?: boolean(name='PrivateIpAddress', description='PrivateIpAddress'),
}

model DescribeServiceMeshKubeconfigResponse = {
  kubeconfig: string(name='Kubeconfig', description='config'),
  requestId: string(name='RequestId', description='requestId'),
}

async function describeServiceMeshKubeconfigWithOptions(request: DescribeServiceMeshKubeconfigRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshKubeconfigResponse {
  Util.validateModel(request);
  return doRequest('DescribeServiceMeshKubeconfig', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function describeServiceMeshKubeconfig(request: DescribeServiceMeshKubeconfigRequest): DescribeServiceMeshKubeconfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshKubeconfigWithOptions(request, runtime);
}

model CreateServiceMeshRequest = {
  regionId: string(name='RegionId', description='region_id'),
  istioVersion?: string(name='IstioVersion', description='current_version'),
  vpcId: string(name='VpcId', description='vpc_id'),
  apiServerPublicEip?: boolean(name='ApiServerPublicEip', description='api_server_public_eip'),
  pilotPublicEip?: boolean(name='PilotPublicEip', description='pilot_public_eip'),
  tracing?: boolean(name='Tracing', description='tracing'),
  name?: string(name='Name', description='name'),
  VSwitches?: string(name='VSwitches', description='vswitch_ids'),
  traceSampling?: float(name='TraceSampling', description='traceSampling'),
  localityLoadBalancing?: boolean(name='LocalityLoadBalancing', description='enableLocalityLB'),
  telemetry?: boolean(name='Telemetry', description='telemetryV2'),
  openAgentPolicy?: boolean(name='OpenAgentPolicy', description='opaEnabled'),
  OPALogLevel?: string(name='OPALogLevel', description='opaLogLevel'),
  OPARequestCPU?: string(name='OPARequestCPU', description='opaRequestCPU'),
  OPARequestMemory?: string(name='OPARequestMemory', description='opaRequestMemory'),
  OPALimitCPU?: string(name='OPALimitCPU', description='opaLimitCPU'),
  OPALimitMemory?: string(name='OPALimitMemory', description='opaLimitMemory'),
  enableAudit?: boolean(name='EnableAudit', description='enableAudit'),
  auditProject?: string(name='AuditProject', description='AuditProject'),
}

model CreateServiceMeshResponse = {
  requestId: string(name='RequestId', description='requestId'),
  serviceMeshId: string(name='ServiceMeshId', description='servicemesh_id'),
}

async function createServiceMeshWithOptions(request: CreateServiceMeshRequest, runtime: Util.RuntimeOptions): CreateServiceMeshResponse {
  Util.validateModel(request);
  return doRequest('CreateServiceMesh', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function createServiceMesh(request: CreateServiceMeshRequest): CreateServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceMeshWithOptions(request, runtime);
}

model DeleteServiceMeshRequest = {
  serviceMeshId: string(name='ServiceMeshId', description='ServiceMeshId'),
  force?: boolean(name='Force', description='force'),
}

model DeleteServiceMeshResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteServiceMeshWithOptions(request: DeleteServiceMeshRequest, runtime: Util.RuntimeOptions): DeleteServiceMeshResponse {
  Util.validateModel(request);
  return doRequest('DeleteServiceMesh', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function deleteServiceMesh(request: DeleteServiceMeshRequest): DeleteServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServiceMeshWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
