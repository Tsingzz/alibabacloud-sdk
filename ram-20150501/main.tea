import Util;
import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('ram', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model GetAccessKeyLastUsedRequest = {
  userName?: string(name='UserName', description='UserName'),
  userAccessKeyId?: string(name='UserAccessKeyId', description='UserAccessKeyId'),
}

model GetAccessKeyLastUsedResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  accessKeyLastUsed: {
    lastUsedDate: string(name='LastUsedDate', description='LastUsedDate'),
  }(name='AccessKeyLastUsed', description='AccessKeyLastUsed'),
}

async function getAccessKeyLastUsedWithOptions(request: GetAccessKeyLastUsedRequest, runtime: Util.RuntimeOptions): GetAccessKeyLastUsedResponse {
  Util.validateModel(request);
  return doRequest('GetAccessKeyLastUsed', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function getAccessKeyLastUsed(request: GetAccessKeyLastUsedRequest): GetAccessKeyLastUsedResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccessKeyLastUsedWithOptions(request, runtime);
}

model ChangePasswordRequest = {
  oldPassword?: string(name='OldPassword', description='OldPassword'),
  newPassword?: string(name='NewPassword', description='NewPassword'),
}

model ChangePasswordResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function changePasswordWithOptions(request: ChangePasswordRequest, runtime: Util.RuntimeOptions): ChangePasswordResponse {
  Util.validateModel(request);
  return doRequest('ChangePassword', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function changePassword(request: ChangePasswordRequest): ChangePasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return changePasswordWithOptions(request, runtime);
}

model UpdateRoleRequest = {
  roleName?: string(name='RoleName', description='RoleName'),
  newAssumeRolePolicyDocument?: string(name='NewAssumeRolePolicyDocument', description='NewAssumeRolePolicyDocument'),
  newMaxSessionDuration?: long(name='NewMaxSessionDuration', description='NewMaxSessionDuration'),
}

model UpdateRoleResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  role: {
    roleId: string(name='RoleId', description='RoleId'),
    roleName: string(name='RoleName', description='RoleName'),
    arn: string(name='Arn', description='Arn'),
    description: string(name='Description', description='Description'),
    assumeRolePolicyDocument: string(name='AssumeRolePolicyDocument', description='AssumeRolePolicyDocument'),
    createDate: string(name='CreateDate', description='CreateDate'),
    updateDate: string(name='UpdateDate', description='UpdateDate'),
    maxSessionDuration: long(name='MaxSessionDuration', description='MaxSessionDuration'),
  }(name='Role', description='Role'),
}

async function updateRoleWithOptions(request: UpdateRoleRequest, runtime: Util.RuntimeOptions): UpdateRoleResponse {
  Util.validateModel(request);
  return doRequest('UpdateRole', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function updateRole(request: UpdateRoleRequest): UpdateRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRoleWithOptions(request, runtime);
}

model SetSecurityPreferenceRequest = {
  enableSaveMFATicket?: boolean(name='EnableSaveMFATicket', description='EnableSaveMFATicket'),
  allowUserToChangePassword?: boolean(name='AllowUserToChangePassword', description='AllowUserToChangePassword'),
  allowUserToManageAccessKeys?: boolean(name='AllowUserToManageAccessKeys', description='AllowUserToManageAccessKeys'),
  allowUserToManagePublicKeys?: boolean(name='AllowUserToManagePublicKeys', description='AllowUserToManagePublicKeys'),
  allowUserToManageMFADevices?: boolean(name='AllowUserToManageMFADevices', description='AllowUserToManageMFADevices'),
  loginSessionDuration?: integer(name='LoginSessionDuration', description='LoginSessionDuration'),
  loginNetworkMasks?: string(name='LoginNetworkMasks', description='LoginNetworkMasks'),
}

model SetSecurityPreferenceResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  securityPreference: {
    loginProfilePreference: {
      enableSaveMFATicket: boolean(name='EnableSaveMFATicket', description='EnableSaveMFATicket'),
      allowUserToChangePassword: boolean(name='AllowUserToChangePassword', description='AllowUserToChangePassword'),
      loginSessionDuration: integer(name='LoginSessionDuration', description='LoginSessionDuration'),
      loginNetworkMasks: string(name='LoginNetworkMasks', description='LoginNetworkMasks'),
    }(name='LoginProfilePreference', description='LoginProfilePreference'),
    accessKeyPreference: {
      allowUserToManageAccessKeys: boolean(name='AllowUserToManageAccessKeys', description='AllowUserToManageAccessKeys'),
    }(name='AccessKeyPreference', description='AccessKeyPreference'),
    publicKeyPreference: {
      allowUserToManagePublicKeys: boolean(name='AllowUserToManagePublicKeys', description='AllowUserToManagePublicKeys'),
    }(name='PublicKeyPreference', description='PublicKeyPreference'),
    MFAPreference: {
      allowUserToManageMFADevices: boolean(name='AllowUserToManageMFADevices', description='AllowUserToManageMFADevices'),
    }(name='MFAPreference', description='MFAPreference'),
  }(name='SecurityPreference', description='SecurityPreference'),
}

async function setSecurityPreferenceWithOptions(request: SetSecurityPreferenceRequest, runtime: Util.RuntimeOptions): SetSecurityPreferenceResponse {
  Util.validateModel(request);
  return doRequest('SetSecurityPreference', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function setSecurityPreference(request: SetSecurityPreferenceRequest): SetSecurityPreferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return setSecurityPreferenceWithOptions(request, runtime);
}

model ListRolesRequest = {
  marker?: string(name='Marker', description='Marker'),
  maxItems?: integer(name='MaxItems', description='MaxItems'),
}

model ListRolesResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  isTruncated: boolean(name='IsTruncated', description='IsTruncated'),
  marker: string(name='Marker', description='Marker'),
  roles: {
    role: [
      {
        roleId: string(name='RoleId', description='RoleId'),
        roleName: string(name='RoleName', description='RoleName'),
        arn: string(name='Arn', description='Arn'),
        description: string(name='Description', description='Description'),
        createDate: string(name='CreateDate', description='CreateDate'),
        updateDate: string(name='UpdateDate', description='UpdateDate'),
        maxSessionDuration: long(name='MaxSessionDuration', description='MaxSessionDuration'),
      }
    ](name='Role', description='Role'),
  }(name='Roles', description='Roles'),
}

async function listRolesWithOptions(request: ListRolesRequest, runtime: Util.RuntimeOptions): ListRolesResponse {
  Util.validateModel(request);
  return doRequest('ListRoles', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function listRoles(request: ListRolesRequest): ListRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRolesWithOptions(request, runtime);
}

model ListPoliciesForRoleRequest = {
  roleName?: string(name='RoleName', description='RoleName'),
}

model ListPoliciesForRoleResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  policies: {
    policy: [
      {
        policyName: string(name='PolicyName', description='PolicyName'),
        policyType: string(name='PolicyType', description='PolicyType'),
        description: string(name='Description', description='Description'),
        defaultVersion: string(name='DefaultVersion', description='DefaultVersion'),
        attachDate: string(name='AttachDate', description='AttachDate'),
      }
    ](name='Policy', description='Policy'),
  }(name='Policies', description='Policies'),
}

async function listPoliciesForRoleWithOptions(request: ListPoliciesForRoleRequest, runtime: Util.RuntimeOptions): ListPoliciesForRoleResponse {
  Util.validateModel(request);
  return doRequest('ListPoliciesForRole', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function listPoliciesForRole(request: ListPoliciesForRoleRequest): ListPoliciesForRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPoliciesForRoleWithOptions(request, runtime);
}

model GetSecurityPreferenceRequest = {
}

model GetSecurityPreferenceResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  securityPreference: {
    loginProfilePreference: {
      enableSaveMFATicket: boolean(name='EnableSaveMFATicket', description='EnableSaveMFATicket'),
      allowUserToChangePassword: boolean(name='AllowUserToChangePassword', description='AllowUserToChangePassword'),
      loginSessionDuration: integer(name='LoginSessionDuration', description='LoginSessionDuration'),
      loginNetworkMasks: string(name='LoginNetworkMasks', description='LoginNetworkMasks'),
    }(name='LoginProfilePreference', description='LoginProfilePreference'),
    accessKeyPreference: {
      allowUserToManageAccessKeys: boolean(name='AllowUserToManageAccessKeys', description='AllowUserToManageAccessKeys'),
    }(name='AccessKeyPreference', description='AccessKeyPreference'),
    publicKeyPreference: {
      allowUserToManagePublicKeys: boolean(name='AllowUserToManagePublicKeys', description='AllowUserToManagePublicKeys'),
    }(name='PublicKeyPreference', description='PublicKeyPreference'),
    MFAPreference: {
      allowUserToManageMFADevices: boolean(name='AllowUserToManageMFADevices', description='AllowUserToManageMFADevices'),
    }(name='MFAPreference', description='MFAPreference'),
  }(name='SecurityPreference', description='SecurityPreference'),
}

async function getSecurityPreferenceWithOptions(request: GetSecurityPreferenceRequest, runtime: Util.RuntimeOptions): GetSecurityPreferenceResponse {
  Util.validateModel(request);
  return doRequest('GetSecurityPreference', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function getSecurityPreference(request: GetSecurityPreferenceRequest): GetSecurityPreferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecurityPreferenceWithOptions(request, runtime);
}

model GetRoleRequest = {
  roleName?: string(name='RoleName', description='RoleName'),
}

model GetRoleResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  role: {
    roleId: string(name='RoleId', description='RoleId'),
    roleName: string(name='RoleName', description='RoleName'),
    arn: string(name='Arn', description='Arn'),
    description: string(name='Description', description='Description'),
    assumeRolePolicyDocument: string(name='AssumeRolePolicyDocument', description='AssumeRolePolicyDocument'),
    createDate: string(name='CreateDate', description='CreateDate'),
    updateDate: string(name='UpdateDate', description='UpdateDate'),
    maxSessionDuration: long(name='MaxSessionDuration', description='MaxSessionDuration'),
  }(name='Role', description='Role'),
}

async function getRoleWithOptions(request: GetRoleRequest, runtime: Util.RuntimeOptions): GetRoleResponse {
  Util.validateModel(request);
  return doRequest('GetRole', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function getRole(request: GetRoleRequest): GetRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRoleWithOptions(request, runtime);
}

model DetachPolicyFromRoleRequest = {
  policyType?: string(name='PolicyType', description='PolicyType'),
  policyName?: string(name='PolicyName', description='PolicyName'),
  roleName?: string(name='RoleName', description='RoleName'),
}

model DetachPolicyFromRoleResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function detachPolicyFromRoleWithOptions(request: DetachPolicyFromRoleRequest, runtime: Util.RuntimeOptions): DetachPolicyFromRoleResponse {
  Util.validateModel(request);
  return doRequest('DetachPolicyFromRole', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function detachPolicyFromRole(request: DetachPolicyFromRoleRequest): DetachPolicyFromRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachPolicyFromRoleWithOptions(request, runtime);
}

model DeleteRoleRequest = {
  roleName?: string(name='RoleName', description='RoleName'),
}

model DeleteRoleResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function deleteRoleWithOptions(request: DeleteRoleRequest, runtime: Util.RuntimeOptions): DeleteRoleResponse {
  Util.validateModel(request);
  return doRequest('DeleteRole', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function deleteRole(request: DeleteRoleRequest): DeleteRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRoleWithOptions(request, runtime);
}

model CreateRoleRequest = {
  roleName?: string(name='RoleName', description='RoleName'),
  description?: string(name='Description', description='Description'),
  assumeRolePolicyDocument?: string(name='AssumeRolePolicyDocument', description='AssumeRolePolicyDocument'),
  maxSessionDuration?: long(name='MaxSessionDuration', description='MaxSessionDuration'),
}

model CreateRoleResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  role: {
    roleId: string(name='RoleId', description='RoleId'),
    roleName: string(name='RoleName', description='RoleName'),
    arn: string(name='Arn', description='Arn'),
    description: string(name='Description', description='Description'),
    assumeRolePolicyDocument: string(name='AssumeRolePolicyDocument', description='AssumeRolePolicyDocument'),
    createDate: string(name='CreateDate', description='CreateDate'),
    maxSessionDuration: long(name='MaxSessionDuration', description='MaxSessionDuration'),
  }(name='Role', description='Role'),
}

async function createRoleWithOptions(request: CreateRoleRequest, runtime: Util.RuntimeOptions): CreateRoleResponse {
  Util.validateModel(request);
  return doRequest('CreateRole', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function createRole(request: CreateRoleRequest): CreateRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRoleWithOptions(request, runtime);
}

model AttachPolicyToRoleRequest = {
  policyType?: string(name='PolicyType', description='PolicyType'),
  policyName?: string(name='PolicyName', description='PolicyName'),
  roleName?: string(name='RoleName', description='RoleName'),
}

model AttachPolicyToRoleResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function attachPolicyToRoleWithOptions(request: AttachPolicyToRoleRequest, runtime: Util.RuntimeOptions): AttachPolicyToRoleResponse {
  Util.validateModel(request);
  return doRequest('AttachPolicyToRole', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function attachPolicyToRole(request: AttachPolicyToRoleRequest): AttachPolicyToRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachPolicyToRoleWithOptions(request, runtime);
}

model UnbindMFADeviceRequest = {
  userName?: string(name='UserName', description='UserName'),
}

model UnbindMFADeviceResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  MFADevice: {
    serialNumber: string(name='SerialNumber', description='SerialNumber'),
  }(name='MFADevice', description='MFADevice'),
}

async function unbindMFADeviceWithOptions(request: UnbindMFADeviceRequest, runtime: Util.RuntimeOptions): UnbindMFADeviceResponse {
  Util.validateModel(request);
  return doRequest('UnbindMFADevice', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function unbindMFADevice(request: UnbindMFADeviceRequest): UnbindMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindMFADeviceWithOptions(request, runtime);
}

model ListVirtualMFADevicesRequest = {
}

model ListVirtualMFADevicesResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  virtualMFADevices: {
    virtualMFADevice: [
      {
        serialNumber: string(name='SerialNumber', description='SerialNumber'),
        activateDate: string(name='ActivateDate', description='ActivateDate'),
        user: {
          userId: string(name='UserId', description='UserId'),
          userName: string(name='UserName', description='UserName'),
          displayName: string(name='DisplayName', description='DisplayName'),
        }(name='User', description='User'),
      }
    ](name='VirtualMFADevice', description='VirtualMFADevice'),
  }(name='VirtualMFADevices', description='VirtualMFADevices'),
}

async function listVirtualMFADevicesWithOptions(request: ListVirtualMFADevicesRequest, runtime: Util.RuntimeOptions): ListVirtualMFADevicesResponse {
  Util.validateModel(request);
  return doRequest('ListVirtualMFADevices', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function listVirtualMFADevices(request: ListVirtualMFADevicesRequest): ListVirtualMFADevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVirtualMFADevicesWithOptions(request, runtime);
}

model GetUserMFAInfoRequest = {
  userName?: string(name='UserName', description='UserName'),
}

model GetUserMFAInfoResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  MFADevice: {
    serialNumber: string(name='SerialNumber', description='SerialNumber'),
  }(name='MFADevice', description='MFADevice'),
}

async function getUserMFAInfoWithOptions(request: GetUserMFAInfoRequest, runtime: Util.RuntimeOptions): GetUserMFAInfoResponse {
  Util.validateModel(request);
  return doRequest('GetUserMFAInfo', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function getUserMFAInfo(request: GetUserMFAInfoRequest): GetUserMFAInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserMFAInfoWithOptions(request, runtime);
}

model DeleteVirtualMFADeviceRequest = {
  serialNumber?: string(name='SerialNumber', description='SerialNumber'),
}

model DeleteVirtualMFADeviceResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function deleteVirtualMFADeviceWithOptions(request: DeleteVirtualMFADeviceRequest, runtime: Util.RuntimeOptions): DeleteVirtualMFADeviceResponse {
  Util.validateModel(request);
  return doRequest('DeleteVirtualMFADevice', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function deleteVirtualMFADevice(request: DeleteVirtualMFADeviceRequest): DeleteVirtualMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVirtualMFADeviceWithOptions(request, runtime);
}

model CreateVirtualMFADeviceRequest = {
  virtualMFADeviceName?: string(name='VirtualMFADeviceName', description='VirtualMFADeviceName'),
}

model CreateVirtualMFADeviceResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  virtualMFADevice: {
    serialNumber: string(name='SerialNumber', description='SerialNumber'),
    base32StringSeed: string(name='Base32StringSeed', description='Base32StringSeed'),
    QRCodePNG: string(name='QRCodePNG', description='QRCodePNG'),
  }(name='VirtualMFADevice', description='VirtualMFADevice'),
}

async function createVirtualMFADeviceWithOptions(request: CreateVirtualMFADeviceRequest, runtime: Util.RuntimeOptions): CreateVirtualMFADeviceResponse {
  Util.validateModel(request);
  return doRequest('CreateVirtualMFADevice', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function createVirtualMFADevice(request: CreateVirtualMFADeviceRequest): CreateVirtualMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVirtualMFADeviceWithOptions(request, runtime);
}

model BindMFADeviceRequest = {
  serialNumber?: string(name='SerialNumber', description='SerialNumber'),
  userName?: string(name='UserName', description='UserName'),
  authenticationCode1?: string(name='AuthenticationCode1', description='AuthenticationCode1'),
  authenticationCode2?: string(name='AuthenticationCode2', description='AuthenticationCode2'),
}

model BindMFADeviceResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function bindMFADeviceWithOptions(request: BindMFADeviceRequest, runtime: Util.RuntimeOptions): BindMFADeviceResponse {
  Util.validateModel(request);
  return doRequest('BindMFADevice', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function bindMFADevice(request: BindMFADeviceRequest): BindMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindMFADeviceWithOptions(request, runtime);
}

model UpdateLoginProfileRequest = {
  userName?: string(name='UserName', description='UserName'),
  password?: string(name='Password', description='Password'),
  passwordResetRequired?: boolean(name='PasswordResetRequired', description='PasswordResetRequired'),
  MFABindRequired?: boolean(name='MFABindRequired', description='MFABindRequired'),
}

model UpdateLoginProfileResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function updateLoginProfileWithOptions(request: UpdateLoginProfileRequest, runtime: Util.RuntimeOptions): UpdateLoginProfileResponse {
  Util.validateModel(request);
  return doRequest('UpdateLoginProfile', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function updateLoginProfile(request: UpdateLoginProfileRequest): UpdateLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoginProfileWithOptions(request, runtime);
}

model GetLoginProfileRequest = {
  userName?: string(name='UserName', description='UserName'),
}

model GetLoginProfileResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  loginProfile: {
    userName: string(name='UserName', description='UserName'),
    passwordResetRequired: boolean(name='PasswordResetRequired', description='PasswordResetRequired'),
    MFABindRequired: boolean(name='MFABindRequired', description='MFABindRequired'),
    createDate: string(name='CreateDate', description='CreateDate'),
  }(name='LoginProfile', description='LoginProfile'),
}

async function getLoginProfileWithOptions(request: GetLoginProfileRequest, runtime: Util.RuntimeOptions): GetLoginProfileResponse {
  Util.validateModel(request);
  return doRequest('GetLoginProfile', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function getLoginProfile(request: GetLoginProfileRequest): GetLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLoginProfileWithOptions(request, runtime);
}

model DeleteLoginProfileRequest = {
  userName?: string(name='UserName', description='UserName'),
}

model DeleteLoginProfileResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function deleteLoginProfileWithOptions(request: DeleteLoginProfileRequest, runtime: Util.RuntimeOptions): DeleteLoginProfileResponse {
  Util.validateModel(request);
  return doRequest('DeleteLoginProfile', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function deleteLoginProfile(request: DeleteLoginProfileRequest): DeleteLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLoginProfileWithOptions(request, runtime);
}

model CreateLoginProfileRequest = {
  userName?: string(name='UserName', description='UserName'),
  password?: string(name='Password', description='Password'),
  passwordResetRequired?: boolean(name='PasswordResetRequired', description='PasswordResetRequired'),
  MFABindRequired?: boolean(name='MFABindRequired', description='MFABindRequired'),
}

model CreateLoginProfileResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  loginProfile: {
    userName: string(name='UserName', description='UserName'),
    passwordResetRequired: boolean(name='PasswordResetRequired', description='PasswordResetRequired'),
    MFABindRequired: boolean(name='MFABindRequired', description='MFABindRequired'),
    createDate: string(name='CreateDate', description='CreateDate'),
  }(name='LoginProfile', description='LoginProfile'),
}

async function createLoginProfileWithOptions(request: CreateLoginProfileRequest, runtime: Util.RuntimeOptions): CreateLoginProfileResponse {
  Util.validateModel(request);
  return doRequest('CreateLoginProfile', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function createLoginProfile(request: CreateLoginProfileRequest): CreateLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoginProfileWithOptions(request, runtime);
}

model UpdateUserRequest = {
  userName?: string(name='UserName', description='UserName'),
  newUserName?: string(name='NewUserName', description='NewUserName'),
  newDisplayName?: string(name='NewDisplayName', description='NewDisplayName'),
  newMobilePhone?: string(name='NewMobilePhone', description='NewMobilePhone'),
  newEmail?: string(name='NewEmail', description='NewEmail'),
  newComments?: string(name='NewComments', description='NewComments'),
}

model UpdateUserResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  user: {
    userId: string(name='UserId', description='UserId'),
    userName: string(name='UserName', description='UserName'),
    displayName: string(name='DisplayName', description='DisplayName'),
    mobilePhone: string(name='MobilePhone', description='MobilePhone'),
    email: string(name='Email', description='Email'),
    comments: string(name='Comments', description='Comments'),
    createDate: string(name='CreateDate', description='CreateDate'),
    updateDate: string(name='UpdateDate', description='UpdateDate'),
  }(name='User', description='User'),
}

async function updateUserWithOptions(request: UpdateUserRequest, runtime: Util.RuntimeOptions): UpdateUserResponse {
  Util.validateModel(request);
  return doRequest('UpdateUser', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserWithOptions(request, runtime);
}

model ListUsersRequest = {
  marker?: string(name='Marker', description='Marker'),
  maxItems?: integer(name='MaxItems', description='MaxItems'),
}

model ListUsersResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  isTruncated: boolean(name='IsTruncated', description='IsTruncated'),
  marker: string(name='Marker', description='Marker'),
  users: {
    user: [
      {
        userId: string(name='UserId', description='UserId'),
        userName: string(name='UserName', description='UserName'),
        displayName: string(name='DisplayName', description='DisplayName'),
        mobilePhone: string(name='MobilePhone', description='MobilePhone'),
        email: string(name='Email', description='Email'),
        comments: string(name='Comments', description='Comments'),
        createDate: string(name='CreateDate', description='CreateDate'),
        updateDate: string(name='UpdateDate', description='UpdateDate'),
      }
    ](name='User', description='User'),
  }(name='Users', description='Users'),
}

async function listUsersWithOptions(request: ListUsersRequest, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(request);
  return doRequest('ListUsers', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersWithOptions(request, runtime);
}

model GetUserRequest = {
  userName?: string(name='UserName', description='UserName'),
}

model GetUserResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  user: {
    userId: string(name='UserId', description='UserId'),
    userName: string(name='UserName', description='UserName'),
    displayName: string(name='DisplayName', description='DisplayName'),
    mobilePhone: string(name='MobilePhone', description='MobilePhone'),
    email: string(name='Email', description='Email'),
    comments: string(name='Comments', description='Comments'),
    createDate: string(name='CreateDate', description='CreateDate'),
    updateDate: string(name='UpdateDate', description='UpdateDate'),
    lastLoginDate: string(name='LastLoginDate', description='LastLoginDate'),
  }(name='User', description='User'),
}

async function getUserWithOptions(request: GetUserRequest, runtime: Util.RuntimeOptions): GetUserResponse {
  Util.validateModel(request);
  return doRequest('GetUser', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function getUser(request: GetUserRequest): GetUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserWithOptions(request, runtime);
}

model DeleteUserRequest = {
  userName?: string(name='UserName', description='UserName'),
}

model DeleteUserResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function deleteUserWithOptions(request: DeleteUserRequest, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  return doRequest('DeleteUser', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserWithOptions(request, runtime);
}

model CreateUserRequest = {
  userName?: string(name='UserName', description='UserName'),
  displayName?: string(name='DisplayName', description='DisplayName'),
  mobilePhone?: string(name='MobilePhone', description='MobilePhone'),
  email?: string(name='Email', description='Email'),
  comments?: string(name='Comments', description='Comments'),
}

model CreateUserResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  user: {
    userId: string(name='UserId', description='UserId'),
    userName: string(name='UserName', description='UserName'),
    displayName: string(name='DisplayName', description='DisplayName'),
    mobilePhone: string(name='MobilePhone', description='MobilePhone'),
    email: string(name='Email', description='Email'),
    comments: string(name='Comments', description='Comments'),
    createDate: string(name='CreateDate', description='CreateDate'),
  }(name='User', description='User'),
}

async function createUserWithOptions(request: CreateUserRequest, runtime: Util.RuntimeOptions): CreateUserResponse {
  Util.validateModel(request);
  return doRequest('CreateUser', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function createUser(request: CreateUserRequest): CreateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserWithOptions(request, runtime);
}

model UpdateAccessKeyRequest = {
  userName?: string(name='UserName', description='UserName'),
  userAccessKeyId?: string(name='UserAccessKeyId', description='UserAccessKeyId'),
  status?: string(name='Status', description='Status'),
}

model UpdateAccessKeyResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function updateAccessKeyWithOptions(request: UpdateAccessKeyRequest, runtime: Util.RuntimeOptions): UpdateAccessKeyResponse {
  Util.validateModel(request);
  return doRequest('UpdateAccessKey', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function updateAccessKey(request: UpdateAccessKeyRequest): UpdateAccessKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAccessKeyWithOptions(request, runtime);
}

model ListAccessKeysRequest = {
  userName?: string(name='UserName', description='UserName'),
}

model ListAccessKeysResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  accessKeys: {
    accessKey: [
      {
        accessKeyId: string(name='AccessKeyId', description='AccessKeyId'),
        status: string(name='Status', description='Status'),
        createDate: string(name='CreateDate', description='CreateDate'),
      }
    ](name='AccessKey', description='AccessKey'),
  }(name='AccessKeys', description='AccessKeys'),
}

async function listAccessKeysWithOptions(request: ListAccessKeysRequest, runtime: Util.RuntimeOptions): ListAccessKeysResponse {
  Util.validateModel(request);
  return doRequest('ListAccessKeys', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function listAccessKeys(request: ListAccessKeysRequest): ListAccessKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccessKeysWithOptions(request, runtime);
}

model DeleteAccessKeyRequest = {
  userName?: string(name='UserName', description='UserName'),
  userAccessKeyId?: string(name='UserAccessKeyId', description='UserAccessKeyId'),
}

model DeleteAccessKeyResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function deleteAccessKeyWithOptions(request: DeleteAccessKeyRequest, runtime: Util.RuntimeOptions): DeleteAccessKeyResponse {
  Util.validateModel(request);
  return doRequest('DeleteAccessKey', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function deleteAccessKey(request: DeleteAccessKeyRequest): DeleteAccessKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAccessKeyWithOptions(request, runtime);
}

model CreateAccessKeyRequest = {
  userName?: string(name='UserName', description='UserName'),
}

model CreateAccessKeyResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  accessKey: {
    accessKeyId: string(name='AccessKeyId', description='AccessKeyId'),
    accessKeySecret: string(name='AccessKeySecret', description='AccessKeySecret'),
    status: string(name='Status', description='Status'),
    createDate: string(name='CreateDate', description='CreateDate'),
  }(name='AccessKey', description='AccessKey'),
}

async function createAccessKeyWithOptions(request: CreateAccessKeyRequest, runtime: Util.RuntimeOptions): CreateAccessKeyResponse {
  Util.validateModel(request);
  return doRequest('CreateAccessKey', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function createAccessKey(request: CreateAccessKeyRequest): CreateAccessKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccessKeyWithOptions(request, runtime);
}

model SetPasswordPolicyRequest = {
  minimumPasswordLength?: integer(name='MinimumPasswordLength', description='MinimumPasswordLength'),
  requireLowercaseCharacters?: boolean(name='RequireLowercaseCharacters', description='RequireLowercaseCharacters'),
  requireUppercaseCharacters?: boolean(name='RequireUppercaseCharacters', description='RequireUppercaseCharacters'),
  requireNumbers?: boolean(name='RequireNumbers', description='RequireNumbers'),
  requireSymbols?: boolean(name='RequireSymbols', description='RequireSymbols'),
  hardExpiry?: boolean(name='HardExpiry', description='HardExpiry'),
  maxPasswordAge?: integer(name='MaxPasswordAge', description='MaxPasswordAge'),
  passwordReusePrevention?: integer(name='PasswordReusePrevention', description='PasswordReusePrevention'),
  maxLoginAttemps?: integer(name='MaxLoginAttemps', description='MaxLoginAttemps'),
}

model SetPasswordPolicyResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  passwordPolicy: {
    minimumPasswordLength: integer(name='MinimumPasswordLength', description='MinimumPasswordLength'),
    requireLowercaseCharacters: boolean(name='RequireLowercaseCharacters', description='RequireLowercaseCharacters'),
    requireUppercaseCharacters: boolean(name='RequireUppercaseCharacters', description='RequireUppercaseCharacters'),
    requireNumbers: boolean(name='RequireNumbers', description='RequireNumbers'),
    requireSymbols: boolean(name='RequireSymbols', description='RequireSymbols'),
    hardExpiry: boolean(name='HardExpiry', description='HardExpiry'),
    maxPasswordAge: integer(name='MaxPasswordAge', description='MaxPasswordAge'),
    passwordReusePrevention: integer(name='PasswordReusePrevention', description='PasswordReusePrevention'),
    maxLoginAttemps: integer(name='MaxLoginAttemps', description='MaxLoginAttemps'),
  }(name='PasswordPolicy', description='PasswordPolicy'),
}

async function setPasswordPolicyWithOptions(request: SetPasswordPolicyRequest, runtime: Util.RuntimeOptions): SetPasswordPolicyResponse {
  Util.validateModel(request);
  return doRequest('SetPasswordPolicy', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function setPasswordPolicy(request: SetPasswordPolicyRequest): SetPasswordPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return setPasswordPolicyWithOptions(request, runtime);
}

model SetAccountAliasRequest = {
  accountAlias?: string(name='AccountAlias', description='AccountAlias'),
}

model SetAccountAliasResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function setAccountAliasWithOptions(request: SetAccountAliasRequest, runtime: Util.RuntimeOptions): SetAccountAliasResponse {
  Util.validateModel(request);
  return doRequest('SetAccountAlias', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function setAccountAlias(request: SetAccountAliasRequest): SetAccountAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return setAccountAliasWithOptions(request, runtime);
}

model GetPasswordPolicyRequest = {
}

model GetPasswordPolicyResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  passwordPolicy: {
    minimumPasswordLength: integer(name='MinimumPasswordLength', description='MinimumPasswordLength'),
    requireLowercaseCharacters: boolean(name='RequireLowercaseCharacters', description='RequireLowercaseCharacters'),
    requireUppercaseCharacters: boolean(name='RequireUppercaseCharacters', description='RequireUppercaseCharacters'),
    requireNumbers: boolean(name='RequireNumbers', description='RequireNumbers'),
    requireSymbols: boolean(name='RequireSymbols', description='RequireSymbols'),
    hardExpiry: boolean(name='HardExpiry', description='HardExpiry'),
    maxPasswordAge: integer(name='MaxPasswordAge', description='MaxPasswordAge'),
    passwordReusePrevention: integer(name='PasswordReusePrevention', description='PasswordReusePrevention'),
    maxLoginAttemps: integer(name='MaxLoginAttemps', description='MaxLoginAttemps'),
  }(name='PasswordPolicy', description='PasswordPolicy'),
}

async function getPasswordPolicyWithOptions(request: GetPasswordPolicyRequest, runtime: Util.RuntimeOptions): GetPasswordPolicyResponse {
  Util.validateModel(request);
  return doRequest('GetPasswordPolicy', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function getPasswordPolicy(request: GetPasswordPolicyRequest): GetPasswordPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPasswordPolicyWithOptions(request, runtime);
}

model GetAccountAliasRequest = {
}

model GetAccountAliasResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  accountAlias: string(name='AccountAlias', description='AccountAlias'),
}

async function getAccountAliasWithOptions(request: GetAccountAliasRequest, runtime: Util.RuntimeOptions): GetAccountAliasResponse {
  Util.validateModel(request);
  return doRequest('GetAccountAlias', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function getAccountAlias(request: GetAccountAliasRequest): GetAccountAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccountAliasWithOptions(request, runtime);
}

model ClearAccountAliasRequest = {
}

model ClearAccountAliasResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function clearAccountAliasWithOptions(request: ClearAccountAliasRequest, runtime: Util.RuntimeOptions): ClearAccountAliasResponse {
  Util.validateModel(request);
  return doRequest('ClearAccountAlias', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function clearAccountAlias(request: ClearAccountAliasRequest): ClearAccountAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return clearAccountAliasWithOptions(request, runtime);
}

model SetDefaultPolicyVersionRequest = {
  policyName?: string(name='PolicyName', description='PolicyName'),
  versionId?: string(name='VersionId', description='VersionId'),
}

model SetDefaultPolicyVersionResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function setDefaultPolicyVersionWithOptions(request: SetDefaultPolicyVersionRequest, runtime: Util.RuntimeOptions): SetDefaultPolicyVersionResponse {
  Util.validateModel(request);
  return doRequest('SetDefaultPolicyVersion', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function setDefaultPolicyVersion(request: SetDefaultPolicyVersionRequest): SetDefaultPolicyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultPolicyVersionWithOptions(request, runtime);
}

model ListPolicyVersionsRequest = {
  policyType?: string(name='PolicyType', description='PolicyType'),
  policyName?: string(name='PolicyName', description='PolicyName'),
}

model ListPolicyVersionsResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  policyVersions: {
    policyVersion: [
      {
        versionId: string(name='VersionId', description='VersionId'),
        isDefaultVersion: boolean(name='IsDefaultVersion', description='IsDefaultVersion'),
        policyDocument: string(name='PolicyDocument', description='PolicyDocument'),
        createDate: string(name='CreateDate', description='CreateDate'),
      }
    ](name='PolicyVersion', description='PolicyVersion'),
  }(name='PolicyVersions', description='PolicyVersions'),
}

async function listPolicyVersionsWithOptions(request: ListPolicyVersionsRequest, runtime: Util.RuntimeOptions): ListPolicyVersionsResponse {
  Util.validateModel(request);
  return doRequest('ListPolicyVersions', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function listPolicyVersions(request: ListPolicyVersionsRequest): ListPolicyVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPolicyVersionsWithOptions(request, runtime);
}

model GetPolicyVersionRequest = {
  policyType?: string(name='PolicyType', description='PolicyType'),
  policyName?: string(name='PolicyName', description='PolicyName'),
  versionId?: string(name='VersionId', description='VersionId'),
}

model GetPolicyVersionResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  policyVersion: {
    versionId: string(name='VersionId', description='VersionId'),
    isDefaultVersion: boolean(name='IsDefaultVersion', description='IsDefaultVersion'),
    policyDocument: string(name='PolicyDocument', description='PolicyDocument'),
    createDate: string(name='CreateDate', description='CreateDate'),
  }(name='PolicyVersion', description='PolicyVersion'),
}

async function getPolicyVersionWithOptions(request: GetPolicyVersionRequest, runtime: Util.RuntimeOptions): GetPolicyVersionResponse {
  Util.validateModel(request);
  return doRequest('GetPolicyVersion', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function getPolicyVersion(request: GetPolicyVersionRequest): GetPolicyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPolicyVersionWithOptions(request, runtime);
}

model DeletePolicyVersionRequest = {
  policyName?: string(name='PolicyName', description='PolicyName'),
  versionId?: string(name='VersionId', description='VersionId'),
}

model DeletePolicyVersionResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function deletePolicyVersionWithOptions(request: DeletePolicyVersionRequest, runtime: Util.RuntimeOptions): DeletePolicyVersionResponse {
  Util.validateModel(request);
  return doRequest('DeletePolicyVersion', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function deletePolicyVersion(request: DeletePolicyVersionRequest): DeletePolicyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePolicyVersionWithOptions(request, runtime);
}

model CreatePolicyVersionRequest = {
  policyName?: string(name='PolicyName', description='PolicyName'),
  policyDocument?: string(name='PolicyDocument', description='PolicyDocument'),
  setAsDefault?: boolean(name='SetAsDefault', description='SetAsDefault'),
  rotateStrategy?: string(name='RotateStrategy', description='RotateStrategy'),
}

model CreatePolicyVersionResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  policyVersion: {
    versionId: string(name='VersionId', description='VersionId'),
    isDefaultVersion: boolean(name='IsDefaultVersion', description='IsDefaultVersion'),
    policyDocument: string(name='PolicyDocument', description='PolicyDocument'),
    createDate: string(name='CreateDate', description='CreateDate'),
  }(name='PolicyVersion', description='PolicyVersion'),
}

async function createPolicyVersionWithOptions(request: CreatePolicyVersionRequest, runtime: Util.RuntimeOptions): CreatePolicyVersionResponse {
  Util.validateModel(request);
  return doRequest('CreatePolicyVersion', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function createPolicyVersion(request: CreatePolicyVersionRequest): CreatePolicyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPolicyVersionWithOptions(request, runtime);
}

model ListPoliciesForUserRequest = {
  userName?: string(name='UserName', description='UserName'),
}

model ListPoliciesForUserResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  policies: {
    policy: [
      {
        policyName: string(name='PolicyName', description='PolicyName'),
        policyType: string(name='PolicyType', description='PolicyType'),
        description: string(name='Description', description='Description'),
        defaultVersion: string(name='DefaultVersion', description='DefaultVersion'),
        attachDate: string(name='AttachDate', description='AttachDate'),
      }
    ](name='Policy', description='Policy'),
  }(name='Policies', description='Policies'),
}

async function listPoliciesForUserWithOptions(request: ListPoliciesForUserRequest, runtime: Util.RuntimeOptions): ListPoliciesForUserResponse {
  Util.validateModel(request);
  return doRequest('ListPoliciesForUser', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function listPoliciesForUser(request: ListPoliciesForUserRequest): ListPoliciesForUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPoliciesForUserWithOptions(request, runtime);
}

model ListPoliciesForGroupRequest = {
  groupName?: string(name='GroupName', description='GroupName'),
}

model ListPoliciesForGroupResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  policies: {
    policy: [
      {
        policyName: string(name='PolicyName', description='PolicyName'),
        policyType: string(name='PolicyType', description='PolicyType'),
        description: string(name='Description', description='Description'),
        defaultVersion: string(name='DefaultVersion', description='DefaultVersion'),
        attachDate: string(name='AttachDate', description='AttachDate'),
      }
    ](name='Policy', description='Policy'),
  }(name='Policies', description='Policies'),
}

async function listPoliciesForGroupWithOptions(request: ListPoliciesForGroupRequest, runtime: Util.RuntimeOptions): ListPoliciesForGroupResponse {
  Util.validateModel(request);
  return doRequest('ListPoliciesForGroup', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function listPoliciesForGroup(request: ListPoliciesForGroupRequest): ListPoliciesForGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPoliciesForGroupWithOptions(request, runtime);
}

model ListEntitiesForPolicyRequest = {
  policyType?: string(name='PolicyType', description='PolicyType'),
  policyName?: string(name='PolicyName', description='PolicyName'),
}

model ListEntitiesForPolicyResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  groups: {
    group: [
      {
        groupName: string(name='GroupName', description='GroupName'),
        comments: string(name='Comments', description='Comments'),
        attachDate: string(name='AttachDate', description='AttachDate'),
      }
    ](name='Group', description='Group'),
  }(name='Groups', description='Groups'),
  users: {
    user: [
      {
        userId: string(name='UserId', description='UserId'),
        userName: string(name='UserName', description='UserName'),
        displayName: string(name='DisplayName', description='DisplayName'),
        attachDate: string(name='AttachDate', description='AttachDate'),
      }
    ](name='User', description='User'),
  }(name='Users', description='Users'),
  roles: {
    role: [
      {
        roleId: string(name='RoleId', description='RoleId'),
        roleName: string(name='RoleName', description='RoleName'),
        arn: string(name='Arn', description='Arn'),
        description: string(name='Description', description='Description'),
        attachDate: string(name='AttachDate', description='AttachDate'),
      }
    ](name='Role', description='Role'),
  }(name='Roles', description='Roles'),
}

async function listEntitiesForPolicyWithOptions(request: ListEntitiesForPolicyRequest, runtime: Util.RuntimeOptions): ListEntitiesForPolicyResponse {
  Util.validateModel(request);
  return doRequest('ListEntitiesForPolicy', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function listEntitiesForPolicy(request: ListEntitiesForPolicyRequest): ListEntitiesForPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEntitiesForPolicyWithOptions(request, runtime);
}

model DetachPolicyFromUserRequest = {
  policyType?: string(name='PolicyType', description='PolicyType'),
  policyName?: string(name='PolicyName', description='PolicyName'),
  userName?: string(name='UserName', description='UserName'),
}

model DetachPolicyFromUserResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function detachPolicyFromUserWithOptions(request: DetachPolicyFromUserRequest, runtime: Util.RuntimeOptions): DetachPolicyFromUserResponse {
  Util.validateModel(request);
  return doRequest('DetachPolicyFromUser', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function detachPolicyFromUser(request: DetachPolicyFromUserRequest): DetachPolicyFromUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachPolicyFromUserWithOptions(request, runtime);
}

model DetachPolicyFromGroupRequest = {
  policyType?: string(name='PolicyType', description='PolicyType'),
  policyName?: string(name='PolicyName', description='PolicyName'),
  groupName?: string(name='GroupName', description='GroupName'),
}

model DetachPolicyFromGroupResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function detachPolicyFromGroupWithOptions(request: DetachPolicyFromGroupRequest, runtime: Util.RuntimeOptions): DetachPolicyFromGroupResponse {
  Util.validateModel(request);
  return doRequest('DetachPolicyFromGroup', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function detachPolicyFromGroup(request: DetachPolicyFromGroupRequest): DetachPolicyFromGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachPolicyFromGroupWithOptions(request, runtime);
}

model AttachPolicyToUserRequest = {
  policyType?: string(name='PolicyType', description='PolicyType'),
  policyName?: string(name='PolicyName', description='PolicyName'),
  userName?: string(name='UserName', description='UserName'),
}

model AttachPolicyToUserResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function attachPolicyToUserWithOptions(request: AttachPolicyToUserRequest, runtime: Util.RuntimeOptions): AttachPolicyToUserResponse {
  Util.validateModel(request);
  return doRequest('AttachPolicyToUser', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function attachPolicyToUser(request: AttachPolicyToUserRequest): AttachPolicyToUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachPolicyToUserWithOptions(request, runtime);
}

model AttachPolicyToGroupRequest = {
  policyType?: string(name='PolicyType', description='PolicyType'),
  policyName?: string(name='PolicyName', description='PolicyName'),
  groupName?: string(name='GroupName', description='GroupName'),
}

model AttachPolicyToGroupResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function attachPolicyToGroupWithOptions(request: AttachPolicyToGroupRequest, runtime: Util.RuntimeOptions): AttachPolicyToGroupResponse {
  Util.validateModel(request);
  return doRequest('AttachPolicyToGroup', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function attachPolicyToGroup(request: AttachPolicyToGroupRequest): AttachPolicyToGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachPolicyToGroupWithOptions(request, runtime);
}

model ListPoliciesRequest = {
  policyType?: string(name='PolicyType', description='PolicyType'),
  marker?: string(name='Marker', description='Marker'),
  maxItems?: integer(name='MaxItems', description='MaxItems'),
}

model ListPoliciesResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  isTruncated: boolean(name='IsTruncated', description='IsTruncated'),
  marker: string(name='Marker', description='Marker'),
  policies: {
    policy: [
      {
        policyName: string(name='PolicyName', description='PolicyName'),
        policyType: string(name='PolicyType', description='PolicyType'),
        description: string(name='Description', description='Description'),
        defaultVersion: string(name='DefaultVersion', description='DefaultVersion'),
        createDate: string(name='CreateDate', description='CreateDate'),
        updateDate: string(name='UpdateDate', description='UpdateDate'),
        attachmentCount: integer(name='AttachmentCount', description='AttachmentCount'),
      }
    ](name='Policy', description='Policy'),
  }(name='Policies', description='Policies'),
}

async function listPoliciesWithOptions(request: ListPoliciesRequest, runtime: Util.RuntimeOptions): ListPoliciesResponse {
  Util.validateModel(request);
  return doRequest('ListPolicies', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function listPolicies(request: ListPoliciesRequest): ListPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPoliciesWithOptions(request, runtime);
}

model GetPolicyRequest = {
  policyType?: string(name='PolicyType', description='PolicyType'),
  policyName?: string(name='PolicyName', description='PolicyName'),
}

model GetPolicyResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  policy: {
    policyName: string(name='PolicyName', description='PolicyName'),
    policyType: string(name='PolicyType', description='PolicyType'),
    description: string(name='Description', description='Description'),
    defaultVersion: string(name='DefaultVersion', description='DefaultVersion'),
    policyDocument: string(name='PolicyDocument', description='PolicyDocument'),
    createDate: string(name='CreateDate', description='CreateDate'),
    updateDate: string(name='UpdateDate', description='UpdateDate'),
    attachmentCount: integer(name='AttachmentCount', description='AttachmentCount'),
  }(name='Policy', description='Policy'),
  defaultPolicyVersion: {
    versionId: string(name='VersionId', description='VersionId'),
    isDefaultVersion: boolean(name='IsDefaultVersion', description='IsDefaultVersion'),
    policyDocument: string(name='PolicyDocument', description='PolicyDocument'),
    createDate: string(name='CreateDate', description='CreateDate'),
  }(name='DefaultPolicyVersion', description='DefaultPolicyVersion'),
}

async function getPolicyWithOptions(request: GetPolicyRequest, runtime: Util.RuntimeOptions): GetPolicyResponse {
  Util.validateModel(request);
  return doRequest('GetPolicy', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function getPolicy(request: GetPolicyRequest): GetPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPolicyWithOptions(request, runtime);
}

model DeletePolicyRequest = {
  policyName?: string(name='PolicyName', description='PolicyName'),
}

model DeletePolicyResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function deletePolicyWithOptions(request: DeletePolicyRequest, runtime: Util.RuntimeOptions): DeletePolicyResponse {
  Util.validateModel(request);
  return doRequest('DeletePolicy', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function deletePolicy(request: DeletePolicyRequest): DeletePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePolicyWithOptions(request, runtime);
}

model CreatePolicyRequest = {
  policyName?: string(name='PolicyName', description='PolicyName'),
  description?: string(name='Description', description='Description'),
  policyDocument?: string(name='PolicyDocument', description='PolicyDocument'),
}

model CreatePolicyResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  policy: {
    policyName: string(name='PolicyName', description='PolicyName'),
    policyType: string(name='PolicyType', description='PolicyType'),
    description: string(name='Description', description='Description'),
    defaultVersion: string(name='DefaultVersion', description='DefaultVersion'),
    createDate: string(name='CreateDate', description='CreateDate'),
  }(name='Policy', description='Policy'),
}

async function createPolicyWithOptions(request: CreatePolicyRequest, runtime: Util.RuntimeOptions): CreatePolicyResponse {
  Util.validateModel(request);
  return doRequest('CreatePolicy', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function createPolicy(request: CreatePolicyRequest): CreatePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPolicyWithOptions(request, runtime);
}

model RemoveUserFromGroupRequest = {
  userName?: string(name='UserName', description='UserName'),
  groupName?: string(name='GroupName', description='GroupName'),
}

model RemoveUserFromGroupResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function removeUserFromGroupWithOptions(request: RemoveUserFromGroupRequest, runtime: Util.RuntimeOptions): RemoveUserFromGroupResponse {
  Util.validateModel(request);
  return doRequest('RemoveUserFromGroup', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function removeUserFromGroup(request: RemoveUserFromGroupRequest): RemoveUserFromGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeUserFromGroupWithOptions(request, runtime);
}

model ListUsersForGroupRequest = {
  groupName?: string(name='GroupName', description='GroupName'),
  marker?: string(name='Marker', description='Marker'),
  maxItems?: integer(name='MaxItems', description='MaxItems'),
}

model ListUsersForGroupResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  isTruncated: boolean(name='IsTruncated', description='IsTruncated'),
  marker: string(name='Marker', description='Marker'),
  users: {
    user: [
      {
        userName: string(name='UserName', description='UserName'),
        displayName: string(name='DisplayName', description='DisplayName'),
        joinDate: string(name='JoinDate', description='JoinDate'),
      }
    ](name='User', description='User'),
  }(name='Users', description='Users'),
}

async function listUsersForGroupWithOptions(request: ListUsersForGroupRequest, runtime: Util.RuntimeOptions): ListUsersForGroupResponse {
  Util.validateModel(request);
  return doRequest('ListUsersForGroup', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function listUsersForGroup(request: ListUsersForGroupRequest): ListUsersForGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersForGroupWithOptions(request, runtime);
}

model ListGroupsForUserRequest = {
  userName?: string(name='UserName', description='UserName'),
}

model ListGroupsForUserResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  groups: {
    group: [
      {
        groupName: string(name='GroupName', description='GroupName'),
        comments: string(name='Comments', description='Comments'),
        joinDate: string(name='JoinDate', description='JoinDate'),
      }
    ](name='Group', description='Group'),
  }(name='Groups', description='Groups'),
}

async function listGroupsForUserWithOptions(request: ListGroupsForUserRequest, runtime: Util.RuntimeOptions): ListGroupsForUserResponse {
  Util.validateModel(request);
  return doRequest('ListGroupsForUser', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function listGroupsForUser(request: ListGroupsForUserRequest): ListGroupsForUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGroupsForUserWithOptions(request, runtime);
}

model AddUserToGroupRequest = {
  userName?: string(name='UserName', description='UserName'),
  groupName?: string(name='GroupName', description='GroupName'),
}

model AddUserToGroupResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function addUserToGroupWithOptions(request: AddUserToGroupRequest, runtime: Util.RuntimeOptions): AddUserToGroupResponse {
  Util.validateModel(request);
  return doRequest('AddUserToGroup', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function addUserToGroup(request: AddUserToGroupRequest): AddUserToGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUserToGroupWithOptions(request, runtime);
}

model UpdateGroupRequest = {
  groupName?: string(name='GroupName', description='GroupName'),
  newGroupName?: string(name='NewGroupName', description='NewGroupName'),
  newComments?: string(name='NewComments', description='NewComments'),
}

model UpdateGroupResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  group: {
    groupName: string(name='GroupName', description='GroupName'),
    comments: string(name='Comments', description='Comments'),
    createDate: string(name='CreateDate', description='CreateDate'),
    updateDate: string(name='UpdateDate', description='UpdateDate'),
  }(name='Group', description='Group'),
}

async function updateGroupWithOptions(request: UpdateGroupRequest, runtime: Util.RuntimeOptions): UpdateGroupResponse {
  Util.validateModel(request);
  return doRequest('UpdateGroup', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function updateGroup(request: UpdateGroupRequest): UpdateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGroupWithOptions(request, runtime);
}

model ListGroupsRequest = {
  marker?: string(name='Marker', description='Marker'),
  maxItems?: integer(name='MaxItems', description='MaxItems'),
}

model ListGroupsResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  isTruncated: boolean(name='IsTruncated', description='IsTruncated'),
  marker: string(name='Marker', description='Marker'),
  groups: {
    group: [
      {
        groupName: string(name='GroupName', description='GroupName'),
        comments: string(name='Comments', description='Comments'),
        createDate: string(name='CreateDate', description='CreateDate'),
        updateDate: string(name='UpdateDate', description='UpdateDate'),
      }
    ](name='Group', description='Group'),
  }(name='Groups', description='Groups'),
}

async function listGroupsWithOptions(request: ListGroupsRequest, runtime: Util.RuntimeOptions): ListGroupsResponse {
  Util.validateModel(request);
  return doRequest('ListGroups', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function listGroups(request: ListGroupsRequest): ListGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGroupsWithOptions(request, runtime);
}

model GetGroupRequest = {
  groupName?: string(name='GroupName', description='GroupName'),
}

model GetGroupResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  group: {
    groupName: string(name='GroupName', description='GroupName'),
    comments: string(name='Comments', description='Comments'),
    createDate: string(name='CreateDate', description='CreateDate'),
    updateDate: string(name='UpdateDate', description='UpdateDate'),
  }(name='Group', description='Group'),
}

async function getGroupWithOptions(request: GetGroupRequest, runtime: Util.RuntimeOptions): GetGroupResponse {
  Util.validateModel(request);
  return doRequest('GetGroup', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function getGroup(request: GetGroupRequest): GetGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGroupWithOptions(request, runtime);
}

model DeleteGroupRequest = {
  groupName?: string(name='GroupName', description='GroupName'),
}

model DeleteGroupResponse = {
  requestId: string(name='RequestId', description='RequestId'),
}

async function deleteGroupWithOptions(request: DeleteGroupRequest, runtime: Util.RuntimeOptions): DeleteGroupResponse {
  Util.validateModel(request);
  return doRequest('DeleteGroup', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function deleteGroup(request: DeleteGroupRequest): DeleteGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGroupWithOptions(request, runtime);
}

model CreateGroupRequest = {
  groupName?: string(name='GroupName', description='GroupName'),
  comments?: string(name='Comments', description='Comments'),
}

model CreateGroupResponse = {
  requestId: string(name='RequestId', description='RequestId'),
  group: {
    groupName: string(name='GroupName', description='GroupName'),
    comments: string(name='Comments', description='Comments'),
    createDate: string(name='CreateDate', description='CreateDate'),
  }(name='Group', description='Group'),
}

async function createGroupWithOptions(request: CreateGroupRequest, runtime: Util.RuntimeOptions): CreateGroupResponse {
  Util.validateModel(request);
  return doRequest('CreateGroup', 'HTTPS', 'POST', '2015-05-01', 'AK', null, request, runtime);
}

async function createGroup(request: CreateGroupRequest): CreateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGroupWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
