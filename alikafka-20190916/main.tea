import Util;
import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'alikafka.ap-south-1.aliyuncs.com',
    ap-southeast-2 = 'alikafka.ap-south-1.aliyuncs.com',
    ap-southeast-3 = 'alikafka.ap-south-1.aliyuncs.com',
    cn-chengdu = 'alikafka.aliyuncs.com',
    eu-central-1 = 'alikafka.ap-south-1.aliyuncs.com',
    eu-west-1 = 'alikafka.ap-south-1.aliyuncs.com',
    me-east-1 = 'alikafka.ap-south-1.aliyuncs.com',
    us-east-1 = 'alikafka.ap-south-1.aliyuncs.com',
    us-west-1 = 'alikafka.ap-south-1.aliyuncs.com',
    cn-hangzhou-finance = 'alikafka.aliyuncs.com',
    cn-shenzhen-finance-1 = 'alikafka.aliyuncs.com',
    cn-shanghai-finance-1 = 'alikafka.aliyuncs.com',
    cn-north-2-gov-1 = 'alikafka.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('alikafka', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model GetAllowedIpListRequest = {
  regionId: string(name='RegionId', description='_regionId'),
  instanceId: string(name='InstanceId', description='instanceId'),
}

model GetAllowedIpListResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
  allowedList: {
    deployType: integer(name='DeployType', description='deployType'),
    vpcList: [
      {
        portRange: string(name='PortRange', description='portRange'),
        allowedIpList: [ string ](name='AllowedIpList', description='whiteIPList'),
      }
    ](name='VpcList', description='vpcList'),
    internetList: [
      {
        portRange: string(name='PortRange', description='portRange'),
        allowedIpList: [ string ](name='AllowedIpList', description='whiteIPList'),
      }
    ](name='InternetList', description='internetList'),
  }(name='AllowedList', description='data'),
}

async function getAllowedIpListWithOptions(request: GetAllowedIpListRequest, runtime: Util.RuntimeOptions): GetAllowedIpListResponse {
  Util.validateModel(request);
  return doRequest('GetAllowedIpList', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function getAllowedIpList(request: GetAllowedIpListRequest): GetAllowedIpListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAllowedIpListWithOptions(request, runtime);
}

model UpdateAllowedIpRequest = {
  regionId: string(name='RegionId', description='_regionId'),
  updateType?: string(name='UpdateType', description='updateType'),
  portRange?: string(name='PortRange', description='portRange'),
  allowedListType?: string(name='AllowedListType', description='whiteListType'),
  allowedListIp?: string(name='AllowedListIp', description='whiteListStr'),
  instanceId?: string(name='InstanceId', description='instanceId'),
}

model UpdateAllowedIpResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
}

async function updateAllowedIpWithOptions(request: UpdateAllowedIpRequest, runtime: Util.RuntimeOptions): UpdateAllowedIpResponse {
  Util.validateModel(request);
  return doRequest('UpdateAllowedIp', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function updateAllowedIp(request: UpdateAllowedIpRequest): UpdateAllowedIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAllowedIpWithOptions(request, runtime);
}

model ModifyPartitionNumRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
  topic: string(name='Topic', description='topic'),
  regionId: string(name='RegionId', description='_regionId'),
  addPartitionNum: integer(name='AddPartitionNum', description='partitionNum'),
}

model ModifyPartitionNumResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
}

async function modifyPartitionNumWithOptions(request: ModifyPartitionNumRequest, runtime: Util.RuntimeOptions): ModifyPartitionNumResponse {
  Util.validateModel(request);
  return doRequest('ModifyPartitionNum', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function modifyPartitionNum(request: ModifyPartitionNumRequest): ModifyPartitionNumResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPartitionNumWithOptions(request, runtime);
}

model ModifyTopicRemarkRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
  topic: string(name='Topic', description='topic'),
  regionId: string(name='RegionId', description='_regionId'),
  remark?: string(name='Remark', description='remark'),
}

model ModifyTopicRemarkResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
}

async function modifyTopicRemarkWithOptions(request: ModifyTopicRemarkRequest, runtime: Util.RuntimeOptions): ModifyTopicRemarkResponse {
  Util.validateModel(request);
  return doRequest('ModifyTopicRemark', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function modifyTopicRemark(request: ModifyTopicRemarkRequest): ModifyTopicRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyTopicRemarkWithOptions(request, runtime);
}

model DeleteSaslUserRequest = {
  regionId: string(name='RegionId', description='_regionId'),
  instanceId: string(name='InstanceId', description='instanceId'),
  username: string(name='Username', description='username'),
  type?: string(name='Type', description='type'),
}

model DeleteSaslUserResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
}

async function deleteSaslUserWithOptions(request: DeleteSaslUserRequest, runtime: Util.RuntimeOptions): DeleteSaslUserResponse {
  Util.validateModel(request);
  return doRequest('DeleteSaslUser', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function deleteSaslUser(request: DeleteSaslUserRequest): DeleteSaslUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSaslUserWithOptions(request, runtime);
}

model DescribeSaslUsersRequest = {
  regionId: string(name='RegionId', description='_regionId'),
  instanceId: string(name='InstanceId', description='instanceId'),
}

model DescribeSaslUsersResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
  saslUserList: {
    saslUserVO: [
      {
        username: string(name='Username', description='username'),
        password: string(name='Password', description='password'),
        type: string(name='Type', description='type'),
      }
    ](name='SaslUserVO', description='SaslUserVO'),
  }(name='SaslUserList', description='data'),
}

async function describeSaslUsersWithOptions(request: DescribeSaslUsersRequest, runtime: Util.RuntimeOptions): DescribeSaslUsersResponse {
  Util.validateModel(request);
  return doRequest('DescribeSaslUsers', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function describeSaslUsers(request: DescribeSaslUsersRequest): DescribeSaslUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSaslUsersWithOptions(request, runtime);
}

model CreateAclRequest = {
  regionId: string(name='RegionId', description='_regionId'),
  instanceId: string(name='InstanceId', description='instanceId'),
  username: string(name='Username', description='username'),
  aclResourceType: string(name='AclResourceType', description='aclResourceType'),
  aclResourceName: string(name='AclResourceName', description='aclResourceName'),
  aclResourcePatternType: string(name='AclResourcePatternType', description='aclResourcePatternType'),
  aclOperationType: string(name='AclOperationType', description='aclOperationType'),
}

model CreateAclResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
}

async function createAclWithOptions(request: CreateAclRequest, runtime: Util.RuntimeOptions): CreateAclResponse {
  Util.validateModel(request);
  return doRequest('CreateAcl', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function createAcl(request: CreateAclRequest): CreateAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAclWithOptions(request, runtime);
}

model CreateSaslUserRequest = {
  regionId: string(name='RegionId', description='_regionId'),
  instanceId: string(name='InstanceId', description='instanceId'),
  username: string(name='Username', description='username'),
  password: string(name='Password', description='password'),
  type?: string(name='Type', description='type'),
}

model CreateSaslUserResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
}

async function createSaslUserWithOptions(request: CreateSaslUserRequest, runtime: Util.RuntimeOptions): CreateSaslUserResponse {
  Util.validateModel(request);
  return doRequest('CreateSaslUser', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function createSaslUser(request: CreateSaslUserRequest): CreateSaslUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSaslUserWithOptions(request, runtime);
}

model DeleteAclRequest = {
  regionId: string(name='RegionId', description='_regionId'),
  instanceId: string(name='InstanceId', description='instanceId'),
  username: string(name='Username', description='username'),
  aclResourceType: string(name='AclResourceType', description='aclResourceType'),
  aclResourceName: string(name='AclResourceName', description='aclResourceName'),
  aclResourcePatternType: string(name='AclResourcePatternType', description='aclResourcePatternType'),
  aclOperationType: string(name='AclOperationType', description='aclOperationType'),
}

model DeleteAclResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
}

async function deleteAclWithOptions(request: DeleteAclRequest, runtime: Util.RuntimeOptions): DeleteAclResponse {
  Util.validateModel(request);
  return doRequest('DeleteAcl', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function deleteAcl(request: DeleteAclRequest): DeleteAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAclWithOptions(request, runtime);
}

model DescribeAclsRequest = {
  regionId: string(name='RegionId', description='_regionId'),
  instanceId: string(name='InstanceId', description='instanceId'),
  username: string(name='Username', description='username'),
  aclResourceType: string(name='AclResourceType', description='aclResourceType'),
  aclResourceName: string(name='AclResourceName', description='aclResourceName'),
}

model DescribeAclsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
  kafkaAclList: {
    kafkaAclVO: [
      {
        username: string(name='Username', description='username'),
        aclResourceType: string(name='AclResourceType', description='aclResourceType'),
        aclResourceName: string(name='AclResourceName', description='aclResourceName'),
        aclResourcePatternType: string(name='AclResourcePatternType', description='aclResourcePatternType'),
        host: string(name='Host', description='host'),
        aclOperationType: string(name='AclOperationType', description='aclOperationType'),
      }
    ](name='KafkaAclVO', description='KafkaAclVO'),
  }(name='KafkaAclList', description='data'),
}

async function describeAclsWithOptions(request: DescribeAclsRequest, runtime: Util.RuntimeOptions): DescribeAclsResponse {
  Util.validateModel(request);
  return doRequest('DescribeAcls', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function describeAcls(request: DescribeAclsRequest): DescribeAclsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAclsWithOptions(request, runtime);
}

model CreatePrePayOrderRequest = {
  regionId: string(name='RegionId', description='_regionId'),
  topicQuota: integer(name='TopicQuota', description='topicQuota'),
  diskType: string(name='DiskType', description='diskType'),
  diskSize: integer(name='DiskSize', description='diskSize'),
  deployType: integer(name='DeployType', description='deployType'),
  ioMax: integer(name='IoMax', description='ioMax'),
  eipMax?: integer(name='EipMax', description='eipMax'),
  specType?: string(name='SpecType', description='specType'),
}

model CreatePrePayOrderResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
  orderId: string(name='OrderId', description='data'),
}

async function createPrePayOrderWithOptions(request: CreatePrePayOrderRequest, runtime: Util.RuntimeOptions): CreatePrePayOrderResponse {
  Util.validateModel(request);
  return doRequest('CreatePrePayOrder', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function createPrePayOrder(request: CreatePrePayOrderRequest): CreatePrePayOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPrePayOrderWithOptions(request, runtime);
}

model UpgradePrePayOrderRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
  topicQuota: integer(name='TopicQuota', description='topicQuota'),
  diskSize: integer(name='DiskSize', description='diskSize'),
  regionId: string(name='RegionId', description='_regionId'),
  ioMax: integer(name='IoMax', description='ioMax'),
  specType?: string(name='SpecType', description='specType'),
  eipMax?: integer(name='EipMax', description='eipMax'),
}

model UpgradePrePayOrderResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
}

async function upgradePrePayOrderWithOptions(request: UpgradePrePayOrderRequest, runtime: Util.RuntimeOptions): UpgradePrePayOrderResponse {
  Util.validateModel(request);
  return doRequest('UpgradePrePayOrder', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function upgradePrePayOrder(request: UpgradePrePayOrderRequest): UpgradePrePayOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradePrePayOrderWithOptions(request, runtime);
}

model DeleteInstanceRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
  regionId: string(name='RegionId', description='_regionId'),
}

model DeleteInstanceResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
}

async function deleteInstanceWithOptions(request: DeleteInstanceRequest, runtime: Util.RuntimeOptions): DeleteInstanceResponse {
  Util.validateModel(request);
  return doRequest('DeleteInstance', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function deleteInstance(request: DeleteInstanceRequest): DeleteInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstanceWithOptions(request, runtime);
}

model GetMetaProductListRequest = {
  listNormal?: string(name='ListNormal', description='listNormal'),
  regionId: string(name='RegionId', description='_regionId'),
}

model GetMetaProductListResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
  metaData: {
    names: map[string]any(name='Names', description='enumNames'),
    productsNormal: {
      specVO: [
        {
          regionId: string(name='RegionId', description='regionId'),
          specType: string(name='SpecType', description='specType'),
          ioMax: long(name='IoMax', description='ioMax'),
          diskType: string(name='DiskType', description='diskType'),
          diskSize: string(name='DiskSize', description='diskSize'),
          topicQuota: string(name='TopicQuota', description='topicQuota'),
          deployType: string(name='DeployType', description='deployType'),
        }
      ](name='SpecVO', description='SpecVO'),
    }(name='ProductsNormal', description='productsNormal'),
    productsProfessional: {
      specVO: [
        {
          regionId: string(name='RegionId', description='regionId'),
          specType: string(name='SpecType', description='specType'),
          ioMax: integer(name='IoMax', description='ioMax'),
          diskType: string(name='DiskType', description='diskType'),
          diskSize: string(name='DiskSize', description='diskSize'),
          topicQuota: string(name='TopicQuota', description='topicQuota'),
          deployType: string(name='DeployType', description='deployType'),
        }
      ](name='SpecVO', description='SpecVO'),
    }(name='ProductsProfessional', description='productsProfessional'),
  }(name='MetaData', description='data'),
}

async function getMetaProductListWithOptions(request: GetMetaProductListRequest, runtime: Util.RuntimeOptions): GetMetaProductListResponse {
  Util.validateModel(request);
  return doRequest('GetMetaProductList', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function getMetaProductList(request: GetMetaProductListRequest): GetMetaProductListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaProductListWithOptions(request, runtime);
}

model ConvertPostPayOrderRequest = {
  regionId: string(name='RegionId', description='_regionId'),
  instanceId: string(name='InstanceId', description='instanceId'),
  duration?: integer(name='Duration', description='duration'),
}

model ConvertPostPayOrderResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
  orderId: string(name='OrderId', description='data'),
}

async function convertPostPayOrderWithOptions(request: ConvertPostPayOrderRequest, runtime: Util.RuntimeOptions): ConvertPostPayOrderResponse {
  Util.validateModel(request);
  return doRequest('ConvertPostPayOrder', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function convertPostPayOrder(request: ConvertPostPayOrderRequest): ConvertPostPayOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return convertPostPayOrderWithOptions(request, runtime);
}

model ListTagResourcesRequest = {
  regionId: string(name='RegionId', description='_regionId'),
  resourceType: string(name='ResourceType', description='resourceType'),
  resourceId?: [ string ](name='ResourceId', description='resourceIds'),
  tag?: [
    {
      key?: string(name='Key', description='key'),
      value?: string(name='Value', description='value'),
    }
  ](name='Tag', description='tags'),
  nextToken?: string(name='NextToken', description='nextToken'),
}

model ListTagResourcesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  nextToken: string(name='NextToken', description='data.nextToken'),
  tagResources: {
    tagResource: [
      {
        tagKey: string(name='TagKey', description='keyName'),
        tagValue: string(name='TagValue', description='valueName'),
        resourceType: string(name='ResourceType', description='resourceType'),
        resourceId: string(name='ResourceId', description='resourceId'),
      }
    ](name='TagResource', description='TagResource'),
  }(name='TagResources', description='data.resources'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  return doRequest('ListTagResources', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest = {
  regionId: string(name='RegionId', description='_regionId'),
  resourceType: string(name='ResourceType', description='resourceType'),
  resourceId: [ string ](name='ResourceId', description='resourceIds'),
  tagKey?: [ string ](name='TagKey', description='tagKeys'),
  all?: boolean(name='All', description='all'),
}

model UntagResourcesResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  return doRequest('UntagResources', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model TagResourcesRequest = {
  regionId: string(name='RegionId', description='_regionId'),
  resourceType: string(name='ResourceType', description='resourceType'),
  resourceId: [ string ](name='ResourceId', description='resourceIds'),
  tag: [
    {
      key: string(name='Key', description='key'),
      value?: string(name='Value', description='value'),
    }
  ](name='Tag', description='tags'),
}

model TagResourcesResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  return doRequest('TagResources', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model DescribeNodeStatusRequest = {
  regionId: string(name='RegionId', description='_regionId'),
  instanceId: string(name='InstanceId', description='instanceId'),
}

model DescribeNodeStatusResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
  statusList: {
    status: [ string ](name='Status', description='Status'),
  }(name='StatusList', description='data'),
}

async function describeNodeStatusWithOptions(request: DescribeNodeStatusRequest, runtime: Util.RuntimeOptions): DescribeNodeStatusResponse {
  Util.validateModel(request);
  return doRequest('DescribeNodeStatus', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function describeNodeStatus(request: DescribeNodeStatusRequest): DescribeNodeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNodeStatusWithOptions(request, runtime);
}

model CreatePostPayOrderRequest = {
  regionId: string(name='RegionId', description='_regionId'),
  topicQuota: integer(name='TopicQuota', description='topicQuota'),
  diskType: string(name='DiskType', description='diskType'),
  diskSize: integer(name='DiskSize', description='diskSize'),
  deployType: integer(name='DeployType', description='deployType'),
  ioMax: integer(name='IoMax', description='ioMax'),
  eipMax?: integer(name='EipMax', description='eipMax'),
}

model CreatePostPayOrderResponse = {
  requestId: string(name='RequestId', description='requestId'),
  success: boolean(name='Success', description='success'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
  orderId: string(name='OrderId', description='data'),
}

async function createPostPayOrderWithOptions(request: CreatePostPayOrderRequest, runtime: Util.RuntimeOptions): CreatePostPayOrderResponse {
  Util.validateModel(request);
  return doRequest('CreatePostPayOrder', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function createPostPayOrder(request: CreatePostPayOrderRequest): CreatePostPayOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPostPayOrderWithOptions(request, runtime);
}

model UpgradePostPayOrderRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
  topicQuota: integer(name='TopicQuota', description='topicQuota'),
  diskSize: integer(name='DiskSize', description='diskSize'),
  regionId: string(name='RegionId', description='_regionId'),
  ioMax: integer(name='IoMax', description='ioMax'),
  specType?: string(name='SpecType', description='specType'),
  eipMax?: integer(name='EipMax', description='eipMax'),
}

model UpgradePostPayOrderResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
}

async function upgradePostPayOrderWithOptions(request: UpgradePostPayOrderRequest, runtime: Util.RuntimeOptions): UpgradePostPayOrderResponse {
  Util.validateModel(request);
  return doRequest('UpgradePostPayOrder', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function upgradePostPayOrder(request: UpgradePostPayOrderRequest): UpgradePostPayOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradePostPayOrderWithOptions(request, runtime);
}

model StartInstanceRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
  regionId: string(name='RegionId', description='_regionId'),
  vpcId: string(name='VpcId', description='vpcId'),
  vSwitchId: string(name='VSwitchId', description='vSwitchId'),
  deployModule?: string(name='DeployModule', description='deployModule'),
  zoneId: string(name='ZoneId', description='zoneId'),
  isEipInner?: boolean(name='IsEipInner', description='isEipInner'),
  isSetUserAndPassword?: boolean(name='IsSetUserAndPassword', description='isSetUserAndPassword'),
  username?: string(name='Username', description='username'),
  password?: string(name='Password', description='password'),
  name?: string(name='Name', description='name'),
  securityGroup?: string(name='SecurityGroup', description='securityGroup'),
}

model StartInstanceResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
}

async function startInstanceWithOptions(request: StartInstanceRequest, runtime: Util.RuntimeOptions): StartInstanceResponse {
  Util.validateModel(request);
  return doRequest('StartInstance', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function startInstance(request: StartInstanceRequest): StartInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return startInstanceWithOptions(request, runtime);
}

model ModifyInstanceNameRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
  regionId: string(name='RegionId', description='_regionId'),
  instanceName: string(name='InstanceName', description='instanceName'),
}

model ModifyInstanceNameResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
}

async function modifyInstanceNameWithOptions(request: ModifyInstanceNameRequest, runtime: Util.RuntimeOptions): ModifyInstanceNameResponse {
  Util.validateModel(request);
  return doRequest('ModifyInstanceName', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function modifyInstanceName(request: ModifyInstanceNameRequest): ModifyInstanceNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceNameWithOptions(request, runtime);
}

model ReleaseInstanceRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
  regionId: string(name='RegionId', description='_regionId'),
  forceDeleteInstance?: boolean(name='ForceDeleteInstance', description='forceDeleteInstance'),
}

model ReleaseInstanceResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
}

async function releaseInstanceWithOptions(request: ReleaseInstanceRequest, runtime: Util.RuntimeOptions): ReleaseInstanceResponse {
  Util.validateModel(request);
  return doRequest('ReleaseInstance', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function releaseInstance(request: ReleaseInstanceRequest): ReleaseInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseInstanceWithOptions(request, runtime);
}

model CreateConsumerGroupRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
  consumerId: string(name='ConsumerId', description='consumerId'),
  regionId: string(name='RegionId', description='_regionId'),
  remark?: string(name='Remark', description='remark'),
}

model CreateConsumerGroupResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
}

async function createConsumerGroupWithOptions(request: CreateConsumerGroupRequest, runtime: Util.RuntimeOptions): CreateConsumerGroupResponse {
  Util.validateModel(request);
  return doRequest('CreateConsumerGroup', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function createConsumerGroup(request: CreateConsumerGroupRequest): CreateConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createConsumerGroupWithOptions(request, runtime);
}

model CreateTopicRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
  topic: string(name='Topic', description='topic'),
  remark: string(name='Remark', description='remark'),
  regionId: string(name='RegionId', description='_regionId'),
  partitionNum?: string(name='PartitionNum', description='partitionNum'),
}

model CreateTopicResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
}

async function createTopicWithOptions(request: CreateTopicRequest, runtime: Util.RuntimeOptions): CreateTopicResponse {
  Util.validateModel(request);
  return doRequest('CreateTopic', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function createTopic(request: CreateTopicRequest): CreateTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTopicWithOptions(request, runtime);
}

model DeleteConsumerGroupRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
  consumerId: string(name='ConsumerId', description='consumerId'),
  regionId: string(name='RegionId', description='_regionId'),
}

model DeleteConsumerGroupResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
}

async function deleteConsumerGroupWithOptions(request: DeleteConsumerGroupRequest, runtime: Util.RuntimeOptions): DeleteConsumerGroupResponse {
  Util.validateModel(request);
  return doRequest('DeleteConsumerGroup', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function deleteConsumerGroup(request: DeleteConsumerGroupRequest): DeleteConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteConsumerGroupWithOptions(request, runtime);
}

model DeleteTopicRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
  topic: string(name='Topic', description='topic'),
  regionId: string(name='RegionId', description='_regionId'),
}

model DeleteTopicResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
}

async function deleteTopicWithOptions(request: DeleteTopicRequest, runtime: Util.RuntimeOptions): DeleteTopicResponse {
  Util.validateModel(request);
  return doRequest('DeleteTopic', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function deleteTopic(request: DeleteTopicRequest): DeleteTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTopicWithOptions(request, runtime);
}

model GetConsumerListRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
  regionId: string(name='RegionId', description='_regionId'),
}

model GetConsumerListResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
  consumerList: {
    consumerVO: [
      {
        regionId: string(name='RegionId', description='regionId'),
        instanceId: string(name='InstanceId', description='instanceId'),
        consumerId: string(name='ConsumerId', description='consumerId'),
        tags: {
          tagVO: [
            {
              key: string(name='Key', description='key'),
              value: string(name='Value', description='value'),
            }
          ](name='TagVO', description='TagVO'),
        }(name='Tags', description='tags'),
      }
    ](name='ConsumerVO', description='ConsumerVO'),
  }(name='ConsumerList', description='data'),
}

async function getConsumerListWithOptions(request: GetConsumerListRequest, runtime: Util.RuntimeOptions): GetConsumerListResponse {
  Util.validateModel(request);
  return doRequest('GetConsumerList', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function getConsumerList(request: GetConsumerListRequest): GetConsumerListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConsumerListWithOptions(request, runtime);
}

model GetInstanceListRequest = {
  regionId: string(name='RegionId', description='_regionId'),
  orderId?: string(name='OrderId', description='orderId'),
  instanceId?: [ string ](name='InstanceId', description='instanceIds'),
  tag?: [
    {
      key?: string(name='Key', description='key'),
      value?: string(name='Value', description='value'),
    }
  ](name='Tag', description='tags'),
}

model GetInstanceListResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
  instanceList: {
    instanceVO: [
      {
        instanceId: string(name='InstanceId', description='instanceId'),
        regionId: string(name='RegionId', description='regionId'),
        serviceStatus: integer(name='ServiceStatus', description='serviceStatus'),
        vpcId: string(name='VpcId', description='vpcId'),
        vSwitchId: string(name='VSwitchId', description='vSwitchId'),
        endPoint: string(name='EndPoint', description='endPoint'),
        createTime: long(name='CreateTime', description='createTime'),
        expiredTime: long(name='ExpiredTime', description='expiredTime'),
        deployType: integer(name='DeployType', description='deployType'),
        sslEndPoint: string(name='SslEndPoint', description='sslEndPoint'),
        name: string(name='Name', description='name'),
        ioMax: integer(name='IoMax', description='ioMax'),
        eipMax: integer(name='EipMax', description='bandwidth'),
        diskType: integer(name='DiskType', description='diskType'),
        diskSize: integer(name='DiskSize', description='diskSize'),
        msgRetain: integer(name='MsgRetain', description='msgRetain'),
        topicNumLimit: integer(name='TopicNumLimit', description='topicNumLimit'),
        zoneId: string(name='ZoneId', description='zoneId'),
        paidType: integer(name='PaidType', description='paidType'),
        specType: string(name='SpecType', description='specType'),
        securityGroup: string(name='SecurityGroup', description='securityGroup'),
        upgradeServiceDetailInfo: {
          upgradeServiceDetailInfoVO: [
            {
              current2OpenSourceVersion: string(name='Current2OpenSourceVersion', description='current2OpenSourceVersion'),
            }
          ](name='UpgradeServiceDetailInfoVO', description='UpgradeServiceDetailInfoVO'),
        }(name='UpgradeServiceDetailInfo', description='upgradeServiceDetailInfo'),
        tags: {
          tagVO: [
            {
              key: string(name='Key', description='key'),
              value: string(name='Value', description='value'),
            }
          ](name='TagVO', description='TagVO'),
        }(name='Tags', description='tags'),
      }
    ](name='InstanceVO', description='InstanceVO'),
  }(name='InstanceList', description='data'),
}

async function getInstanceListWithOptions(request: GetInstanceListRequest, runtime: Util.RuntimeOptions): GetInstanceListResponse {
  Util.validateModel(request);
  return doRequest('GetInstanceList', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function getInstanceList(request: GetInstanceListRequest): GetInstanceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceListWithOptions(request, runtime);
}

model GetConsumerProgressRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
  consumerId: string(name='ConsumerId', description='consumerId'),
  regionId: string(name='RegionId', description='_regionId'),
}

model GetConsumerProgressResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
  consumerProgress: {
    totalDiff: long(name='TotalDiff', description='totalDiff'),
    lastTimestamp: long(name='LastTimestamp', description='lastTimestamp'),
    topicList: {
      topicList: [
        {
          topic: string(name='Topic', description='topic'),
          totalDiff: long(name='TotalDiff', description='totalDiff'),
          lastTimestamp: long(name='LastTimestamp', description='lastTimestamp'),
          offsetList: {
            offsetList: [
              {
                brokerOffset: long(name='BrokerOffset', description='brokerOffset'),
                consumerOffset: long(name='ConsumerOffset', description='consumerOffset'),
                lastTimestamp: long(name='LastTimestamp', description='lastTimestamp'),
                partition: integer(name='Partition', description='partition'),
              }
            ](name='OffsetList', description='OffsetList'),
          }(name='OffsetList', description='offsetList'),
        }
      ](name='TopicList', description='TopicList'),
    }(name='TopicList', description='progressOneTopics'),
  }(name='ConsumerProgress', description='data'),
}

async function getConsumerProgressWithOptions(request: GetConsumerProgressRequest, runtime: Util.RuntimeOptions): GetConsumerProgressResponse {
  Util.validateModel(request);
  return doRequest('GetConsumerProgress', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function getConsumerProgress(request: GetConsumerProgressRequest): GetConsumerProgressResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConsumerProgressWithOptions(request, runtime);
}

model GetTopicListRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
  currentPage?: string(name='CurrentPage', description='currentPage'),
  pageSize?: string(name='PageSize', description='pageSize'),
  regionId?: string(name='RegionId', description='_regionId'),
}

model GetTopicListResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
  total: integer(name='Total', description='total'),
  pageSize: integer(name='PageSize', description='pageSize'),
  currentPage: integer(name='CurrentPage', description='currentPage'),
  topicList: {
    topicVO: [
      {
        topic: string(name='Topic', description='topic'),
        createTime: long(name='CreateTime', description='createTime'),
        remark: string(name='Remark', description='remark'),
        status: integer(name='Status', description='status'),
        instanceId: string(name='InstanceId', description='instanceId'),
        regionId: string(name='RegionId', description='regionId'),
        statusName: string(name='StatusName', description='statusName'),
        compactTopic: boolean(name='CompactTopic', description='compactTopic'),
        localTopic: boolean(name='LocalTopic', description='localTopic'),
        partitionNum: integer(name='PartitionNum', description='partitionNum'),
        tags: {
          tagVO: [
            {
              key: string(name='Key', description='key'),
              value: string(name='Value', description='value'),
            }
          ](name='TagVO', description='TagVO'),
        }(name='Tags', description='tags'),
      }
    ](name='TopicVO', description='TopicVO'),
  }(name='TopicList', description='data'),
}

async function getTopicListWithOptions(request: GetTopicListRequest, runtime: Util.RuntimeOptions): GetTopicListResponse {
  Util.validateModel(request);
  return doRequest('GetTopicList', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function getTopicList(request: GetTopicListRequest): GetTopicListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTopicListWithOptions(request, runtime);
}

model GetTopicStatusRequest = {
  instanceId: string(name='InstanceId', description='instanceId'),
  topic: string(name='Topic', description='topic'),
  regionId?: string(name='RegionId', description='_regionId'),
}

model GetTopicStatusResponse = {
  success: boolean(name='Success', description='success'),
  requestId: string(name='RequestId', description='requestId'),
  code: integer(name='Code', description='code'),
  message: string(name='Message', description='message'),
  topicStatus: {
    totalCount: long(name='TotalCount', description='totalCount'),
    lastTimeStamp: long(name='LastTimeStamp', description='lastTimeStamp'),
    offsetTable: {
      offsetTable: [
        {
          minOffset: long(name='MinOffset', description='minOffset'),
          maxOffset: long(name='MaxOffset', description='maxOffset'),
          lastUpdateTimestamp: long(name='LastUpdateTimestamp', description='lastUpdateTimestamp'),
          topic: string(name='Topic', description='topic'),
          partition: integer(name='Partition', description='partition'),
        }
      ](name='OffsetTable', description='OffsetTable'),
    }(name='OffsetTable', description='offsetTable'),
  }(name='TopicStatus', description='data'),
}

async function getTopicStatusWithOptions(request: GetTopicStatusRequest, runtime: Util.RuntimeOptions): GetTopicStatusResponse {
  Util.validateModel(request);
  return doRequest('GetTopicStatus', 'HTTPS', 'POST', '2019-09-16', 'AK', null, request, runtime);
}

async function getTopicStatus(request: GetTopicStatusRequest): GetTopicStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTopicStatusWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
